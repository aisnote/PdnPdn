; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	?Extract@CPdnShellExtension@@UEAAJPEAPEAUHBITMAP__@@@Z ; CPdnShellExtension::Extract
PUBLIC	?GetLocation@CPdnShellExtension@@UEAAJPEA_WKPEAKPEBUtagSIZE@@K1@Z ; CPdnShellExtension::GetLocation
PUBLIC	?GetCurFile@CPdnShellExtension@@UEAAJPEAPEA_W@Z	; CPdnShellExtension::GetCurFile
PUBLIC	?SaveCompleted@CPdnShellExtension@@UEAAJPEB_W@Z	; CPdnShellExtension::SaveCompleted
PUBLIC	?Save@CPdnShellExtension@@UEAAJPEB_WH@Z		; CPdnShellExtension::Save
PUBLIC	?Load@CPdnShellExtension@@UEAAJPEB_WK@Z		; CPdnShellExtension::Load
PUBLIC	?IsDirty@CPdnShellExtension@@UEAAJXZ		; CPdnShellExtension::IsDirty
PUBLIC	?GetClassID@CPdnShellExtension@@UEAAJPEAU_GUID@@@Z ; CPdnShellExtension::GetClassID
PUBLIC	?Release@CPdnShellExtension@@UEAAKXZ		; CPdnShellExtension::Release
PUBLIC	?AddRef@CPdnShellExtension@@UEAAKXZ		; CPdnShellExtension::AddRef
PUBLIC	?QueryInterface@CPdnShellExtension@@UEAAJAEBU_GUID@@PEAPEAX@Z ; CPdnShellExtension::QueryInterface
PUBLIC	??_C@_1BA@JIHHIEDE@?$AAT?$AAy?$AAp?$AAe?$AAL?$AAi?$AAb?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BC@EAHCMADO@?$AAS?$AAo?$AAf?$AAt?$AAw?$AAa?$AAr?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1O@GBFINDKL@?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BC@IBECJAAI@?$AAS?$AAE?$AAC?$AAU?$AAR?$AAI?$AAT?$AAY?$AA?$AA@ ; `string'
PUBLIC	??_C@_17OMAOINJK@?$AAS?$AAA?$AAM?$AA?$AA@	; `string'
PUBLIC	??_C@_19HLLLM@?$AAM?$AAi?$AAm?$AAe?$AA?$AA@	; `string'
PUBLIC	??_C@_1BC@MAICEHGI@?$AAH?$AAa?$AAr?$AAd?$AAw?$AAa?$AAr?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BE@EKPAFMCP@?$AAI?$AAn?$AAt?$AAe?$AAr?$AAf?$AAa?$AAc?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BC@NKMMNMGL@?$AAF?$AAi?$AAl?$AAe?$AAT?$AAy?$AAp?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CK@OEKPKBNA@?$AAC?$AAo?$AAm?$AAp?$AAo?$AAn?$AAe?$AAn?$AAt?$AA?5?$AAC?$AAa?$AAt?$AAe?$AAg?$AAo?$AAr?$AAi?$AAe?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_1O@JDLOHAN@?$AAD?$AAe?$AAl?$AAe?$AAt?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BC@GCKHIPE@?$AAN?$AAo?$AAR?$AAe?$AAm?$AAo?$AAv?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BI@JFAIJMHL@?$AAF?$AAo?$AAr?$AAc?$AAe?$AAR?$AAe?$AAm?$AAo?$AAv?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_17LLMMEOJD@?$AAV?$AAa?$AAl?$AA?$AA@	; `string'
PUBLIC	??_C@_13OPKGLAFF@?$AAB?$AA?$AA@			; `string'
PUBLIC	??_C@_13MKMNOPIJ@?$AAD?$AA?$AA@			; `string'
PUBLIC	??_C@_13LHMFKAAD@?$AAM?$AA?$AA@			; `string'
PUBLIC	??_C@_13HADIAKP@?$AAS?$AA?$AA@			; `string'
PUBLIC	??0IPersist@@QEAA@XZ				; IPersist::IPersist
PUBLIC	??0IPersistFile@@QEAA@XZ			; IPersistFile::IPersistFile
PUBLIC	??0IExtractImage@@QEAA@XZ			; IExtractImage::IExtractImage
PUBLIC	?QueryInterface@CPdnShellExtension@@W7EAAJAEBU_GUID@@PEAPEAX@Z ; [thunk]:CPdnShellExtension::QueryInterface`adjustor{8}'
PUBLIC	?AddRef@CPdnShellExtension@@W7EAAKXZ		; [thunk]:CPdnShellExtension::AddRef`adjustor{8}'
PUBLIC	?Release@CPdnShellExtension@@W7EAAKXZ		; [thunk]:CPdnShellExtension::Release`adjustor{8}'
PUBLIC	??_GCPdnShellExtension@@QEAAPEAXI@Z		; CPdnShellExtension::`scalar deleting destructor'
PUBLIC	?strstr@@YAPEADPEADPEBD@Z			; strstr
PUBLIC	??0RectF@Gdiplus@@QEAA@MMMM@Z			; Gdiplus::RectF::RectF
PUBLIC	??0Rect@Gdiplus@@QEAA@HHHH@Z			; Gdiplus::Rect::Rect
PUBLIC	??0GdiplusStartupInput@Gdiplus@@QEAA@P6AXW4DebugEventLevel@1@PEAD@ZHH@Z ; Gdiplus::GdiplusStartupInput::GdiplusStartupInput
PUBLIC	??0Color@Gdiplus@@QEAA@K@Z			; Gdiplus::Color::Color
PUBLIC	?GetWidth@Image@Gdiplus@@QEAAIXZ		; Gdiplus::Image::GetWidth
PUBLIC	?GetHeight@Image@Gdiplus@@QEAAIXZ		; Gdiplus::Image::GetHeight
PUBLIC	?GetPixelFormat@Image@Gdiplus@@QEAAHXZ		; Gdiplus::Image::GetPixelFormat
PUBLIC	??0Bitmap@Gdiplus@@QEAA@PEAUIStream@@H@Z	; Gdiplus::Bitmap::Bitmap
PUBLIC	?FromStream@Bitmap@Gdiplus@@SAPEAV12@PEAUIStream@@H@Z ; Gdiplus::Bitmap::FromStream
PUBLIC	??0Bitmap@Gdiplus@@QEAA@HHH@Z			; Gdiplus::Bitmap::Bitmap
PUBLIC	??0Image@Gdiplus@@IEAA@XZ			; Gdiplus::Image::Image
PUBLIC	?SetNativeImage@Image@Gdiplus@@IEAAXPEAVGpImage@2@@Z ; Gdiplus::Image::SetNativeImage
PUBLIC	??0Image@Gdiplus@@IEAA@PEAVGpImage@1@W4Status@1@@Z ; Gdiplus::Image::Image
PUBLIC	?Clone@Image@Gdiplus@@UEAAPEAV12@XZ		; Gdiplus::Image::Clone
PUBLIC	??_GImage@Gdiplus@@UEAAPEAXI@Z			; Gdiplus::Image::`scalar deleting destructor'
PUBLIC	??1Image@Gdiplus@@UEAA@XZ			; Gdiplus::Image::~Image
PUBLIC	??1Bitmap@Gdiplus@@UEAA@XZ			; Gdiplus::Bitmap::~Bitmap
PUBLIC	??_GBitmap@Gdiplus@@UEAAPEAXI@Z			; Gdiplus::Bitmap::`scalar deleting destructor'
PUBLIC	??0Bitmap@Gdiplus@@IEAA@PEAVGpBitmap@1@@Z	; Gdiplus::Bitmap::Bitmap
PUBLIC	?Clone@Bitmap@Gdiplus@@QEAAPEAV12@HHHHH@Z	; Gdiplus::Bitmap::Clone
PUBLIC	?Clone@Bitmap@Gdiplus@@QEAAPEAV12@AEBVRect@2@H@Z ; Gdiplus::Bitmap::Clone
PUBLIC	?SetStatus@Image@Gdiplus@@IEBA?AW4Status@2@W432@@Z ; Gdiplus::Image::SetStatus
PUBLIC	?GetHBITMAP@Bitmap@Gdiplus@@QEAA?AW4Status@2@AEBVColor@2@PEAPEAUHBITMAP__@@@Z ; Gdiplus::Bitmap::GetHBITMAP
PUBLIC	??2GdiplusBase@Gdiplus@@SAPEAX_K@Z		; Gdiplus::GdiplusBase::operator new
PUBLIC	?SetNativeGraphics@Graphics@Gdiplus@@IEAAXPEAVGpGraphics@2@@Z ; Gdiplus::Graphics::SetNativeGraphics
PUBLIC	??0Graphics@Gdiplus@@QEAA@PEAVImage@1@@Z	; Gdiplus::Graphics::Graphics
PUBLIC	?FromImage@Graphics@Gdiplus@@SAPEAV12@PEAVImage@2@@Z ; Gdiplus::Graphics::FromImage
PUBLIC	?SetCompositingMode@Graphics@Gdiplus@@QEAA?AW4Status@2@W4CompositingMode@2@@Z ; Gdiplus::Graphics::SetCompositingMode
PUBLIC	?SetInterpolationMode@Graphics@Gdiplus@@QEAA?AW4Status@2@W4InterpolationMode@2@@Z ; Gdiplus::Graphics::SetInterpolationMode
PUBLIC	?SetPixelOffsetMode@Graphics@Gdiplus@@QEAA?AW4Status@2@W4PixelOffsetMode@2@@Z ; Gdiplus::Graphics::SetPixelOffsetMode
PUBLIC	?GetValue@Color@Gdiplus@@QEBAKXZ		; Gdiplus::Color::GetValue
PUBLIC	?Clear@Graphics@Gdiplus@@QEAA?AW4Status@2@AEBVColor@2@@Z ; Gdiplus::Graphics::Clear
PUBLIC	?SetStatus@Graphics@Gdiplus@@IEBA?AW4Status@2@W432@@Z ; Gdiplus::Graphics::SetStatus
PUBLIC	?DrawImage@Graphics@Gdiplus@@QEAA?AW4Status@2@PEAVImage@2@AEBVRectF@2@MMMMW4Unit@2@PEBVImageAttributes@2@P6AHPEAX@Z4@Z ; Gdiplus::Graphics::DrawImage
PUBLIC	??3GdiplusBase@Gdiplus@@SAXPEAX@Z		; Gdiplus::GdiplusBase::operator delete
PUBLIC	??1Graphics@Gdiplus@@QEAA@XZ			; Gdiplus::Graphics::~Graphics
PUBLIC	??_GGraphics@Gdiplus@@QEAAPEAXI@Z		; Gdiplus::Graphics::`scalar deleting destructor'
PUBLIC	?Base64DecodeGetRequiredLength@ATL@@YAHH@Z	; ATL::Base64DecodeGetRequiredLength
PUBLIC	?DecodeBase64Char@ATL@@YAHI@Z			; ATL::DecodeBase64Char
PUBLIC	?Base64Decode@ATL@@YAHPEBDHPEAEPEAH@Z		; ATL::Base64Decode
PUBLIC	?HRESULT_FROM_WIN32@@YAJK@Z			; HRESULT_FROM_WIN32
PUBLIC	?one@Thank_you@Define_the_symbol__ATL_MIXED@@UEAAXXZ ; Define_the_symbol__ATL_MIXED::Thank_you::one
PUBLIC	??0Thank_you@Define_the_symbol__ATL_MIXED@@QEAA@XZ ; Define_the_symbol__ATL_MIXED::Thank_you::Thank_you
PUBLIC	__pobjMapEntryFirst
PUBLIC	__pobjMapEntryLast
PUBLIC	??_C@_1M@KANJNLFF@?$AAC?$AAL?$AAS?$AAI?$AAD?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@EJNEECMJ@?$AAA?$AAp?$AAp?$AAI?$AAD?$AA?$AA@ ; `string'
PUBLIC	?rgszNeverDelete@CRegParser@ATL@@1QBQEB_WB	; ATL::CRegParser::rgszNeverDelete
PUBLIC	??_C@_0BL@DBLGMADH@CPdnShellExtension?3?3AddRef?$AA@ ; `string'
PUBLIC	??_C@_0BM@JOJIKBGG@CPdnShellExtension?3?3Release?$AA@ ; `string'
PUBLIC	??_C@_0CD@JHCJBIAM@CPdnShellExtension?3?3QueryInterfa@ ; `string'
PUBLIC	??_C@_0BP@KAIPFBKN@CPdnShellExtension?3?3GetClassID?$AA@ ; `string'
PUBLIC	??_C@_0BP@DDPHOJGA@CPdnShellExtension?3?3GetCurFile?$AA@ ; `string'
PUBLIC	??_C@_0BM@DENMPMBM@CPdnShellExtension?3?3IsDirty?$AA@ ; `string'
PUBLIC	??_C@_0BJ@NOGNPBDH@CPdnShellExtension?3?3Load?$AA@ ; `string'
PUBLIC	??_C@_0M@BFLKMDFB@filename?$DN?$CFS?$AA@	; `string'
PUBLIC	??_C@_07PFDFEF@mode?$DN?$CFu?$AA@		; `string'
PUBLIC	??_C@_0BJ@NMHAACOD@CPdnShellExtension?3?3Save?$AA@ ; `string'
PUBLIC	??_C@_0M@OMMMKBAH@fileName?$DN?$CFS?$AA@	; `string'
PUBLIC	??_C@_0CC@BMOPIGAE@CPdnShellExtension?3?3SaveComplete@ ; `string'
PUBLIC	??_C@_0BM@JMFFCPFO@CPdnShellExtension?3?3Extract?$AA@ ; `string'
PUBLIC	??_C@_0BL@MGDJGNNI@CreateFile?5failed?0?5hr?$DN0x?$CFx?$AA@ ; `string'
PUBLIC	??_C@_0BM@FMFLHODH@ReadFile?$CI1?$CJ?5failed?0?5hr?$DN0x?$CFx?$AA@ ; `string'
PUBLIC	??_C@_0BE@NLGGPDDE@we?5have?5a?5pdn3?5file?$AA@	; `string'
PUBLIC	??_C@_0BF@BNPIDFID@Read?5?$CL?5decode?5length?$AA@ ; `string'
PUBLIC	??_C@_0BM@PPANPIJO@ReadFile?$CI2?$CJ?5failed?0?5hr?$DN0x?$CFx?$AA@ ; `string'
PUBLIC	??_C@_0BA@NJGIKDMF@Allocate?5buffer?$AA@	; `string'
PUBLIC	??_C@_0BL@CKPLGBJG@pbHeaderBytes?5alloc?5failed?$AA@ ; `string'
PUBLIC	??_C@_0N@OAMJOJH@Read?5N?5bytes?$AA@		; `string'
PUBLIC	??_C@_0BM@CIOPHIMG@ReadFile?$CI3?$CJ?5failed?0?5hr?$DN0x?$CFx?$AA@ ; `string'
PUBLIC	??_C@_0BH@JEGMCECD@Convert?5to?5UTF8?5string?$AA@ ; `string'
PUBLIC	??_C@_0BE@LMEJEPMO@Search?5for?5?$CC?$DMthumb?$CC?$AA@ ; `string'
PUBLIC	??_C@_07JCJGGECG@?$DMthumb?5?$AA@		; `string'
PUBLIC	??_C@_0BP@LGHBILCM@Did?5not?5find?5opening?5tag?0?5?$CC?$CFs?$CC?$AA@ ; `string'
PUBLIC	??_C@_0BM@PHCNMIJC@Search?5for?5?$CCpng?$DN?$CC?5or?5?$CCgif?$DN?$CC?$AA@ ; `string'
PUBLIC	??_C@_05EOONGFOI@png?$DN?$CC?$AA@		; `string'
PUBLIC	??_C@_05FKKCOMLO@gif?$DN?$CC?$AA@		; `string'
PUBLIC	??_C@_0BL@EDOGHBJD@Did?5not?5find?5png?5tag?0?5?$CC?$CFs?$CC?$AA@ ; `string'
PUBLIC	??_C@_0BL@KGEPKNAI@Did?5not?5find?5gif?5tag?0?5?$CC?$CFs?$CC?$AA@ ; `string'
PUBLIC	??_C@_0N@KFIHLOHI@Search?5for?5?$CC?$AA@	; `string'
PUBLIC	??_C@_01BJJEKLCA@?$CC?$AA@			; `string'
PUBLIC	??_C@_0CB@CAHDGFFO@Did?5not?5find?5closing?5quote?0?5?$CC?$CFs?$CC@ ; `string'
PUBLIC	??_C@_0EH@FOMDMKJD@Stomp?5out?5the?5portion?5of?5the?5str@ ; `string'
PUBLIC	??_C@_0BB@CCCEGODB@iImgBase64Len?$DN?$CFd?$AA@	; `string'
PUBLIC	??_C@_0EC@KCAIIOOB@Get?5required?5length?5of?5byte?$FL?$FN?5ar@ ; `string'
PUBLIC	??_C@_0N@IBGOHNOE@nImgBytes?$DN?$CFd?$AA@	; `string'
PUBLIC	??_C@_0DG@JOAFMEGE@Allocate?5?$CFd?5byte?5buffer?5for?5base@ ; `string'
PUBLIC	??_C@_0BI@GPFLLHGL@pbImgBytes?5alloc?5failed?$AA@ ; `string'
PUBLIC	??_C@_0BO@BEDNBMFK@Convert?5from?5base64?5to?5byte?$FL?$FN?$AA@ ; `string'
PUBLIC	??_C@_0BE@JCLDCCEI@Base64Decode?5failed?$AA@	; `string'
PUBLIC	??_C@_0N@MGEALFHP@iImgLen?5?$DN?5?$CFd?$AA@	; `string'
PUBLIC	??_C@_0BP@EONCIIPM@Wrap?5a?5memory?5stream?5around?5it?$AA@ ; `string'
PUBLIC	??_C@_0BL@LFMBEFIM@pMemoryStream?5alloc?5failed?$AA@ ; `string'
PUBLIC	??_C@_0N@FFMEJMDB@Startup?5GDI?$CL?$AA@		; `string'
PUBLIC	??_C@_0BG@BKINCINP@GdiplusStartup?5failed?$AA@	; `string'
PUBLIC	??_C@_0L@CABDKHLD@Load?5image?$AA@		; `string'
PUBLIC	??_C@_0CB@MPPDABAC@Bitmap?3?3FromStream?5returned?5NULL@ ; `string'
PUBLIC	??_C@_0BE@FPMEADDO@Get?5HBITMAP?5from?5it?$AA@	; `string'
PUBLIC	??_C@_09HAOJGDGP@status?$DN?$CFd?$AA@		; `string'
PUBLIC	??_C@_0CL@EGOAEGAG@pResizedBitmap?9?$DOGetHBITMAP?5faile@ ; `string'
PUBLIC	??_C@_0EG@OHAGDJCJ@pResizedBitmap?9?$DOGetHBITMAP?5faile@ ; `string'
PUBLIC	??_C@_0BL@GPOBMODA@Give?5bitmap?5to?5the?5caller?$CB?$AA@ ; `string'
PUBLIC	??_C@_07CLEOFAGA@Cleanup?$AA@			; `string'
PUBLIC	??_C@_0CA@PNAELGIJ@CPdnShellExtension?3?3GetLocation?$AA@ ; `string'
PUBLIC	??_C@_0BB@FEIPGDJC@pszPathBuffer?$DN?$CFS?$AA@	; `string'
PUBLIC	??_C@_09BBMGEBJ@cchMax?$DN?$CFu?$AA@		; `string'
PUBLIC	??_C@_0BG@GDBLMLEL@pszPathBuffer?5is?5NULL?$AA@	; `string'
PUBLIC	??_C@_0BE@OLEPLOML@pdwPriority?5is?5NULL?$AA@	; `string'
PUBLIC	??_C@_0BB@HBPIANIE@pdwFlags?5is?5NULL?$AA@	; `string'
PUBLIC	??_C@_0BA@IDFBKKE@prgSize?5is?5NULL?$AA@	; `string'
PUBLIC	??_C@_0P@JIGAMKEA@?$CKpdwFlags?5?$DN?5?$CFu?$AA@ ; `string'
PUBLIC	??_C@_0BA@OBCKIJON@prgSize?$DN?$CFd?5x?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0BB@BCCMLPJA@m_size?5?$DN?5?$CFd?5x?5?$CFd?$AA@ ; `string'
PUBLIC	??_7CPdnShellExtension@@6BIPersistFile@@@	; CPdnShellExtension::`vftable'
PUBLIC	??_7CPdnShellExtension@@6BIExtractImage@@@	; CPdnShellExtension::`vftable'
PUBLIC	??_7Bitmap@Gdiplus@@6B@				; Gdiplus::Bitmap::`vftable'
PUBLIC	??_7Image@Gdiplus@@6B@				; Gdiplus::Image::`vftable'
PUBLIC	??_7Thank_you@Define_the_symbol__ATL_MIXED@@6B@	; Define_the_symbol__ATL_MIXED::Thank_you::`vftable'
EXTRN	IID_IPersistFile:BYTE
EXTRN	IID_IExtractImage:BYTE
EXTRN	__imp_SysAllocString:PROC
EXTRN	__imp_SysFreeString:PROC
EXTRN	GdiplusStartup:PROC
EXTRN	strstr:PROC
EXTRN	__imp_CloseHandle:PROC
EXTRN	__imp_CreateFileW:PROC
EXTRN	GdiplusShutdown:PROC
EXTRN	GdipGetImageWidth:PROC
EXTRN	GdipGetImageHeight:PROC
EXTRN	GdipGetImagePixelFormat:PROC
EXTRN	GdipCreateBitmapFromStream:PROC
EXTRN	GdipCreateBitmapFromStreamICM:PROC
EXTRN	GdipCreateBitmapFromScan0:PROC
EXTRN	GdipCloneImage:PROC
EXTRN	??_EImage@Gdiplus@@UEAAPEAXI@Z:PROC		; Gdiplus::Image::`vector deleting destructor'
EXTRN	??_EBitmap@Gdiplus@@UEAAPEAXI@Z:PROC		; Gdiplus::Bitmap::`vector deleting destructor'
EXTRN	GdipDisposeImage:PROC
EXTRN	GdipCloneBitmapAreaI:PROC
EXTRN	GdipCreateHBITMAPFromBitmap:PROC
EXTRN	GdipAlloc:PROC
EXTRN	GdipGetImageGraphicsContext:PROC
EXTRN	GdipSetCompositingMode:PROC
EXTRN	GdipSetInterpolationMode:PROC
EXTRN	GdipSetPixelOffsetMode:PROC
EXTRN	GdipGraphicsClear:PROC
EXTRN	GdipDrawImageRectRect:PROC
EXTRN	GdipFree:PROC
EXTRN	GdipDeleteGraphics:PROC
EXTRN	??_U@YAPEAX_K@Z:PROC				; operator new[]
EXTRN	??_V@YAXPEAX@Z:PROC				; operator delete[]
EXTRN	__imp_ReadFile:PROC
EXTRN	__imp_VerSetConditionMask:PROC
EXTRN	__imp_GetLastError:PROC
EXTRN	__imp_VerifyVersionInfoW:PROC
GenericSansSerifFontFamilyBuffer DB 010H DUP (?)
GenericSerifFontFamilyBuffer DB 010H DUP (?)
GenericMonospaceFontFamilyBuffer DB 010H DUP (?)
GenericTypographicStringFormatBuffer DB 010H DUP (?)
GenericDefaultStringFormatBuffer DB 010H DUP (?)
;	COMDAT ??_7Thank_you@Define_the_symbol__ATL_MIXED@@6B@
CONST	SEGMENT
??_7Thank_you@Define_the_symbol__ATL_MIXED@@6B@ DQ FLAT:?one@Thank_you@Define_the_symbol__ATL_MIXED@@UEAAXXZ ; Define_the_symbol__ATL_MIXED::Thank_you::`vftable'
CONST	ENDS
;	COMDAT ??_7Image@Gdiplus@@6B@
CONST	SEGMENT
??_7Image@Gdiplus@@6B@ DQ FLAT:??_EImage@Gdiplus@@UEAAPEAXI@Z ; Gdiplus::Image::`vftable'
	DQ	FLAT:?Clone@Image@Gdiplus@@UEAAPEAV12@XZ
CONST	ENDS
;	COMDAT ??_7Bitmap@Gdiplus@@6B@
CONST	SEGMENT
??_7Bitmap@Gdiplus@@6B@ DQ FLAT:??_EBitmap@Gdiplus@@UEAAPEAXI@Z ; Gdiplus::Bitmap::`vftable'
	DQ	FLAT:?Clone@Image@Gdiplus@@UEAAPEAV12@XZ
CONST	ENDS
;	COMDAT ??_7CPdnShellExtension@@6BIExtractImage@@@
CONST	SEGMENT
??_7CPdnShellExtension@@6BIExtractImage@@@ DQ FLAT:?QueryInterface@CPdnShellExtension@@W7EAAJAEBU_GUID@@PEAPEAX@Z ; CPdnShellExtension::`vftable'
	DQ	FLAT:?AddRef@CPdnShellExtension@@W7EAAKXZ
	DQ	FLAT:?Release@CPdnShellExtension@@W7EAAKXZ
	DQ	FLAT:?GetLocation@CPdnShellExtension@@UEAAJPEA_WKPEAKPEBUtagSIZE@@K1@Z
	DQ	FLAT:?Extract@CPdnShellExtension@@UEAAJPEAPEAUHBITMAP__@@@Z
CONST	ENDS
;	COMDAT ??_7CPdnShellExtension@@6BIPersistFile@@@
CONST	SEGMENT
??_7CPdnShellExtension@@6BIPersistFile@@@ DQ FLAT:?QueryInterface@CPdnShellExtension@@UEAAJAEBU_GUID@@PEAPEAX@Z ; CPdnShellExtension::`vftable'
	DQ	FLAT:?AddRef@CPdnShellExtension@@UEAAKXZ
	DQ	FLAT:?Release@CPdnShellExtension@@UEAAKXZ
	DQ	FLAT:?GetClassID@CPdnShellExtension@@UEAAJPEAU_GUID@@@Z
	DQ	FLAT:?IsDirty@CPdnShellExtension@@UEAAJXZ
	DQ	FLAT:?Load@CPdnShellExtension@@UEAAJPEB_WK@Z
	DQ	FLAT:?Save@CPdnShellExtension@@UEAAJPEB_WH@Z
	DQ	FLAT:?SaveCompleted@CPdnShellExtension@@UEAAJPEB_W@Z
	DQ	FLAT:?GetCurFile@CPdnShellExtension@@UEAAJPEAPEA_W@Z
CONST	ENDS
;	COMDAT ??_C@_0BB@BCCMLPJA@m_size?5?$DN?5?$CFd?5x?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BB@BCCMLPJA@m_size?5?$DN?5?$CFd?5x?5?$CFd?$AA@ DB 'm_size = %d x %'
	DB	'd', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@OBCKIJON@prgSize?$DN?$CFd?5x?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BA@OBCKIJON@prgSize?$DN?$CFd?5x?5?$CFd?$AA@ DB 'prgSize=%d x %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@JIGAMKEA@?$CKpdwFlags?5?$DN?5?$CFu?$AA@
CONST	SEGMENT
??_C@_0P@JIGAMKEA@?$CKpdwFlags?5?$DN?5?$CFu?$AA@ DB '*pdwFlags = %u', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@IDFBKKE@prgSize?5is?5NULL?$AA@
CONST	SEGMENT
??_C@_0BA@IDFBKKE@prgSize?5is?5NULL?$AA@ DB 'prgSize is NULL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@HBPIANIE@pdwFlags?5is?5NULL?$AA@
CONST	SEGMENT
??_C@_0BB@HBPIANIE@pdwFlags?5is?5NULL?$AA@ DB 'pdwFlags is NULL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@OLEPLOML@pdwPriority?5is?5NULL?$AA@
CONST	SEGMENT
??_C@_0BE@OLEPLOML@pdwPriority?5is?5NULL?$AA@ DB 'pdwPriority is NULL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@GDBLMLEL@pszPathBuffer?5is?5NULL?$AA@
CONST	SEGMENT
??_C@_0BG@GDBLMLEL@pszPathBuffer?5is?5NULL?$AA@ DB 'pszPathBuffer is NULL'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_09BBMGEBJ@cchMax?$DN?$CFu?$AA@
CONST	SEGMENT
??_C@_09BBMGEBJ@cchMax?$DN?$CFu?$AA@ DB 'cchMax=%u', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FEIPGDJC@pszPathBuffer?$DN?$CFS?$AA@
CONST	SEGMENT
??_C@_0BB@FEIPGDJC@pszPathBuffer?$DN?$CFS?$AA@ DB 'pszPathBuffer=%S', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@PNAELGIJ@CPdnShellExtension?3?3GetLocation?$AA@
CONST	SEGMENT
??_C@_0CA@PNAELGIJ@CPdnShellExtension?3?3GetLocation?$AA@ DB 'CPdnShellEx'
	DB	'tension::GetLocation', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07CLEOFAGA@Cleanup?$AA@
CONST	SEGMENT
??_C@_07CLEOFAGA@Cleanup?$AA@ DB 'Cleanup', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@GPOBMODA@Give?5bitmap?5to?5the?5caller?$CB?$AA@
CONST	SEGMENT
??_C@_0BL@GPOBMODA@Give?5bitmap?5to?5the?5caller?$CB?$AA@ DB 'Give bitmap'
	DB	' to the caller!', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@OHAGDJCJ@pResizedBitmap?9?$DOGetHBITMAP?5faile@
CONST	SEGMENT
??_C@_0EG@OHAGDJCJ@pResizedBitmap?9?$DOGetHBITMAP?5faile@ DB 'pResizedBit'
	DB	'map->GetHBITMAP failed, not Win32Error, hr is now = E_FAIL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@EGOAEGAG@pResizedBitmap?9?$DOGetHBITMAP?5faile@
CONST	SEGMENT
??_C@_0CL@EGOAEGAG@pResizedBitmap?9?$DOGetHBITMAP?5faile@ DB 'pResizedBit'
	DB	'map->GetHBITMAP failed, hr=0x%x', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09HAOJGDGP@status?$DN?$CFd?$AA@
CONST	SEGMENT
??_C@_09HAOJGDGP@status?$DN?$CFd?$AA@ DB 'status=%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@FPMEADDO@Get?5HBITMAP?5from?5it?$AA@
CONST	SEGMENT
??_C@_0BE@FPMEADDO@Get?5HBITMAP?5from?5it?$AA@ DB 'Get HBITMAP from it', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@MPPDABAC@Bitmap?3?3FromStream?5returned?5NULL@
CONST	SEGMENT
??_C@_0CB@MPPDABAC@Bitmap?3?3FromStream?5returned?5NULL@ DB 'Bitmap::From'
	DB	'Stream returned NULL', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@CABDKHLD@Load?5image?$AA@
CONST	SEGMENT
??_C@_0L@CABDKHLD@Load?5image?$AA@ DB 'Load image', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@BKINCINP@GdiplusStartup?5failed?$AA@
CONST	SEGMENT
??_C@_0BG@BKINCINP@GdiplusStartup?5failed?$AA@ DB 'GdiplusStartup failed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FFMEJMDB@Startup?5GDI?$CL?$AA@
CONST	SEGMENT
??_C@_0N@FFMEJMDB@Startup?5GDI?$CL?$AA@ DB 'Startup GDI+', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@LFMBEFIM@pMemoryStream?5alloc?5failed?$AA@
CONST	SEGMENT
??_C@_0BL@LFMBEFIM@pMemoryStream?5alloc?5failed?$AA@ DB 'pMemoryStream al'
	DB	'loc failed', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@EONCIIPM@Wrap?5a?5memory?5stream?5around?5it?$AA@
CONST	SEGMENT
??_C@_0BP@EONCIIPM@Wrap?5a?5memory?5stream?5around?5it?$AA@ DB 'Wrap a me'
	DB	'mory stream around it', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MGEALFHP@iImgLen?5?$DN?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0N@MGEALFHP@iImgLen?5?$DN?5?$CFd?$AA@ DB 'iImgLen = %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@JCLDCCEI@Base64Decode?5failed?$AA@
CONST	SEGMENT
??_C@_0BE@JCLDCCEI@Base64Decode?5failed?$AA@ DB 'Base64Decode failed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@BEDNBMFK@Convert?5from?5base64?5to?5byte?$FL?$FN?$AA@
CONST	SEGMENT
??_C@_0BO@BEDNBMFK@Convert?5from?5base64?5to?5byte?$FL?$FN?$AA@ DB 'Conve'
	DB	'rt from base64 to byte[]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@GPFLLHGL@pbImgBytes?5alloc?5failed?$AA@
CONST	SEGMENT
??_C@_0BI@GPFLLHGL@pbImgBytes?5alloc?5failed?$AA@ DB 'pbImgBytes alloc fa'
	DB	'iled', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@JOAFMEGE@Allocate?5?$CFd?5byte?5buffer?5for?5base@
CONST	SEGMENT
??_C@_0DG@JOAFMEGE@Allocate?5?$CFd?5byte?5buffer?5for?5base@ DB 'Allocate'
	DB	' %d byte buffer for base64->byte[] conversion', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@IBGOHNOE@nImgBytes?$DN?$CFd?$AA@
CONST	SEGMENT
??_C@_0N@IBGOHNOE@nImgBytes?$DN?$CFd?$AA@ DB 'nImgBytes=%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EC@KCAIIOOB@Get?5required?5length?5of?5byte?$FL?$FN?5ar@
CONST	SEGMENT
??_C@_0EC@KCAIIOOB@Get?5required?5length?5of?5byte?$FL?$FN?5ar@ DB 'Get r'
	DB	'equired length of byte[] array for base64->byte[] conversion', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@CCCEGODB@iImgBase64Len?$DN?$CFd?$AA@
CONST	SEGMENT
??_C@_0BB@CCCEGODB@iImgBase64Len?$DN?$CFd?$AA@ DB 'iImgBase64Len=%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@FOMDMKJD@Stomp?5out?5the?5portion?5of?5the?5str@
CONST	SEGMENT
??_C@_0EH@FOMDMKJD@Stomp?5out?5the?5portion?5of?5the?5str@ DB 'Stomp out '
	DB	'the portion of the string that is the image in base64 format', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@CAHDGFFO@Did?5not?5find?5closing?5quote?0?5?$CC?$CFs?$CC@
CONST	SEGMENT
??_C@_0CB@CAHDGFFO@Did?5not?5find?5closing?5quote?0?5?$CC?$CFs?$CC@ DB 'D'
	DB	'id not find closing quote, "%s"', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01BJJEKLCA@?$CC?$AA@
CONST	SEGMENT
??_C@_01BJJEKLCA@?$CC?$AA@ DB '"', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KFIHLOHI@Search?5for?5?$CC?$AA@
CONST	SEGMENT
??_C@_0N@KFIHLOHI@Search?5for?5?$CC?$AA@ DB 'Search for "', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@KGEPKNAI@Did?5not?5find?5gif?5tag?0?5?$CC?$CFs?$CC?$AA@
CONST	SEGMENT
??_C@_0BL@KGEPKNAI@Did?5not?5find?5gif?5tag?0?5?$CC?$CFs?$CC?$AA@ DB 'Did'
	DB	' not find gif tag, "%s"', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@EDOGHBJD@Did?5not?5find?5png?5tag?0?5?$CC?$CFs?$CC?$AA@
CONST	SEGMENT
??_C@_0BL@EDOGHBJD@Did?5not?5find?5png?5tag?0?5?$CC?$CFs?$CC?$AA@ DB 'Did'
	DB	' not find png tag, "%s"', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05FKKCOMLO@gif?$DN?$CC?$AA@
CONST	SEGMENT
??_C@_05FKKCOMLO@gif?$DN?$CC?$AA@ DB 'gif="', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05EOONGFOI@png?$DN?$CC?$AA@
CONST	SEGMENT
??_C@_05EOONGFOI@png?$DN?$CC?$AA@ DB 'png="', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@PHCNMIJC@Search?5for?5?$CCpng?$DN?$CC?5or?5?$CCgif?$DN?$CC?$AA@
CONST	SEGMENT
??_C@_0BM@PHCNMIJC@Search?5for?5?$CCpng?$DN?$CC?5or?5?$CCgif?$DN?$CC?$AA@ DB 'S'
	DB	'earch for "png=" or "gif="', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@LGHBILCM@Did?5not?5find?5opening?5tag?0?5?$CC?$CFs?$CC?$AA@
CONST	SEGMENT
??_C@_0BP@LGHBILCM@Did?5not?5find?5opening?5tag?0?5?$CC?$CFs?$CC?$AA@ DB 'D'
	DB	'id not find opening tag, "%s"', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07JCJGGECG@?$DMthumb?5?$AA@
CONST	SEGMENT
??_C@_07JCJGGECG@?$DMthumb?5?$AA@ DB '<thumb ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@LMEJEPMO@Search?5for?5?$CC?$DMthumb?$CC?$AA@
CONST	SEGMENT
??_C@_0BE@LMEJEPMO@Search?5for?5?$CC?$DMthumb?$CC?$AA@ DB 'Search for "<t'
	DB	'humb"', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@JEGMCECD@Convert?5to?5UTF8?5string?$AA@
CONST	SEGMENT
??_C@_0BH@JEGMCECD@Convert?5to?5UTF8?5string?$AA@ DB 'Convert to UTF8 str'
	DB	'ing', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@CIOPHIMG@ReadFile?$CI3?$CJ?5failed?0?5hr?$DN0x?$CFx?$AA@
CONST	SEGMENT
??_C@_0BM@CIOPHIMG@ReadFile?$CI3?$CJ?5failed?0?5hr?$DN0x?$CFx?$AA@ DB 'Re'
	DB	'adFile(3) failed, hr=0x%x', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@OAMJOJH@Read?5N?5bytes?$AA@
CONST	SEGMENT
??_C@_0N@OAMJOJH@Read?5N?5bytes?$AA@ DB 'Read N bytes', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@CKPLGBJG@pbHeaderBytes?5alloc?5failed?$AA@
CONST	SEGMENT
??_C@_0BL@CKPLGBJG@pbHeaderBytes?5alloc?5failed?$AA@ DB 'pbHeaderBytes al'
	DB	'loc failed', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@NJGIKDMF@Allocate?5buffer?$AA@
CONST	SEGMENT
??_C@_0BA@NJGIKDMF@Allocate?5buffer?$AA@ DB 'Allocate buffer', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@PPANPIJO@ReadFile?$CI2?$CJ?5failed?0?5hr?$DN0x?$CFx?$AA@
CONST	SEGMENT
??_C@_0BM@PPANPIJO@ReadFile?$CI2?$CJ?5failed?0?5hr?$DN0x?$CFx?$AA@ DB 'Re'
	DB	'adFile(2) failed, hr=0x%x', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@BNPIDFID@Read?5?$CL?5decode?5length?$AA@
CONST	SEGMENT
??_C@_0BF@BNPIDFID@Read?5?$CL?5decode?5length?$AA@ DB 'Read + decode leng'
	DB	'th', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@NLGGPDDE@we?5have?5a?5pdn3?5file?$AA@
CONST	SEGMENT
??_C@_0BE@NLGGPDDE@we?5have?5a?5pdn3?5file?$AA@ DB 'we have a pdn3 file', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@FMFLHODH@ReadFile?$CI1?$CJ?5failed?0?5hr?$DN0x?$CFx?$AA@
CONST	SEGMENT
??_C@_0BM@FMFLHODH@ReadFile?$CI1?$CJ?5failed?0?5hr?$DN0x?$CFx?$AA@ DB 'Re'
	DB	'adFile(1) failed, hr=0x%x', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@MGDJGNNI@CreateFile?5failed?0?5hr?$DN0x?$CFx?$AA@
CONST	SEGMENT
??_C@_0BL@MGDJGNNI@CreateFile?5failed?0?5hr?$DN0x?$CFx?$AA@ DB 'CreateFil'
	DB	'e failed, hr=0x%x', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@JMFFCPFO@CPdnShellExtension?3?3Extract?$AA@
CONST	SEGMENT
??_C@_0BM@JMFFCPFO@CPdnShellExtension?3?3Extract?$AA@ DB 'CPdnShellExtens'
	DB	'ion::Extract', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@BMOPIGAE@CPdnShellExtension?3?3SaveComplete@
CONST	SEGMENT
??_C@_0CC@BMOPIGAE@CPdnShellExtension?3?3SaveComplete@ DB 'CPdnShellExten'
	DB	'sion::SaveCompleted', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OMMMKBAH@fileName?$DN?$CFS?$AA@
CONST	SEGMENT
??_C@_0M@OMMMKBAH@fileName?$DN?$CFS?$AA@ DB 'fileName=%S', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@NMHAACOD@CPdnShellExtension?3?3Save?$AA@
CONST	SEGMENT
??_C@_0BJ@NMHAACOD@CPdnShellExtension?3?3Save?$AA@ DB 'CPdnShellExtension'
	DB	'::Save', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_07PFDFEF@mode?$DN?$CFu?$AA@
CONST	SEGMENT
??_C@_07PFDFEF@mode?$DN?$CFu?$AA@ DB 'mode=%u', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BFLKMDFB@filename?$DN?$CFS?$AA@
CONST	SEGMENT
??_C@_0M@BFLKMDFB@filename?$DN?$CFS?$AA@ DB 'filename=%S', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@NOGNPBDH@CPdnShellExtension?3?3Load?$AA@
CONST	SEGMENT
??_C@_0BJ@NOGNPBDH@CPdnShellExtension?3?3Load?$AA@ DB 'CPdnShellExtension'
	DB	'::Load', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@DENMPMBM@CPdnShellExtension?3?3IsDirty?$AA@
CONST	SEGMENT
??_C@_0BM@DENMPMBM@CPdnShellExtension?3?3IsDirty?$AA@ DB 'CPdnShellExtens'
	DB	'ion::IsDirty', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@DDPHOJGA@CPdnShellExtension?3?3GetCurFile?$AA@
CONST	SEGMENT
??_C@_0BP@DDPHOJGA@CPdnShellExtension?3?3GetCurFile?$AA@ DB 'CPdnShellExt'
	DB	'ension::GetCurFile', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@KAIPFBKN@CPdnShellExtension?3?3GetClassID?$AA@
CONST	SEGMENT
??_C@_0BP@KAIPFBKN@CPdnShellExtension?3?3GetClassID?$AA@ DB 'CPdnShellExt'
	DB	'ension::GetClassID', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@JHCJBIAM@CPdnShellExtension?3?3QueryInterfa@
CONST	SEGMENT
??_C@_0CD@JHCJBIAM@CPdnShellExtension?3?3QueryInterfa@ DB 'CPdnShellExten'
	DB	'sion::QueryInterface', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@JOJIKBGG@CPdnShellExtension?3?3Release?$AA@
CONST	SEGMENT
??_C@_0BM@JOJIKBGG@CPdnShellExtension?3?3Release?$AA@ DB 'CPdnShellExtens'
	DB	'ion::Release', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@DBLGMADH@CPdnShellExtension?3?3AddRef?$AA@
CONST	SEGMENT
??_C@_0BL@DBLGMADH@CPdnShellExtension?3?3AddRef?$AA@ DB 'CPdnShellExtensi'
	DB	'on::AddRef', 00H				; `string'
CONST	ENDS
;	COMDAT ?rgszNeverDelete@CRegParser@ATL@@1QBQEB_WB
CONST	SEGMENT
?rgszNeverDelete@CRegParser@ATL@@1QBQEB_WB DQ FLAT:??_C@_1M@EJNEECMJ@?$AAA?$AAp?$AAp?$AAI?$AAD?$AA?$AA@ ; ATL::CRegParser::rgszNeverDelete
	DQ	FLAT:??_C@_1M@KANJNLFF@?$AAC?$AAL?$AAS?$AAI?$AAD?$AA?$AA@
	DQ	FLAT:??_C@_1CK@OEKPKBNA@?$AAC?$AAo?$AAm?$AAp?$AAo?$AAn?$AAe?$AAn?$AAt?$AA?5?$AAC?$AAa?$AAt?$AAe?$AAg?$AAo?$AAr?$AAi?$AAe?$AAs?$AA?$AA@
	DQ	FLAT:??_C@_1BC@NKMMNMGL@?$AAF?$AAi?$AAl?$AAe?$AAT?$AAy?$AAp?$AAe?$AA?$AA@
	DQ	FLAT:??_C@_1BE@EKPAFMCP@?$AAI?$AAn?$AAt?$AAe?$AAr?$AAf?$AAa?$AAc?$AAe?$AA?$AA@
	DQ	FLAT:??_C@_1BC@MAICEHGI@?$AAH?$AAa?$AAr?$AAd?$AAw?$AAa?$AAr?$AAe?$AA?$AA@
	DQ	FLAT:??_C@_19HLLLM@?$AAM?$AAi?$AAm?$AAe?$AA?$AA@
	DQ	FLAT:??_C@_17OMAOINJK@?$AAS?$AAA?$AAM?$AA?$AA@
	DQ	FLAT:??_C@_1BC@IBECJAAI@?$AAS?$AAE?$AAC?$AAU?$AAR?$AAI?$AAT?$AAY?$AA?$AA@
	DQ	FLAT:??_C@_1O@GBFINDKL@?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?$AA@
	DQ	FLAT:??_C@_1BC@EAHCMADO@?$AAS?$AAo?$AAf?$AAt?$AAw?$AAa?$AAr?$AAe?$AA?$AA@
	DQ	FLAT:??_C@_1BA@JIHHIEDE@?$AAT?$AAy?$AAp?$AAe?$AAL?$AAi?$AAb?$AA?$AA@
CONST	ENDS
;	COMDAT ??_C@_1BA@JIHHIEDE@?$AAT?$AAy?$AAp?$AAe?$AAL?$AAi?$AAb?$AA?$AA@
CONST	SEGMENT
??_C@_1BA@JIHHIEDE@?$AAT?$AAy?$AAp?$AAe?$AAL?$AAi?$AAb?$AA?$AA@ DB 'T', 00H
	DB	'y', 00H, 'p', 00H, 'e', 00H, 'L', 00H, 'i', 00H, 'b', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1BC@EAHCMADO@?$AAS?$AAo?$AAf?$AAt?$AAw?$AAa?$AAr?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1BC@EAHCMADO@?$AAS?$AAo?$AAf?$AAt?$AAw?$AAa?$AAr?$AAe?$AA?$AA@ DB 'S'
	DB	00H, 'o', 00H, 'f', 00H, 't', 00H, 'w', 00H, 'a', 00H, 'r', 00H
	DB	'e', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@GBFINDKL@?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?$AA@
CONST	SEGMENT
??_C@_1O@GBFINDKL@?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM?$AA?$AA@ DB 'S', 00H, 'Y'
	DB	00H, 'S', 00H, 'T', 00H, 'E', 00H, 'M', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BC@IBECJAAI@?$AAS?$AAE?$AAC?$AAU?$AAR?$AAI?$AAT?$AAY?$AA?$AA@
CONST	SEGMENT
??_C@_1BC@IBECJAAI@?$AAS?$AAE?$AAC?$AAU?$AAR?$AAI?$AAT?$AAY?$AA?$AA@ DB 'S'
	DB	00H, 'E', 00H, 'C', 00H, 'U', 00H, 'R', 00H, 'I', 00H, 'T', 00H
	DB	'Y', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_17OMAOINJK@?$AAS?$AAA?$AAM?$AA?$AA@
CONST	SEGMENT
??_C@_17OMAOINJK@?$AAS?$AAA?$AAM?$AA?$AA@ DB 'S', 00H, 'A', 00H, 'M', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_19HLLLM@?$AAM?$AAi?$AAm?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_19HLLLM@?$AAM?$AAi?$AAm?$AAe?$AA?$AA@ DB 'M', 00H, 'i', 00H, 'm', 00H
	DB	'e', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BC@MAICEHGI@?$AAH?$AAa?$AAr?$AAd?$AAw?$AAa?$AAr?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1BC@MAICEHGI@?$AAH?$AAa?$AAr?$AAd?$AAw?$AAa?$AAr?$AAe?$AA?$AA@ DB 'H'
	DB	00H, 'a', 00H, 'r', 00H, 'd', 00H, 'w', 00H, 'a', 00H, 'r', 00H
	DB	'e', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BE@EKPAFMCP@?$AAI?$AAn?$AAt?$AAe?$AAr?$AAf?$AAa?$AAc?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1BE@EKPAFMCP@?$AAI?$AAn?$AAt?$AAe?$AAr?$AAf?$AAa?$AAc?$AAe?$AA?$AA@ DB 'I'
	DB	00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'f', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1BC@NKMMNMGL@?$AAF?$AAi?$AAl?$AAe?$AAT?$AAy?$AAp?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1BC@NKMMNMGL@?$AAF?$AAi?$AAl?$AAe?$AAT?$AAy?$AAp?$AAe?$AA?$AA@ DB 'F'
	DB	00H, 'i', 00H, 'l', 00H, 'e', 00H, 'T', 00H, 'y', 00H, 'p', 00H
	DB	'e', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1CK@OEKPKBNA@?$AAC?$AAo?$AAm?$AAp?$AAo?$AAn?$AAe?$AAn?$AAt?$AA?5?$AAC?$AAa?$AAt?$AAe?$AAg?$AAo?$AAr?$AAi?$AAe?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@OEKPKBNA@?$AAC?$AAo?$AAm?$AAp?$AAo?$AAn?$AAe?$AAn?$AAt?$AA?5?$AAC?$AAa?$AAt?$AAe?$AAg?$AAo?$AAr?$AAi?$AAe?$AAs?$AA?$AA@ DB 'C'
	DB	00H, 'o', 00H, 'm', 00H, 'p', 00H, 'o', 00H, 'n', 00H, 'e', 00H
	DB	'n', 00H, 't', 00H, ' ', 00H, 'C', 00H, 'a', 00H, 't', 00H, 'e'
	DB	00H, 'g', 00H, 'o', 00H, 'r', 00H, 'i', 00H, 'e', 00H, 's', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@JDLOHAN@?$AAD?$AAe?$AAl?$AAe?$AAt?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1O@JDLOHAN@?$AAD?$AAe?$AAl?$AAe?$AAt?$AAe?$AA?$AA@ DB 'D', 00H, 'e', 00H
	DB	'l', 00H, 'e', 00H, 't', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BC@GCKHIPE@?$AAN?$AAo?$AAR?$AAe?$AAm?$AAo?$AAv?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1BC@GCKHIPE@?$AAN?$AAo?$AAR?$AAe?$AAm?$AAo?$AAv?$AAe?$AA?$AA@ DB 'N'
	DB	00H, 'o', 00H, 'R', 00H, 'e', 00H, 'm', 00H, 'o', 00H, 'v', 00H
	DB	'e', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BI@JFAIJMHL@?$AAF?$AAo?$AAr?$AAc?$AAe?$AAR?$AAe?$AAm?$AAo?$AAv?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1BI@JFAIJMHL@?$AAF?$AAo?$AAr?$AAc?$AAe?$AAR?$AAe?$AAm?$AAo?$AAv?$AAe?$AA?$AA@ DB 'F'
	DB	00H, 'o', 00H, 'r', 00H, 'c', 00H, 'e', 00H, 'R', 00H, 'e', 00H
	DB	'm', 00H, 'o', 00H, 'v', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_17LLMMEOJD@?$AAV?$AAa?$AAl?$AA?$AA@
CONST	SEGMENT
??_C@_17LLMMEOJD@?$AAV?$AAa?$AAl?$AA?$AA@ DB 'V', 00H, 'a', 00H, 'l', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_13OPKGLAFF@?$AAB?$AA?$AA@
CONST	SEGMENT
??_C@_13OPKGLAFF@?$AAB?$AA?$AA@ DB 'B', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_13MKMNOPIJ@?$AAD?$AA?$AA@
CONST	SEGMENT
??_C@_13MKMNOPIJ@?$AAD?$AA?$AA@ DB 'D', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_13LHMFKAAD@?$AAM?$AA?$AA@
CONST	SEGMENT
??_C@_13LHMFKAAD@?$AAM?$AA?$AA@ DB 'M', 00H, 00H, 00H	; `string'
;	COMDAT ??_C@_13HADIAKP@?$AAS?$AA?$AA@
CONST	SEGMENT
??_C@_13HADIAKP@?$AAS?$AA?$AA@ DB 'S', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@EJNEECMJ@?$AAA?$AAp?$AAp?$AAI?$AAD?$AA?$AA@
CONST	SEGMENT
??_C@_1M@EJNEECMJ@?$AAA?$AAp?$AAp?$AAI?$AAD?$AA?$AA@ DB 'A', 00H, 'p', 00H
	DB	'p', 00H, 'I', 00H, 'D', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@KANJNLFF@?$AAC?$AAL?$AAS?$AAI?$AAD?$AA?$AA@
CONST	SEGMENT
??_C@_1M@KANJNLFF@?$AAC?$AAL?$AAS?$AAI?$AAD?$AA?$AA@ DB 'C', 00H, 'L', 00H
	DB	'S', 00H, 'I', 00H, 'D', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT __pobjMapEntryLast
ATL$__z	SEGMENT
__pobjMapEntryLast DQ 0000000000000000H
ATL$__z	ENDS
;	COMDAT __pobjMapEntryFirst
ATL$__a	SEGMENT
__pobjMapEntryFirst DQ 0000000000000000H
ATL$__a	ENDS
;	COMDAT pdata
; File e:\my_project\openpdn\openpdn-e28f1ff0077e\src\shellextension\pdnshellextension.cpp
pdata	SEGMENT
$pdata$?GetLocation@CPdnShellExtension@@UEAAJPEA_WKPEAKPEBUtagSIZE@@K1@Z DD imagerel $LN33
	DD	imagerel $LN33+153
	DD	imagerel $unwind$?GetLocation@CPdnShellExtension@@UEAAJPEA_WKPEAKPEBUtagSIZE@@K1@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetLocation@CPdnShellExtension@@UEAAJPEA_WKPEAKPEBUtagSIZE@@K1@Z DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT ?GetLocation@CPdnShellExtension@@UEAAJPEA_WKPEAKPEBUtagSIZE@@K1@Z
_TEXT	SEGMENT
this$ = 48
pszPathBuffer$ = 56
cchMax$ = 64
pdwPriority$ = 72
prgSize$ = 80
dwRecClrDepth$ = 88
pdwFlags$ = 96
?GetLocation@CPdnShellExtension@@UEAAJPEA_WKPEAKPEBUtagSIZE@@K1@Z PROC ; CPdnShellExtension::GetLocation, COMDAT

; 808  : {

$LN33:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	49 8b e9	 mov	 rbp, r9
  00017	48 8b c2	 mov	 rax, rdx
  0001a	48 8b f9	 mov	 rdi, rcx

; 809  :     HRESULT hr = S_OK;
; 810  :     TraceEnter();
; 811  : 
; 812  :     TraceOut("pszPathBuffer=%S", pszPathBuffer);
; 813  :     TraceOut("cchMax=%u", cchMax);
; 814  : 
; 815  :     if (SUCCEEDED(hr))
; 816  :     {
; 817  :         if (NULL == pszPathBuffer)

  0001d	48 85 d2	 test	 rdx, rdx

; 818  :         {
; 819  :             TraceOut("pszPathBuffer is NULL");
; 820  :             hr = E_INVALIDARG;
; 821  :         }
; 822  :     }
; 823  : 
; 824  :     if (SUCCEEDED(hr))

  00020	74 19		 je	 SHORT $LN32@GetLocatio

; 825  :     {
; 826  :         if (NULL == pdwPriority)

  00022	4d 85 c9	 test	 r9, r9

; 827  :         {
; 828  :             TraceOut("pdwPriority is NULL");
; 829  :             hr = E_INVALIDARG;
; 830  :         }
; 831  :     }
; 832  : 
; 833  :     if (SUCCEEDED(hr))

  00025	74 14		 je	 SHORT $LN32@GetLocatio

; 834  :     {
; 835  :         if (NULL == pdwFlags)

  00027	48 8b 5c 24 60	 mov	 rbx, QWORD PTR pdwFlags$[rsp]
  0002c	48 85 db	 test	 rbx, rbx

; 836  :         {
; 837  :             TraceOut("pdwFlags is NULL");
; 838  :             hr = E_INVALIDARG;
; 839  :         }
; 840  :     }
; 841  : 
; 842  :     if (SUCCEEDED(hr))

  0002f	74 0a		 je	 SHORT $LN32@GetLocatio

; 843  :     {
; 844  :         if (NULL == prgSize)

  00031	48 8b 74 24 50	 mov	 rsi, QWORD PTR prgSize$[rsp]
  00036	48 85 f6	 test	 rsi, rsi
  00039	75 07		 jne	 SHORT $LN31@GetLocatio
$LN32@GetLocatio:

; 845  :         {
; 846  :             TraceOut("prgSize is NULL");
; 847  :             hr = E_INVALIDARG;

  0003b	b8 57 00 07 80	 mov	 eax, -2147024809	; ffffffff80070057H

; 848  :         }
; 849  :     }
; 850  : 
; 851  :     TraceOut("*pdwFlags = %u", *pdwFlags);
; 852  :     TraceOut("prgSize=%d x %d", prgSize->cx, prgSize->cy);
; 853  : 
; 854  :     if (SUCCEEDED(hr))

  00040	eb 42		 jmp	 SHORT $LN3@GetLocatio
$LN31@GetLocatio:

; 855  :     {
; 856  :         wcscpy_s(pszPathBuffer, cchMax, m_bstrFileName);

  00042	41 8b d0	 mov	 edx, r8d
  00045	4c 8b 41 10	 mov	 r8, QWORD PTR [rcx+16]
  00049	48 8b c8	 mov	 rcx, rax
  0004c	e8 00 00 00 00	 call	 wcscpy_s

; 857  : 
; 858  :         *pdwPriority = IEIT_PRIORITY_NORMAL;

  00051	c7 45 00 00 00
	00 10		 mov	 DWORD PTR [rbp], 268435456 ; 10000000H

; 859  : 
; 860  :         if ((*pdwFlags & IEIFLAG_ASPECT) ||
; 861  :             (*pdwFlags & IEIFLAG_ORIGSIZE))

  00058	f6 03 04	 test	 BYTE PTR [rbx], 4
  0005b	75 10		 jne	 SHORT $LN6@GetLocatio
  0005d	f6 03 40	 test	 BYTE PTR [rbx], 64	; 00000040H
  00060	75 0b		 jne	 SHORT $LN6@GetLocatio

; 864  :             TraceOut("m_size = %d x %d", m_size.cx, m_size.cy);
; 865  :         }
; 866  :         else
; 867  :         {
; 868  :             m_size.cx = -1;

  00062	83 c8 ff	 or	 eax, -1
  00065	89 47 18	 mov	 DWORD PTR [rdi+24], eax

; 869  :             m_size.cy = -1;

  00068	89 47 1c	 mov	 DWORD PTR [rdi+28], eax
  0006b	eb 07		 jmp	 SHORT $LN5@GetLocatio
$LN6@GetLocatio:

; 862  :         {
; 863  :             m_size = *prgSize;

  0006d	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  00070	48 89 47 18	 mov	 QWORD PTR [rdi+24], rax
$LN5@GetLocatio:

; 870  :         }
; 871  : 
; 872  :         *pdwFlags |= IEIFLAG_CACHE;

  00074	83 0b 02	 or	 DWORD PTR [rbx], 2
  00077	8b 03		 mov	 eax, DWORD PTR [rbx]

; 873  : 
; 874  :         if (*pdwFlags & IEIFLAG_ASYNC)

  00079	24 01		 and	 al, 1
  0007b	f6 d8		 neg	 al
  0007d	1b c0		 sbb	 eax, eax
  0007f	25 0a 00 00 80	 and	 eax, -2147483638	; ffffffff8000000aH
$LN3@GetLocatio:

; 875  :         {
; 876  :             hr = E_PENDING;
; 877  :         }
; 878  :         else
; 879  :         {
; 880  :             hr = NOERROR;
; 881  :         }
; 882  :     }
; 883  : 
; 884  :     TraceLeaveHr(hr);
; 885  :     return hr;
; 886  : }

  00084	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00089	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  0008e	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00093	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00097	5f		 pop	 rdi
  00098	c3		 ret	 0
?GetLocation@CPdnShellExtension@@UEAAJPEA_WKPEAKPEBUtagSIZE@@K1@Z ENDP ; CPdnShellExtension::GetLocation
_TEXT	ENDS
PUBLIC	__$ArrayPad$
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_cookie:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ComputeThumbnailSize@@YA?AUtagSIZE@@HHH@Z DD imagerel ?ComputeThumbnailSize@@YA?AUtagSIZE@@HHH@Z
	DD	imagerel ?ComputeThumbnailSize@@YA?AUtagSIZE@@HHH@Z+166
	DD	imagerel $unwind$?ComputeThumbnailSize@@YA?AUtagSIZE@@HHH@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ComputeThumbnailSize@@YA?AUtagSIZE@@HHH@Z DD 011319H
	DD	02204H
	DD	imagerel __GSHandlerCheck
	DD	08H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT ?ComputeThumbnailSize@@YA?AUtagSIZE@@HHH@Z
_TEXT	SEGMENT
thumbSize$ = 0
__$ArrayPad$ = 8
originalWidth$ = 32
originalHeight$ = 40
maxEdgeLength$ = 48
?ComputeThumbnailSize@@YA?AUtagSIZE@@HHH@Z PROC		; ComputeThumbnailSize, COMDAT

; 265  : {

  00000	48 83 ec 18	 sub	 rsp, 24
  00004	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0000b	48 33 c4	 xor	 rax, rsp
  0000e	48 89 44 24 08	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 266  :     SIZE thumbSize;
; 267  :     ZeroMemory(&thumbSize, sizeof(thumbSize));

  00013	33 c0		 xor	 eax, eax
  00015	44 8b ca	 mov	 r9d, edx
  00018	89 04 24	 mov	 DWORD PTR thumbSize$[rsp], eax
  0001b	89 44 24 04	 mov	 DWORD PTR thumbSize$[rsp+4], eax

; 268  : 
; 269  :     if (originalWidth <= 0 || originalHeight <= 0)

  0001f	85 c9		 test	 ecx, ecx
  00021	7e 61		 jle	 SHORT $LN6@ComputeThu
  00023	85 d2		 test	 edx, edx
  00025	7e 5d		 jle	 SHORT $LN6@ComputeThu

; 273  :     }
; 274  :     else if (originalWidth > originalHeight)

  00027	3b d1		 cmp	 edx, ecx
  00029	7d 25		 jge	 SHORT $LN14@ComputeThu

; 275  :     {
; 276  :         int longSide = min(originalWidth, maxEdgeLength);

  0002b	41 3b c8	 cmp	 ecx, r8d
  0002e	44 0f 4c c1	 cmovl	 r8d, ecx

; 277  :         thumbSize.cx = longSide;

  00032	44 89 04 24	 mov	 DWORD PTR thumbSize$[rsp], r8d

; 278  :         thumbSize.cy = max(1, (originalHeight * longSide) / originalWidth);

  00036	45 0f af c1	 imul	 r8d, r9d
  0003a	41 8b c0	 mov	 eax, r8d
  0003d	99		 cdq
  0003e	f7 f9		 idiv	 ecx
  00040	b9 01 00 00 00	 mov	 ecx, 1
  00045	3b c1		 cmp	 eax, ecx
  00047	0f 4c c1	 cmovl	 eax, ecx
  0004a	89 44 24 04	 mov	 DWORD PTR thumbSize$[rsp+4], eax
  0004e	eb 40		 jmp	 SHORT $LN1@ComputeThu
$LN14@ComputeThu:

; 279  :     }
; 280  :     else if (originalHeight > originalWidth)

  00050	7e 25		 jle	 SHORT $LN2@ComputeThu

; 281  :     {
; 282  :         int longSide = min(originalHeight, maxEdgeLength);

  00052	41 3b d0	 cmp	 edx, r8d
  00055	44 0f 4c c2	 cmovl	 r8d, edx

; 283  :         thumbSize.cx = max(1, (originalWidth * longSide) / originalHeight);

  00059	41 8b c0	 mov	 eax, r8d
  0005c	0f af c1	 imul	 eax, ecx
  0005f	b9 01 00 00 00	 mov	 ecx, 1
  00064	99		 cdq
  00065	41 f7 f9	 idiv	 r9d
  00068	3b c1		 cmp	 eax, ecx
  0006a	0f 4c c1	 cmovl	 eax, ecx
  0006d	89 04 24	 mov	 DWORD PTR thumbSize$[rsp], eax
$LN15@ComputeThu:

; 284  :         thumbSize.cy = longSide;

  00070	44 89 44 24 04	 mov	 DWORD PTR thumbSize$[rsp+4], r8d

; 285  :     }
; 286  :     else // if (docSize.Width == docSize.Height)

  00075	eb 19		 jmp	 SHORT $LN1@ComputeThu
$LN2@ComputeThu:

; 287  :     {
; 288  :         int longSide = min(originalWidth, maxEdgeLength);

  00077	41 3b c8	 cmp	 ecx, r8d
  0007a	44 0f 4c c1	 cmovl	 r8d, ecx

; 289  :         thumbSize.cx = longSide;

  0007e	44 89 04 24	 mov	 DWORD PTR thumbSize$[rsp], r8d

; 290  :         thumbSize.cy = longSide;

  00082	eb ec		 jmp	 SHORT $LN15@ComputeThu
$LN6@ComputeThu:

; 270  :     {
; 271  :         thumbSize.cx = 1;

  00084	b9 01 00 00 00	 mov	 ecx, 1
  00089	89 0c 24	 mov	 DWORD PTR thumbSize$[rsp], ecx

; 272  :         thumbSize.cy = 1;

  0008c	89 4c 24 04	 mov	 DWORD PTR thumbSize$[rsp+4], ecx
$LN1@ComputeThu:

; 291  :     }
; 292  : 
; 293  :     return thumbSize;

  00090	48 8b 04 24	 mov	 rax, QWORD PTR thumbSize$[rsp]

; 294  : }

  00094	48 8b 4c 24 08	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00099	48 33 cc	 xor	 rcx, rsp
  0009c	e8 00 00 00 00	 call	 __security_check_cookie
  000a1	48 83 c4 18	 add	 rsp, 24
  000a5	c3		 ret	 0
?ComputeThumbnailSize@@YA?AUtagSIZE@@HHH@Z ENDP		; ComputeThumbnailSize
_TEXT	ENDS
PUBLIC	?DoGdiplusStartup@@YAJPEAW4Status@Gdiplus@@PEA_KPEAUGdiplusStartupInput@2@@Z ; DoGdiplusStartup
EXTRN	__C_specific_handler:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$?DoGdiplusStartup@@YAJPEAW4Status@Gdiplus@@PEA_KPEAUGdiplusStartupInput@2@@Z DD imagerel $LN12
	DD	imagerel $LN12+101
	DD	imagerel $unwind$?DoGdiplusStartup@@YAJPEAW4Status@Gdiplus@@PEA_KPEAUGdiplusStartupInput@2@@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?DoGdiplusStartup@@YAJPEAW4Status@Gdiplus@@PEA_KPEAUGdiplusStartupInput@2@@Z DD 040f09H
	DD	09340fH
	DD	0700b520fH
	DD	imagerel __C_specific_handler
	DD	01H
	DD	imagerel $LN12+43
	DD	imagerel $LN12+63
	DD	01H
	DD	imagerel $LN12+63
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT ?DoGdiplusStartup@@YAJPEAW4Status@Gdiplus@@PEA_KPEAUGdiplusStartupInput@2@@Z
_TEXT	SEGMENT
status$ = 32
pStatusResult$ = 64
pToken$ = 72
gdiplusStartupInput$ = 80
?DoGdiplusStartup@@YAJPEAW4Status@Gdiplus@@PEA_KPEAUGdiplusStartupInput@2@@Z PROC ; DoGdiplusStartup, COMDAT

; 189  : {

$LN12:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	4d 8b c8	 mov	 r9, r8
  00012	4c 8b d2	 mov	 r10, rdx
  00015	48 8b f9	 mov	 rdi, rcx

; 190  :     // An exception may be thrown because we delay-load gdiplus.dll and
; 191  :     // this is not installed on Win2K systems. Even if .NET is installed,
; 192  :     // gdiplus.dll is not located in the system directory and thus is not
; 193  :     // locatable by the loader.
; 194  : 	// This was moved into a separate function because of compiler error
; 195  : 	// C2712: "cannot use __try in functions that require object unwinding"
; 196  : 
; 197  : 	Status status = Ok;

  00018	33 c0		 xor	 eax, eax

; 198  : 	HRESULT hr = S_OK;
; 199  : 
; 200  : 	if (NULL == pStatusResult)

  0001a	33 db		 xor	 ebx, ebx
  0001c	b9 57 00 07 80	 mov	 ecx, -2147024809	; ffffffff80070057H
  00021	48 85 ff	 test	 rdi, rdi
  00024	0f 44 d9	 cmove	 ebx, ecx

; 201  : 	{
; 202  : 		hr = E_INVALIDARG;
; 203  : 	}
; 204  : 
; 205  : 	if (SUCCEEDED(hr))

  00027	85 db		 test	 ebx, ebx
  00029	78 27		 js	 SHORT $LN11@DoGdiplusS

; 206  : 	{
; 207  : 		__try
; 208  : 		{
; 209  : 			status = GdiplusStartup(pToken, gdiplusStartupInput, NULL);

  0002b	45 33 c0	 xor	 r8d, r8d
  0002e	49 8b d1	 mov	 rdx, r9
  00031	49 8b ca	 mov	 rcx, r10
  00034	e8 00 00 00 00	 call	 GdiplusStartup
  00039	89 44 24 20	 mov	 DWORD PTR status$[rsp], eax

; 210  : 		}

  0003d	eb 13		 jmp	 SHORT $LN11@DoGdiplusS
$LN9@DoGdiplusS:

; 211  : 
; 212  : 		__except (EXCEPTION_EXECUTE_HANDLER)
; 213  : 		{
; 214  : 			hr = E_FAIL;

  0003f	bb 05 40 00 80	 mov	 ebx, -2147467259	; ffffffff80004005H

; 215  : 			status = Win32Error;

  00044	b8 07 00 00 00	 mov	 eax, 7
  00049	89 44 24 20	 mov	 DWORD PTR status$[rsp], eax
  0004d	48 8b 7c 24 40	 mov	 rdi, QWORD PTR pStatusResult$[rsp]
$LN11@DoGdiplusS:

; 216  : 		}
; 217  : 	}
; 218  : 
; 219  : 	if (SUCCEEDED(hr))

  00052	85 db		 test	 ebx, ebx
  00054	78 02		 js	 SHORT $LN1@DoGdiplusS

; 220  : 	{
; 221  : 		*pStatusResult = status;

  00056	89 07		 mov	 DWORD PTR [rdi], eax
$LN1@DoGdiplusS:

; 222  : 	}
; 223  : 
; 224  : 	return hr;

  00058	8b c3		 mov	 eax, ebx
$LN5@DoGdiplusS:

; 225  : }

  0005a	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  0005f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00063	5f		 pop	 rdi
  00064	c3		 ret	 0
?DoGdiplusStartup@@YAJPEAW4Status@Gdiplus@@PEA_KPEAUGdiplusStartupInput@2@@Z ENDP ; DoGdiplusStartup
; Function compile flags: /Ogspy
_TEXT	ENDS
;	COMDAT ?SaveCompleted@CPdnShellExtension@@UEAAJPEB_W@Z
_TEXT	SEGMENT
this$ = 8
pszFileName$ = 16
?SaveCompleted@CPdnShellExtension@@UEAAJPEB_W@Z PROC	; CPdnShellExtension::SaveCompleted, COMDAT

; 182  :     HRESULT hr = E_NOTIMPL;
; 183  :     TraceEnter();
; 184  :     TraceLeaveHr(hr);
; 185  :     return hr;

  00000	b8 01 40 00 80	 mov	 eax, -2147467263	; ffffffff80004001H

; 186  : }

  00005	c3		 ret	 0
?SaveCompleted@CPdnShellExtension@@UEAAJPEB_W@Z ENDP	; CPdnShellExtension::SaveCompleted
; Function compile flags: /Ogspy
_TEXT	ENDS
;	COMDAT ?Save@CPdnShellExtension@@UEAAJPEB_WH@Z
_TEXT	SEGMENT
this$ = 8
pszFileName$ = 16
fRemember$ = 24
?Save@CPdnShellExtension@@UEAAJPEB_WH@Z PROC		; CPdnShellExtension::Save, COMDAT

; 171  :     HRESULT hr = E_NOTIMPL;
; 172  :     TraceEnter();
; 173  : 
; 174  :     TraceOut("fileName=%S", pszFileName);
; 175  : 
; 176  :     TraceLeaveHr(hr);
; 177  :     return hr;

  00000	b8 01 40 00 80	 mov	 eax, -2147467263	; ffffffff80004001H

; 178  : }

  00005	c3		 ret	 0
?Save@CPdnShellExtension@@UEAAJPEB_WH@Z ENDP		; CPdnShellExtension::Save
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Load@CPdnShellExtension@@UEAAJPEB_WK@Z DD imagerel $LN13
	DD	imagerel $LN13+87
	DD	imagerel $unwind$?Load@CPdnShellExtension@@UEAAJPEB_WK@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Load@CPdnShellExtension@@UEAAJPEB_WK@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT ?Load@CPdnShellExtension@@UEAAJPEB_WK@Z
_TEXT	SEGMENT
this$ = 48
pszFileName$ = 56
dwMode$ = 64
?Load@CPdnShellExtension@@UEAAJPEB_WK@Z PROC		; CPdnShellExtension::Load, COMDAT

; 134  : {

$LN13:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 135  :     HRESULT hr = S_OK;
; 136  :     TraceEnter();
; 137  : 
; 138  :     TraceOut("filename=%S", pszFileName);
; 139  :     TraceOut("mode=%u", dwMode);
; 140  : 
; 141  :     if (SUCCEEDED(hr))
; 142  :     {
; 143  :         if (NULL == pszFileName)

  0000f	33 db		 xor	 ebx, ebx
  00011	48 8b fa	 mov	 rdi, rdx
  00014	48 8b f1	 mov	 rsi, rcx
  00017	48 3b d3	 cmp	 rdx, rbx
  0001a	75 07		 jne	 SHORT $LN12@Load

; 144  :         {
; 145  :             hr = E_INVALIDARG;

  0001c	bb 57 00 07 80	 mov	 ebx, -2147024809	; ffffffff80070057H

; 146  :         }
; 147  :     }
; 148  : 
; 149  :     if (SUCCEEDED(hr))

  00021	eb 22		 jmp	 SHORT $LN3@Load
$LN12@Load:

; 150  :     {
; 151  :         SysFreeString(m_bstrFileName);

  00023	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00027	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SysFreeString

; 152  :         m_bstrFileName = SysAllocString(pszFileName);

  0002d	48 8b cf	 mov	 rcx, rdi
  00030	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SysAllocString

; 153  : 
; 154  :         if (NULL == m_bstrFileName)

  00036	b9 0e 00 07 80	 mov	 ecx, -2147024882	; ffffffff8007000eH
  0003b	48 3b c3	 cmp	 rax, rbx
  0003e	48 89 46 18	 mov	 QWORD PTR [rsi+24], rax
  00042	0f 44 d9	 cmove	 ebx, ecx
$LN3@Load:

; 155  :         {
; 156  :             hr = E_OUTOFMEMORY;
; 157  :         }
; 158  :         else
; 159  :         {
; 160  :             hr = S_OK;
; 161  :         }
; 162  :     }
; 163  : 
; 164  :     TraceLeaveHr(hr);
; 165  :     return hr;
; 166  : }

  00045	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0004a	8b c3		 mov	 eax, ebx
  0004c	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00051	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00055	5f		 pop	 rdi
  00056	c3		 ret	 0
?Load@CPdnShellExtension@@UEAAJPEB_WK@Z ENDP		; CPdnShellExtension::Load
; Function compile flags: /Ogspy
_TEXT	ENDS
;	COMDAT ?IsDirty@CPdnShellExtension@@UEAAJXZ
_TEXT	SEGMENT
this$ = 8
?IsDirty@CPdnShellExtension@@UEAAJXZ PROC		; CPdnShellExtension::IsDirty, COMDAT

; 126  :     HRESULT hr = E_NOTIMPL;
; 127  :     TraceEnter();
; 128  :     TraceLeaveHr(hr);
; 129  :     return hr;

  00000	b8 01 40 00 80	 mov	 eax, -2147467263	; ffffffff80004001H

; 130  : }

  00005	c3		 ret	 0
?IsDirty@CPdnShellExtension@@UEAAJXZ ENDP		; CPdnShellExtension::IsDirty
; Function compile flags: /Ogspy
_TEXT	ENDS
;	COMDAT ?GetCurFile@CPdnShellExtension@@UEAAJPEAPEA_W@Z
_TEXT	SEGMENT
this$ = 8
ppszFileName$ = 16
?GetCurFile@CPdnShellExtension@@UEAAJPEAPEA_W@Z PROC	; CPdnShellExtension::GetCurFile, COMDAT

; 118  :     HRESULT hr = E_NOTIMPL;
; 119  :     TraceEnter();
; 120  :     TraceLeaveHr(hr);
; 121  :     return hr;

  00000	b8 01 40 00 80	 mov	 eax, -2147467263	; ffffffff80004001H

; 122  : }

  00005	c3		 ret	 0
?GetCurFile@CPdnShellExtension@@UEAAJPEAPEA_W@Z ENDP	; CPdnShellExtension::GetCurFile
; Function compile flags: /Ogspy
_TEXT	ENDS
;	COMDAT ?GetClassID@CPdnShellExtension@@UEAAJPEAU_GUID@@@Z
_TEXT	SEGMENT
this$ = 8
pClassID$ = 16
?GetClassID@CPdnShellExtension@@UEAAJPEAU_GUID@@@Z PROC	; CPdnShellExtension::GetClassID, COMDAT

; 110  :     HRESULT hr = E_NOTIMPL;
; 111  :     TraceEnter();
; 112  :     TraceLeaveHr(hr);
; 113  :     return hr;

  00000	b8 01 40 00 80	 mov	 eax, -2147467263	; ffffffff80004001H

; 114  : }

  00005	c3		 ret	 0
?GetClassID@CPdnShellExtension@@UEAAJPEAU_GUID@@@Z ENDP	; CPdnShellExtension::GetClassID
; Function compile flags: /Ogspy
_TEXT	ENDS
;	COMDAT ?AddRef@CPdnShellExtension@@UEAAKXZ
_TEXT	SEGMENT
this$ = 8
?AddRef@CPdnShellExtension@@UEAAKXZ PROC		; CPdnShellExtension::AddRef, COMDAT

; 41   :     TraceEnter();
; 42   :     TraceLeave();
; 43   :     return (DWORD)InterlockedIncrement(&m_lRefCount);

  00000	b8 01 00 00 00	 mov	 eax, 1
  00005	f0 0f c1 41 10	 lock xadd DWORD PTR [rcx+16], eax
  0000a	ff c0		 inc	 eax

; 44   : }

  0000c	c3		 ret	 0
?AddRef@CPdnShellExtension@@UEAAKXZ ENDP		; CPdnShellExtension::AddRef
_TEXT	ENDS
PUBLIC	??1CPdnShellExtension@@QEAA@XZ			; CPdnShellExtension::~CPdnShellExtension
; Function compile flags: /Ogspy
;	COMDAT ??1CPdnShellExtension@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1CPdnShellExtension@@QEAA@XZ PROC			; CPdnShellExtension::~CPdnShellExtension, COMDAT

; 35   : {

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7CPdnShellExtension@@6BIPersistFile@@@
  00007	48 89 01	 mov	 QWORD PTR [rcx], rax
  0000a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7CPdnShellExtension@@6BIExtractImage@@@
  00011	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 36   :     InterlockedDecrement(&g_lRefCount);

  00015	f0 83 05 00 00
	00 00 ff	 lock add DWORD PTR ?g_lRefCount@@3JC, -1 ; g_lRefCount

; 37   : }

  0001d	c3		 ret	 0
??1CPdnShellExtension@@QEAA@XZ ENDP			; CPdnShellExtension::~CPdnShellExtension
; Function compile flags: /Ogspy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\atlmfc\include\atlenc.h
_TEXT	ENDS
;	COMDAT ?DecodeBase64Char@ATL@@YAHI@Z
_TEXT	SEGMENT
ch$ = 8
?DecodeBase64Char@ATL@@YAHI@Z PROC			; ATL::DecodeBase64Char, COMDAT

; 175  : 	// returns -1 if the character is invalid
; 176  : 	// or should be skipped
; 177  : 	// otherwise, returns the 6-bit code for the character
; 178  : 	// from the encoding table
; 179  : 	if (ch >= 'A' && ch <= 'Z')

  00000	8d 41 bf	 lea	 eax, DWORD PTR [rcx-65]
  00003	83 f8 19	 cmp	 eax, 25
  00006	77 04		 ja	 SHORT $LN5@DecodeBase

; 180  : 		return ch - 'A' + 0;	// 0 range starts at 'A'

  00008	8d 41 bf	 lea	 eax, DWORD PTR [rcx-65]

; 188  : 		return 63;
; 189  : 	return -1;
; 190  : }

  0000b	c3		 ret	 0
$LN5@DecodeBase:

; 181  : 	if (ch >= 'a' && ch <= 'z')

  0000c	8d 41 9f	 lea	 eax, DWORD PTR [rcx-97]
  0000f	83 f8 19	 cmp	 eax, 25
  00012	77 04		 ja	 SHORT $LN4@DecodeBase

; 182  : 		return ch - 'a' + 26;	// 26 range starts at 'a'

  00014	8d 41 b9	 lea	 eax, DWORD PTR [rcx-71]

; 188  : 		return 63;
; 189  : 	return -1;
; 190  : }

  00017	c3		 ret	 0
$LN4@DecodeBase:

; 183  : 	if (ch >= '0' && ch <= '9')

  00018	8d 41 d0	 lea	 eax, DWORD PTR [rcx-48]
  0001b	83 f8 09	 cmp	 eax, 9
  0001e	77 04		 ja	 SHORT $LN3@DecodeBase

; 184  : 		return ch - '0' + 52;	// 52 range starts at '0'

  00020	8d 41 04	 lea	 eax, DWORD PTR [rcx+4]

; 188  : 		return 63;
; 189  : 	return -1;
; 190  : }

  00023	c3		 ret	 0
$LN3@DecodeBase:

; 185  : 	if (ch == '+')

  00024	83 f9 2b	 cmp	 ecx, 43			; 0000002bH
  00027	75 04		 jne	 SHORT $LN2@DecodeBase

; 186  : 		return 62;

  00029	8d 41 13	 lea	 eax, QWORD PTR [rcx+19]

; 188  : 		return 63;
; 189  : 	return -1;
; 190  : }

  0002c	c3		 ret	 0
$LN2@DecodeBase:

; 187  : 	if (ch == '/')

  0002d	83 c8 ff	 or	 eax, -1
  00030	83 f9 2f	 cmp	 ecx, 47			; 0000002fH
  00033	8d 50 40	 lea	 edx, QWORD PTR [rax+64]
  00036	0f 44 c2	 cmove	 eax, edx

; 188  : 		return 63;
; 189  : 	return -1;
; 190  : }

  00039	c3		 ret	 0
?DecodeBase64Char@ATL@@YAHI@Z ENDP			; ATL::DecodeBase64Char
; Function compile flags: /Ogspy
_TEXT	ENDS
;	COMDAT ?Base64DecodeGetRequiredLength@ATL@@YAHH@Z
_TEXT	SEGMENT
nSrcLen$ = 8
?Base64DecodeGetRequiredLength@ATL@@YAHH@Z PROC		; ATL::Base64DecodeGetRequiredLength, COMDAT

; 73   : 	return nSrcLen;

  00000	8b c1		 mov	 eax, ecx

; 74   : }

  00002	c3		 ret	 0
?Base64DecodeGetRequiredLength@ATL@@YAHH@Z ENDP		; ATL::Base64DecodeGetRequiredLength
; Function compile flags: /Ogspy
_TEXT	ENDS
;	COMDAT ??0Thank_you@Define_the_symbol__ATL_MIXED@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0Thank_you@Define_the_symbol__ATL_MIXED@@QEAA@XZ PROC	; Define_the_symbol__ATL_MIXED::Thank_you::Thank_you, COMDAT
  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7Thank_you@Define_the_symbol__ATL_MIXED@@6B@
  00007	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?clash@Define_the_symbol__ATL_MIXED@@3UThank_you@1@A, rax ; Define_the_symbol__ATL_MIXED::clash
  0000e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?clash@Define_the_symbol__ATL_MIXED@@3UThank_you@1@A ; Define_the_symbol__ATL_MIXED::clash
  00015	c3		 ret	 0
??0Thank_you@Define_the_symbol__ATL_MIXED@@QEAA@XZ ENDP	; Define_the_symbol__ATL_MIXED::Thank_you::Thank_you
; Function compile flags: /Ogspy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\atlmfc\include\atldef.h
_TEXT	ENDS
;	COMDAT ?one@Thank_you@Define_the_symbol__ATL_MIXED@@UEAAXXZ
_TEXT	SEGMENT
this$ = 8
?one@Thank_you@Define_the_symbol__ATL_MIXED@@UEAAXXZ PROC ; Define_the_symbol__ATL_MIXED::Thank_you::one, COMDAT

; 80   : 	struct Thank_you { virtual void one(){} };

  00000	c2 00 00	 ret	 0
?one@Thank_you@Define_the_symbol__ATL_MIXED@@UEAAXXZ ENDP ; Define_the_symbol__ATL_MIXED::Thank_you::one
; Function compile flags: /Ogspy
; File c:\program files\microsoft sdks\windows\v6.0a\include\gdiplusbitmap.h
_TEXT	ENDS
;	COMDAT ?SetNativeImage@Image@Gdiplus@@IEAAXPEAVGpImage@2@@Z
_TEXT	SEGMENT
this$ = 8
nativeImage$ = 16
?SetNativeImage@Image@Gdiplus@@IEAAXPEAVGpImage@2@@Z PROC ; Gdiplus::Image::SetNativeImage, COMDAT

; 531  :     this->nativeImage = nativeImage;

  00000	48 89 51 08	 mov	 QWORD PTR [rcx+8], rdx

; 532  : }

  00004	c3		 ret	 0
?SetNativeImage@Image@Gdiplus@@IEAAXPEAVGpImage@2@@Z ENDP ; Gdiplus::Image::SetNativeImage
; Function compile flags: /Ogspy
_TEXT	ENDS
;	COMDAT ??0Image@Gdiplus@@IEAA@PEAVGpImage@1@W4Status@1@@Z
_TEXT	SEGMENT
this$ = 8
nativeImage$ = 16
status$ = 24
??0Image@Gdiplus@@IEAA@PEAVGpImage@1@W4Status@1@@Z PROC	; Gdiplus::Image::Image, COMDAT

; 523  : {

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7Image@Gdiplus@@6B@

; 524  :     SetNativeImage(nativeImage);

  00007	48 89 51 08	 mov	 QWORD PTR [rcx+8], rdx

; 525  :     lastResult = status;

  0000b	44 89 41 10	 mov	 DWORD PTR [rcx+16], r8d
  0000f	48 89 01	 mov	 QWORD PTR [rcx], rax

; 526  : }

  00012	48 8b c1	 mov	 rax, rcx
  00015	c3		 ret	 0
??0Image@Gdiplus@@IEAA@PEAVGpImage@1@W4Status@1@@Z ENDP	; Gdiplus::Image::Image
; Function compile flags: /Ogspy
_TEXT	ENDS
;	COMDAT ??1Image@Gdiplus@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1Image@Gdiplus@@UEAA@XZ PROC				; Gdiplus::Image::~Image, COMDAT

; 90   : {

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7Image@Gdiplus@@6B@
  00007	48 89 01	 mov	 QWORD PTR [rcx], rax

; 91   :     DllExports::GdipDisposeImage(nativeImage);

  0000a	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]

; 92   : }

  0000e	e9 00 00 00 00	 jmp	 GdipDisposeImage
??1Image@Gdiplus@@UEAA@XZ ENDP				; Gdiplus::Image::~Image
; Function compile flags: /Ogspy
; File c:\program files\microsoft sdks\windows\v6.0a\include\gdiplusgraphics.h
_TEXT	ENDS
;	COMDAT ?SetStatus@Graphics@Gdiplus@@IEBA?AW4Status@2@W432@@Z
_TEXT	SEGMENT
this$ = 8
status$ = 16
?SetStatus@Graphics@Gdiplus@@IEBA?AW4Status@2@W432@@Z PROC ; Gdiplus::Graphics::SetStatus, COMDAT

; 2395 :         if (status != Ok)

  00000	85 d2		 test	 edx, edx
  00002	74 06		 je	 SHORT $LN2@SetStatus

; 2396 :             return (lastResult = status);

  00004	89 51 08	 mov	 DWORD PTR [rcx+8], edx
  00007	8b c2		 mov	 eax, edx

; 2399 :     }

  00009	c3		 ret	 0
$LN2@SetStatus:

; 2397 :         else
; 2398 :             return status;

  0000a	33 c0		 xor	 eax, eax

; 2399 :     }

  0000c	c3		 ret	 0
?SetStatus@Graphics@Gdiplus@@IEBA?AW4Status@2@W432@@Z ENDP ; Gdiplus::Graphics::SetStatus
; Function compile flags: /Ogspy
_TEXT	ENDS
;	COMDAT ?SetNativeGraphics@Graphics@Gdiplus@@IEAAXPEAVGpGraphics@2@@Z
_TEXT	SEGMENT
this$ = 8
graphics$ = 16
?SetNativeGraphics@Graphics@Gdiplus@@IEAAXPEAVGpGraphics@2@@Z PROC ; Gdiplus::Graphics::SetNativeGraphics, COMDAT

; 2390 :         this->nativeGraphics = graphics;

  00000	48 89 11	 mov	 QWORD PTR [rcx], rdx

; 2391 :     }

  00003	c3		 ret	 0
?SetNativeGraphics@Graphics@Gdiplus@@IEAAXPEAVGpGraphics@2@@Z ENDP ; Gdiplus::Graphics::SetNativeGraphics
_TEXT	ENDS
EXTRN	_fltused:DWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$?DrawImage@Graphics@Gdiplus@@QEAA?AW4Status@2@PEAVImage@2@AEBVRectF@2@MMMMW4Unit@2@PEBVImageAttributes@2@P6AHPEAX@Z4@Z DD imagerel $LN11
	DD	imagerel $LN11+159
	DD	imagerel $unwind$?DrawImage@Graphics@Gdiplus@@QEAA?AW4Status@2@PEAVImage@2@AEBVRectF@2@MMMMW4Unit@2@PEBVImageAttributes@2@P6AHPEAX@Z4@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?DrawImage@Graphics@Gdiplus@@QEAA?AW4Status@2@PEAVImage@2@AEBVRectF@2@MMMMW4Unit@2@PEBVImageAttributes@2@P6AHPEAX@Z4@Z DD 020601H
	DD	03002d206H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT ?DrawImage@Graphics@Gdiplus@@QEAA?AW4Status@2@PEAVImage@2@AEBVRectF@2@MMMMW4Unit@2@PEBVImageAttributes@2@P6AHPEAX@Z4@Z
_TEXT	SEGMENT
this$ = 128
image$ = 136
destRect$ = 144
srcx$ = 152
srcy$ = 160
srcwidth$ = 168
srcheight$ = 176
srcUnit$ = 184
imageAttributes$ = 192
callback$ = 200
callbackData$ = 208
?DrawImage@Graphics@Gdiplus@@QEAA?AW4Status@2@PEAVImage@2@AEBVRectF@2@MMMMW4Unit@2@PEBVImageAttributes@2@P6AHPEAX@Z4@Z PROC ; Gdiplus::Graphics::DrawImage, COMDAT

; 1633 :     {

$LN11:
  00000	40 53		 push	 rbx
  00002	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00006	48 8b d9	 mov	 rbx, rcx

; 1634 :         return SetStatus(DllExports::GdipDrawImageRectRect(nativeGraphics,
; 1635 :                                                            image ? image->nativeImage
; 1636 :                                                                  : NULL,
; 1637 :                                                            destRect.X,
; 1638 :                                                            destRect.Y,
; 1639 :                                                            destRect.Width,
; 1640 :                                                            destRect.Height,
; 1641 :                                                            srcx, srcy,
; 1642 :                                                            srcwidth, srcheight,
; 1643 :                                                            srcUnit,
; 1644 :                                                            imageAttributes
; 1645 :                                                             ? imageAttributes->nativeImageAttr
; 1646 :                                                             : NULL,
; 1647 :                                                            callback,
; 1648 :                                                            callbackData));

  00009	48 85 d2	 test	 rdx, rdx
  0000c	74 06		 je	 SHORT $LN5@DrawImage
  0000e	48 8b 52 08	 mov	 rdx, QWORD PTR [rdx+8]
  00012	eb 02		 jmp	 SHORT $LN6@DrawImage
$LN5@DrawImage:
  00014	33 d2		 xor	 edx, edx
$LN6@DrawImage:
  00016	48 83 64 24 68
	00		 and	 QWORD PTR [rsp+104], 0
  0001c	48 83 64 24 60
	00		 and	 QWORD PTR [rsp+96], 0
  00022	48 83 64 24 58
	00		 and	 QWORD PTR [rsp+88], 0
  00028	f3 0f 10 84 24
	b0 00 00 00	 movss	 xmm0, DWORD PTR srcheight$[rsp]
  00031	f3 0f 10 8c 24
	a8 00 00 00	 movss	 xmm1, DWORD PTR srcwidth$[rsp]
  0003a	f3 41 0f 10 10	 movss	 xmm2, DWORD PTR [r8]
  0003f	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00042	c7 44 24 50 02
	00 00 00	 mov	 DWORD PTR [rsp+80], 2
  0004a	f3 0f 11 44 24
	48		 movss	 DWORD PTR [rsp+72], xmm0
  00050	f3 0f 10 84 24
	a0 00 00 00	 movss	 xmm0, DWORD PTR srcy$[rsp]
  00059	f3 0f 11 4c 24
	40		 movss	 DWORD PTR [rsp+64], xmm1
  0005f	f3 41 0f 10 48
	0c		 movss	 xmm1, DWORD PTR [r8+12]
  00065	f3 0f 11 44 24
	38		 movss	 DWORD PTR [rsp+56], xmm0
  0006b	f3 41 0f 10 40
	08		 movss	 xmm0, DWORD PTR [r8+8]
  00071	f3 0f 11 5c 24
	30		 movss	 DWORD PTR [rsp+48], xmm3
  00077	f3 41 0f 10 58
	04		 movss	 xmm3, DWORD PTR [r8+4]
  0007d	f3 0f 11 4c 24
	28		 movss	 DWORD PTR [rsp+40], xmm1
  00083	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  00089	e8 00 00 00 00	 call	 GdipDrawImageRectRect
  0008e	85 c0		 test	 eax, eax
  00090	74 05		 je	 SHORT $LN8@DrawImage
  00092	89 43 08	 mov	 DWORD PTR [rbx+8], eax
  00095	eb 02		 jmp	 SHORT $LN7@DrawImage
$LN8@DrawImage:
  00097	33 c0		 xor	 eax, eax
$LN7@DrawImage:

; 1649 :     }

  00099	48 83 c4 70	 add	 rsp, 112		; 00000070H
  0009d	5b		 pop	 rbx
  0009e	c3		 ret	 0
?DrawImage@Graphics@Gdiplus@@QEAA?AW4Status@2@PEAVImage@2@AEBVRectF@2@MMMMW4Unit@2@PEBVImageAttributes@2@P6AHPEAX@Z4@Z ENDP ; Gdiplus::Graphics::DrawImage
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?SetPixelOffsetMode@Graphics@Gdiplus@@QEAA?AW4Status@2@W4PixelOffsetMode@2@@Z DD imagerel $LN7
	DD	imagerel $LN7+39
	DD	imagerel $unwind$?SetPixelOffsetMode@Graphics@Gdiplus@@QEAA?AW4Status@2@W4PixelOffsetMode@2@@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?SetPixelOffsetMode@Graphics@Gdiplus@@QEAA?AW4Status@2@W4PixelOffsetMode@2@@Z DD 020601H
	DD	030023206H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT ?SetPixelOffsetMode@Graphics@Gdiplus@@QEAA?AW4Status@2@W4PixelOffsetMode@2@@Z
_TEXT	SEGMENT
this$ = 48
pixelOffsetMode$ = 56
?SetPixelOffsetMode@Graphics@Gdiplus@@QEAA?AW4Status@2@W4PixelOffsetMode@2@@Z PROC ; Gdiplus::Graphics::SetPixelOffsetMode, COMDAT

; 272  :     {

$LN7:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 273  :         return SetStatus(DllExports::GdipSetPixelOffsetMode(nativeGraphics,
; 274  :                                                             pixelOffsetMode));

  00009	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0000c	ba 04 00 00 00	 mov	 edx, 4
  00011	e8 00 00 00 00	 call	 GdipSetPixelOffsetMode
  00016	85 c0		 test	 eax, eax
  00018	74 05		 je	 SHORT $LN4@SetPixelOf
  0001a	89 43 08	 mov	 DWORD PTR [rbx+8], eax
  0001d	eb 02		 jmp	 SHORT $LN3@SetPixelOf
$LN4@SetPixelOf:
  0001f	33 c0		 xor	 eax, eax
$LN3@SetPixelOf:

; 275  :     }

  00021	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00025	5b		 pop	 rbx
  00026	c3		 ret	 0
?SetPixelOffsetMode@Graphics@Gdiplus@@QEAA?AW4Status@2@W4PixelOffsetMode@2@@Z ENDP ; Gdiplus::Graphics::SetPixelOffsetMode
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?SetInterpolationMode@Graphics@Gdiplus@@QEAA?AW4Status@2@W4InterpolationMode@2@@Z DD imagerel $LN7
	DD	imagerel $LN7+39
	DD	imagerel $unwind$?SetInterpolationMode@Graphics@Gdiplus@@QEAA?AW4Status@2@W4InterpolationMode@2@@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?SetInterpolationMode@Graphics@Gdiplus@@QEAA?AW4Status@2@W4InterpolationMode@2@@Z DD 020601H
	DD	030023206H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT ?SetInterpolationMode@Graphics@Gdiplus@@QEAA?AW4Status@2@W4InterpolationMode@2@@Z
_TEXT	SEGMENT
this$ = 48
interpolationMode$ = 56
?SetInterpolationMode@Graphics@Gdiplus@@QEAA?AW4Status@2@W4InterpolationMode@2@@Z PROC ; Gdiplus::Graphics::SetInterpolationMode, COMDAT

; 230  :     {

$LN7:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 231  :         return SetStatus(DllExports::GdipSetInterpolationMode(nativeGraphics,
; 232  :                                                            interpolationMode));

  00009	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0000c	ba 04 00 00 00	 mov	 edx, 4
  00011	e8 00 00 00 00	 call	 GdipSetInterpolationMode
  00016	85 c0		 test	 eax, eax
  00018	74 05		 je	 SHORT $LN4@SetInterpo
  0001a	89 43 08	 mov	 DWORD PTR [rbx+8], eax
  0001d	eb 02		 jmp	 SHORT $LN3@SetInterpo
$LN4@SetInterpo:
  0001f	33 c0		 xor	 eax, eax
$LN3@SetInterpo:

; 233  :     }

  00021	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00025	5b		 pop	 rbx
  00026	c3		 ret	 0
?SetInterpolationMode@Graphics@Gdiplus@@QEAA?AW4Status@2@W4InterpolationMode@2@@Z ENDP ; Gdiplus::Graphics::SetInterpolationMode
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?SetCompositingMode@Graphics@Gdiplus@@QEAA?AW4Status@2@W4CompositingMode@2@@Z DD imagerel $LN7
	DD	imagerel $LN7+34
	DD	imagerel $unwind$?SetCompositingMode@Graphics@Gdiplus@@QEAA?AW4Status@2@W4CompositingMode@2@@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?SetCompositingMode@Graphics@Gdiplus@@QEAA?AW4Status@2@W4CompositingMode@2@@Z DD 020601H
	DD	030023206H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT ?SetCompositingMode@Graphics@Gdiplus@@QEAA?AW4Status@2@W4CompositingMode@2@@Z
_TEXT	SEGMENT
this$ = 48
compositingMode$ = 56
?SetCompositingMode@Graphics@Gdiplus@@QEAA?AW4Status@2@W4CompositingMode@2@@Z PROC ; Gdiplus::Graphics::SetCompositingMode, COMDAT

; 154  :     {

$LN7:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 155  :         return SetStatus(DllExports::GdipSetCompositingMode(nativeGraphics,
; 156  :                                                             compositingMode));

  00009	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0000c	e8 00 00 00 00	 call	 GdipSetCompositingMode
  00011	85 c0		 test	 eax, eax
  00013	74 05		 je	 SHORT $LN4@SetComposi
  00015	89 43 08	 mov	 DWORD PTR [rbx+8], eax
  00018	eb 02		 jmp	 SHORT $LN3@SetComposi
$LN4@SetComposi:
  0001a	33 c0		 xor	 eax, eax
$LN3@SetComposi:

; 157  :     }

  0001c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00020	5b		 pop	 rbx
  00021	c3		 ret	 0
?SetCompositingMode@Graphics@Gdiplus@@QEAA?AW4Status@2@W4CompositingMode@2@@Z ENDP ; Gdiplus::Graphics::SetCompositingMode
; Function compile flags: /Ogspy
_TEXT	ENDS
;	COMDAT ??1Graphics@Gdiplus@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1Graphics@Gdiplus@@QEAA@XZ PROC			; Gdiplus::Graphics::~Graphics, COMDAT

; 103  :         DllExports::GdipDeleteGraphics(nativeGraphics);

  00000	48 8b 09	 mov	 rcx, QWORD PTR [rcx]

; 104  :     }

  00003	e9 00 00 00 00	 jmp	 GdipDeleteGraphics
??1Graphics@Gdiplus@@QEAA@XZ ENDP			; Gdiplus::Graphics::~Graphics
_TEXT	ENDS
PUBLIC	__$ArrayPad$
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0Graphics@Gdiplus@@QEAA@PEAVImage@1@@Z DD imagerel $LN6
	DD	imagerel $LN6+86
	DD	imagerel $unwind$??0Graphics@Gdiplus@@QEAA@PEAVImage@1@@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0Graphics@Gdiplus@@QEAA@PEAVImage@1@@Z DD 021519H
	DD	030025206H
	DD	imagerel __GSHandlerCheck
	DD	028H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT ??0Graphics@Gdiplus@@QEAA@PEAVImage@1@@Z
_TEXT	SEGMENT
graphics$ = 32
__$ArrayPad$ = 40
this$ = 64
image$ = 72
??0Graphics@Gdiplus@@QEAA@PEAVImage@1@@Z PROC		; Gdiplus::Graphics::Graphics, COMDAT

; 89   :     Graphics(IN Image* image)

$LN6:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0000d	48 33 c4	 xor	 rax, rsp
  00010	48 89 44 24 28	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 90   :     {
; 91   :         GpGraphics *graphics = NULL;

  00015	33 c0		 xor	 eax, eax
  00017	4c 8b c2	 mov	 r8, rdx
  0001a	48 8b d9	 mov	 rbx, rcx
  0001d	48 89 44 24 20	 mov	 QWORD PTR graphics$[rsp], rax

; 92   : 
; 93   :         if (image != NULL)

  00022	48 3b d0	 cmp	 rdx, rax
  00025	74 16		 je	 SHORT $LN1@Graphics

; 94   :         {
; 95   :             lastResult = DllExports::GdipGetImageGraphicsContext(
; 96   :                                                                 image->nativeImage, &graphics);

  00027	49 8b 48 08	 mov	 rcx, QWORD PTR [r8+8]
  0002b	48 8d 54 24 20	 lea	 rdx, QWORD PTR graphics$[rsp]
  00030	e8 00 00 00 00	 call	 GdipGetImageGraphicsContext
  00035	89 43 08	 mov	 DWORD PTR [rbx+8], eax
  00038	48 8b 44 24 20	 mov	 rax, QWORD PTR graphics$[rsp]
$LN1@Graphics:

; 97   :         }
; 98   :         SetNativeGraphics(graphics);

  0003d	48 89 03	 mov	 QWORD PTR [rbx], rax

; 99   :     }

  00040	48 8b c3	 mov	 rax, rbx
  00043	48 8b 4c 24 28	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00048	48 33 cc	 xor	 rcx, rsp
  0004b	e8 00 00 00 00	 call	 __security_check_cookie
  00050	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00054	5b		 pop	 rbx
  00055	c3		 ret	 0
??0Graphics@Gdiplus@@QEAA@PEAVImage@1@@Z ENDP		; Gdiplus::Graphics::Graphics
; Function compile flags: /Ogspy
; File c:\program files\microsoft sdks\windows\v6.0a\include\gdiplusheaders.h
_TEXT	ENDS
;	COMDAT ?SetStatus@Image@Gdiplus@@IEBA?AW4Status@2@W432@@Z
_TEXT	SEGMENT
this$ = 8
status$ = 16
?SetStatus@Image@Gdiplus@@IEBA?AW4Status@2@W432@@Z PROC	; Gdiplus::Image::SetStatus, COMDAT

; 479  :         if (status != Ok)

  00000	85 d2		 test	 edx, edx
  00002	74 06		 je	 SHORT $LN2@SetStatus@2

; 480  :             return (lastResult = status);

  00004	89 51 10	 mov	 DWORD PTR [rcx+16], edx
  00007	8b c2		 mov	 eax, edx

; 483  :     }

  00009	c3		 ret	 0
$LN2@SetStatus@2:

; 481  :         else
; 482  :             return status;

  0000a	33 c0		 xor	 eax, eax

; 483  :     }

  0000c	c3		 ret	 0
?SetStatus@Image@Gdiplus@@IEBA?AW4Status@2@W432@@Z ENDP	; Gdiplus::Image::SetStatus
; Function compile flags: /Ogspy
_TEXT	ENDS
;	COMDAT ??0Image@Gdiplus@@IEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0Image@Gdiplus@@IEAA@XZ PROC				; Gdiplus::Image::Image, COMDAT

; 471  :     Image() {}

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7Image@Gdiplus@@6B@
  00007	48 89 01	 mov	 QWORD PTR [rcx], rax
  0000a	48 8b c1	 mov	 rax, rcx
  0000d	c3		 ret	 0
??0Image@Gdiplus@@IEAA@XZ ENDP				; Gdiplus::Image::Image
; Function compile flags: /Ogspy
; File c:\program files\microsoft sdks\windows\v6.0a\include\gdipluscolor.h
_TEXT	ENDS
;	COMDAT ?GetValue@Color@Gdiplus@@QEBAKXZ
_TEXT	SEGMENT
this$ = 8
?GetValue@Color@Gdiplus@@QEBAKXZ PROC			; Gdiplus::Color::GetValue, COMDAT

; 121  :         return Argb;

  00000	8b 01		 mov	 eax, DWORD PTR [rcx]

; 122  :     }

  00002	c3		 ret	 0
?GetValue@Color@Gdiplus@@QEBAKXZ ENDP			; Gdiplus::Color::GetValue
; Function compile flags: /Ogspy
_TEXT	ENDS
;	COMDAT ??0Color@Gdiplus@@QEAA@K@Z
_TEXT	SEGMENT
this$ = 8
argb$ = 16
??0Color@Gdiplus@@QEAA@K@Z PROC				; Gdiplus::Color::Color, COMDAT

; 75   :     {
; 76   :         Argb = argb;

  00000	89 11		 mov	 DWORD PTR [rcx], edx

; 77   :     }

  00002	48 8b c1	 mov	 rax, rcx
  00005	c3		 ret	 0
??0Color@Gdiplus@@QEAA@K@Z ENDP				; Gdiplus::Color::Color
; Function compile flags: /Ogspy
; File c:\program files\microsoft sdks\windows\v6.0a\include\gdiplusinit.h
_TEXT	ENDS
;	COMDAT ??0GdiplusStartupInput@Gdiplus@@QEAA@P6AXW4DebugEventLevel@1@PEAD@ZHH@Z
_TEXT	SEGMENT
this$ = 8
debugEventCallback$ = 16
suppressBackgroundThread$ = 24
suppressExternalCodecs$ = 32
??0GdiplusStartupInput@Gdiplus@@QEAA@P6AXW4DebugEventLevel@1@PEAD@ZHH@Z PROC ; Gdiplus::GdiplusStartupInput::GdiplusStartupInput, COMDAT

; 47   :         DebugEventProc debugEventCallback = NULL,
; 48   :         BOOL suppressBackgroundThread = FALSE,
; 49   :         BOOL suppressExternalCodecs = FALSE)
; 50   :     {
; 51   :         GdiplusVersion = 1;
; 52   :         DebugEventCallback = debugEventCallback;

  00000	33 c0		 xor	 eax, eax
  00002	c7 01 01 00 00
	00		 mov	 DWORD PTR [rcx], 1
  00008	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 53   :         SuppressBackgroundThread = suppressBackgroundThread;

  0000c	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 54   :         SuppressExternalCodecs = suppressExternalCodecs;

  0000f	89 41 14	 mov	 DWORD PTR [rcx+20], eax

; 55   :     }

  00012	48 8b c1	 mov	 rax, rcx
  00015	c3		 ret	 0
??0GdiplusStartupInput@Gdiplus@@QEAA@P6AXW4DebugEventLevel@1@PEAD@ZHH@Z ENDP ; Gdiplus::GdiplusStartupInput::GdiplusStartupInput
; Function compile flags: /Ogspy
; File c:\program files\microsoft sdks\windows\v6.0a\include\gdiplustypes.h
_TEXT	ENDS
;	COMDAT ??0Rect@Gdiplus@@QEAA@HHHH@Z
_TEXT	SEGMENT
this$ = 8
x$ = 16
y$ = 24
width$ = 32
height$ = 40
??0Rect@Gdiplus@@QEAA@HHHH@Z PROC			; Gdiplus::Rect::Rect, COMDAT

; 540  :          IN INT y,
; 541  :          IN INT width,
; 542  :          IN INT height)
; 543  :     {
; 544  :         X = x;
; 545  :         Y = y;
; 546  :         Width = width;
; 547  :         Height = height;

  00000	8b 44 24 28	 mov	 eax, DWORD PTR height$[rsp]
  00004	83 21 00	 and	 DWORD PTR [rcx], 0
  00007	83 61 04 00	 and	 DWORD PTR [rcx+4], 0
  0000b	89 41 0c	 mov	 DWORD PTR [rcx+12], eax
  0000e	44 89 49 08	 mov	 DWORD PTR [rcx+8], r9d

; 548  :     }

  00012	48 8b c1	 mov	 rax, rcx
  00015	c3		 ret	 0
??0Rect@Gdiplus@@QEAA@HHHH@Z ENDP			; Gdiplus::Rect::Rect
; Function compile flags: /Ogspy
_TEXT	ENDS
;	COMDAT ??0RectF@Gdiplus@@QEAA@MMMM@Z
_TEXT	SEGMENT
this$ = 8
x$ = 16
y$ = 24
width$ = 32
height$ = 40
??0RectF@Gdiplus@@QEAA@MMMM@Z PROC			; Gdiplus::RectF::RectF, COMDAT

; 352  :           IN REAL y,
; 353  :           IN REAL width,
; 354  :           IN REAL height)
; 355  :     {
; 356  :         X = x;
; 357  :         Y = y;
; 358  :         Width = width;
; 359  :         Height = height;

  00000	f3 0f 10 44 24
	28		 movss	 xmm0, DWORD PTR height$[rsp]
  00006	f3 0f 11 09	 movss	 DWORD PTR [rcx], xmm1
  0000a	f3 0f 11 51 04	 movss	 DWORD PTR [rcx+4], xmm2

; 360  :     }

  0000f	48 8b c1	 mov	 rax, rcx
  00012	f3 0f 11 41 0c	 movss	 DWORD PTR [rcx+12], xmm0
  00017	f3 0f 11 59 08	 movss	 DWORD PTR [rcx+8], xmm3
  0001c	c3		 ret	 0
??0RectF@Gdiplus@@QEAA@MMMM@Z ENDP			; Gdiplus::RectF::RectF
; Function compile flags: /Ogspy
; File c:\program files\microsoft sdks\windows\v6.0a\include\gdiplusbase.h
_TEXT	ENDS
;	COMDAT ??2GdiplusBase@Gdiplus@@SAPEAX_K@Z
_TEXT	SEGMENT
in_size$ = 8
??2GdiplusBase@Gdiplus@@SAPEAX_K@Z PROC			; Gdiplus::GdiplusBase::operator new, COMDAT

; 27   :        return DllExports::GdipAlloc(in_size);
; 28   :     }

  00000	e9 00 00 00 00	 jmp	 GdipAlloc
??2GdiplusBase@Gdiplus@@SAPEAX_K@Z ENDP			; Gdiplus::GdiplusBase::operator new
; Function compile flags: /Ogspy
_TEXT	ENDS
;	COMDAT ??3GdiplusBase@Gdiplus@@SAXPEAX@Z
_TEXT	SEGMENT
in_pVoid$ = 8
??3GdiplusBase@Gdiplus@@SAXPEAX@Z PROC			; Gdiplus::GdiplusBase::operator delete, COMDAT

; 23   :        DllExports::GdipFree(in_pVoid);
; 24   :     }

  00000	e9 00 00 00 00	 jmp	 GdipFree
??3GdiplusBase@Gdiplus@@SAXPEAX@Z ENDP			; Gdiplus::GdiplusBase::operator delete
; Function compile flags: /Ogspy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\string.h
_TEXT	ENDS
;	COMDAT ?strstr@@YAPEADPEADPEBD@Z
_TEXT	SEGMENT
_Str$ = 8
_SubStr$ = 16
?strstr@@YAPEADPEADPEBD@Z PROC				; strstr, COMDAT

; 190  : 	{ return (char*)strstr((const char*)_Str, _SubStr); }

  00000	e9 00 00 00 00	 jmp	 strstr
?strstr@@YAPEADPEADPEBD@Z ENDP				; strstr
; Function compile flags: /Ogspy
; File c:\program files\microsoft sdks\windows\v6.0a\include\winerror.h
_TEXT	ENDS
;	COMDAT ?HRESULT_FROM_WIN32@@YAJK@Z
_TEXT	SEGMENT
x$ = 8
?HRESULT_FROM_WIN32@@YAJK@Z PROC			; HRESULT_FROM_WIN32, COMDAT

; 22905: FORCEINLINE HRESULT HRESULT_FROM_WIN32(unsigned long x) { return (HRESULT)(x) <= 0 ? (HRESULT)(x) : (HRESULT) (((x) & 0x0000FFFF) | (FACILITY_WIN32 << 16) | 0x80000000);}

  00000	0f b7 c1	 movzx	 eax, cx
  00003	0d 00 00 07 80	 or	 eax, -2147024896	; ffffffff80070000H
  00008	85 c9		 test	 ecx, ecx
  0000a	0f 4e c1	 cmovle	 eax, ecx
  0000d	c3		 ret	 0
?HRESULT_FROM_WIN32@@YAJK@Z ENDP			; HRESULT_FROM_WIN32
; Function compile flags: /Odspy
;	COMDAT ?AddRef@CPdnShellExtension@@W7EAAKXZ
_TEXT	SEGMENT
?AddRef@CPdnShellExtension@@W7EAAKXZ PROC		; [thunk]:CPdnShellExtension::AddRef`adjustor{8}', COMDAT
  00000	48 83 e9 08	 sub	 rcx, 8
  00004	e9 00 00 00 00	 jmp	 ?AddRef@CPdnShellExtension@@UEAAKXZ ; CPdnShellExtension::AddRef
?AddRef@CPdnShellExtension@@W7EAAKXZ ENDP		; [thunk]:CPdnShellExtension::AddRef`adjustor{8}'
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GGraphics@Gdiplus@@QEAAPEAXI@Z DD imagerel $LN8
	DD	imagerel $LN8+34
	DD	imagerel $unwind$??_GGraphics@Gdiplus@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GGraphics@Gdiplus@@QEAAPEAXI@Z DD 020601H
	DD	030023206H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT ??_GGraphics@Gdiplus@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_GGraphics@Gdiplus@@QEAAPEAXI@Z PROC			; Gdiplus::Graphics::`scalar deleting destructor', COMDAT
$LN8:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx
  00009	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0000c	e8 00 00 00 00	 call	 GdipDeleteGraphics
  00011	48 8b cb	 mov	 rcx, rbx
  00014	e8 00 00 00 00	 call	 GdipFree
  00019	48 8b c3	 mov	 rax, rbx
  0001c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00020	5b		 pop	 rbx
  00021	c3		 ret	 0
??_GGraphics@Gdiplus@@QEAAPEAXI@Z ENDP			; Gdiplus::Graphics::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	__$ArrayPad$
;	COMDAT pdata
pdata	SEGMENT
$pdata$?VerifyWindowsVersion@@YAJKKPEAH@Z DD imagerel ?VerifyWindowsVersion@@YAJKKPEAH@Z
	DD	imagerel ?VerifyWindowsVersion@@YAJKKPEAH@Z+204
	DD	imagerel $unwind$?VerifyWindowsVersion@@YAJKKPEAH@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?VerifyWindowsVersion@@YAJKKPEAH@Z DD 051f19H
	DD	02d340dH
	DD	02a010dH
	DD	07006H
	DD	imagerel __GSHandlerCheck
	DD	0140H
; Function compile flags: /Ogspy
; File e:\my_project\openpdn\openpdn-e28f1ff0077e\src\shellextension\pdnshellextension.cpp
xdata	ENDS
;	COMDAT ?VerifyWindowsVersion@@YAJKKPEAH@Z
_TEXT	SEGMENT
osviex$ = 32
__$ArrayPad$ = 320
pbResult$ = 352
?VerifyWindowsVersion@@YAJKKPEAH@Z PROC			; VerifyWindowsVersion, COMDAT

; 297  : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 81 ec 50 01
	00 00		 sub	 rsp, 336		; 00000150H
  0000d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00014	48 33 c4	 xor	 rax, rsp
  00017	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  0001f	48 8b f9	 mov	 rdi, rcx

; 298  : 	if (NULL == pbResult)
; 299  : 	{
; 300  : 		return E_INVALIDARG;
; 301  : 	}
; 302  : 
; 303  : 	HRESULT hr = S_OK;
; 304  : 	BOOL bResult = TRUE;
; 305  : 	DWORD dwError = ERROR_SUCCESS;
; 306  : 
; 307  : 	OSVERSIONINFOEX osviex;
; 308  : 	ZeroMemory(&osviex, sizeof(osviex));

  00022	48 8d 4c 24 20	 lea	 rcx, QWORD PTR osviex$[rsp]
  00027	33 d2		 xor	 edx, edx
  00029	41 b8 1c 01 00
	00		 mov	 r8d, 284		; 0000011cH
  0002f	33 db		 xor	 ebx, ebx
  00031	e8 00 00 00 00	 call	 memset

; 309  : 
; 310  : 	osviex.dwOSVersionInfoSize = sizeof(osviex);
; 311  : 	osviex.dwMajorVersion = dwMajor;
; 312  : 	osviex.dwMinorVersion = dwMinor;
; 313  : 
; 314  : 	DWORDLONG dwlConditionMask = 0;
; 315  : 
; 316  : 	int vop = VER_GREATER_EQUAL;
; 317  : 
; 318  : 	VER_SET_CONDITION(dwlConditionMask, VER_MAJORVERSION, vop);

  00036	8d 53 02	 lea	 edx, QWORD PTR [rbx+2]
  00039	41 b0 03	 mov	 r8b, 3
  0003c	33 c9		 xor	 ecx, ecx
  0003e	c7 44 24 20 1c
	01 00 00	 mov	 DWORD PTR osviex$[rsp], 284 ; 0000011cH
  00046	c7 44 24 24 06
	00 00 00	 mov	 DWORD PTR osviex$[rsp+4], 6
  0004e	89 5c 24 28	 mov	 DWORD PTR osviex$[rsp+8], ebx
  00052	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_VerSetConditionMask

; 319  : 	VER_SET_CONDITION(dwlConditionMask, VER_MINORVERSION, vop);

  00058	8d 53 01	 lea	 edx, QWORD PTR [rbx+1]
  0005b	48 8b c8	 mov	 rcx, rax
  0005e	41 b0 03	 mov	 r8b, 3
  00061	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_VerSetConditionMask

; 320  : 
; 321  : 	if (SUCCEEDED(hr))
; 322  : 	{
; 323  : 		bResult = VerifyVersionInfo(&osviex, VER_MAJORVERSION | VER_MINORVERSION, dwlConditionMask);

  00067	8d 53 03	 lea	 edx, QWORD PTR [rbx+3]
  0006a	48 8d 4c 24 20	 lea	 rcx, QWORD PTR osviex$[rsp]
  0006f	4c 8b c0	 mov	 r8, rax
  00072	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_VerifyVersionInfoW

; 324  : 
; 325  : 		if (bResult)

  00078	3b c3		 cmp	 eax, ebx
  0007a	74 08		 je	 SHORT $LN4@VerifyWind

; 326  : 		{
; 327  : 			*pbResult = TRUE;

  0007c	c7 07 01 00 00
	00		 mov	 DWORD PTR [rdi], 1

; 328  : 		}
; 329  : 		else

  00082	eb 25		 jmp	 SHORT $LN1@VerifyWind
$LN4@VerifyWind:

; 330  : 		{
; 331  : 			dwError = GetLastError();

  00084	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError
  0008a	44 8b d8	 mov	 r11d, eax

; 332  : 
; 333  : 			if (ERROR_OLD_WIN_VERSION == dwError)

  0008d	3d 7e 04 00 00	 cmp	 eax, 1150		; 0000047eH
  00092	75 04		 jne	 SHORT $LN2@VerifyWind

; 334  : 			{
; 335  : 				*pbResult = FALSE;

  00094	89 1f		 mov	 DWORD PTR [rdi], ebx

; 336  : 			}
; 337  : 			else

  00096	eb 11		 jmp	 SHORT $LN1@VerifyWind
$LN2@VerifyWind:

; 338  : 			{
; 339  : 				hr = HRESULT_FROM_WIN32(dwError);

  00098	0f b7 c0	 movzx	 eax, ax
  0009b	0d 00 00 07 80	 or	 eax, -2147024896	; ffffffff80070000H
  000a0	44 3b db	 cmp	 r11d, ebx
  000a3	41 0f 4e c3	 cmovle	 eax, r11d
  000a7	8b d8		 mov	 ebx, eax
$LN1@VerifyWind:

; 340  : 			}
; 341  : 		}
; 342  : 	}
; 343  : 
; 344  : 	return hr;

  000a9	8b c3		 mov	 eax, ebx

; 345  : }

  000ab	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000b3	48 33 cc	 xor	 rcx, rsp
  000b6	e8 00 00 00 00	 call	 __security_check_cookie
  000bb	48 8b 9c 24 68
	01 00 00	 mov	 rbx, QWORD PTR [rsp+360]
  000c3	48 81 c4 50 01
	00 00		 add	 rsp, 336		; 00000150H
  000ca	5f		 pop	 rdi
  000cb	c3		 ret	 0
?VerifyWindowsVersion@@YAJKKPEAH@Z ENDP			; VerifyWindowsVersion
_TEXT	ENDS
PUBLIC	__$ArrayPad$
;	COMDAT pdata
; File c:\program files\microsoft sdks\windows\v6.0a\include\winerror.h
pdata	SEGMENT
$pdata$?ReadFileComplete@@YAJPEAX0K@Z DD imagerel ?ReadFileComplete@@YAJPEAX0K@Z
	DD	imagerel ?ReadFileComplete@@YAJPEAX0K@Z+151
	DD	imagerel $unwind$?ReadFileComplete@@YAJPEAX0K@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ReadFileComplete@@YAJPEAX0K@Z DD 061b19H
	DD	0f340cH
	DD	07008720cH
	DD	050066007H
	DD	imagerel __GSHandlerCheck
	DD	038H
; Function compile flags: /Ogspy
; File e:\my_project\openpdn\openpdn-e28f1ff0077e\src\shellextension\pdnshellextension.cpp
xdata	ENDS
;	COMDAT ?ReadFileComplete@@YAJPEAX0K@Z
_TEXT	SEGMENT
dwBytesRead$106933 = 48
__$ArrayPad$ = 56
hFile$ = 96
lpBuffer$ = 104
nNumberOfBytesToRead$ = 112
?ReadFileComplete@@YAJPEAX0K@Z PROC			; ReadFileComplete, COMDAT

; 235  : {

  00000	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 44 24 38	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  0001b	41 8b f8	 mov	 edi, r8d
  0001e	48 8b f2	 mov	 rsi, rdx
  00021	48 8b e9	 mov	 rbp, rcx

; 236  :     HRESULT hr = S_OK;

  00024	33 db		 xor	 ebx, ebx
$LL6@ReadFileCo:

; 237  : 
; 238  :     while (SUCCEEDED(hr) && nNumberOfBytesToRead > 0)

  00026	85 ff		 test	 edi, edi
  00028	74 51		 je	 SHORT $LN5@ReadFileCo

; 239  :     {
; 240  :         DWORD dwBytesRead = 0;

  0002a	83 64 24 30 00	 and	 DWORD PTR dwBytesRead$106933[rsp], 0

; 241  : 
; 242  :         BOOL bResult = ReadFile(hFile, lpBuffer, nNumberOfBytesToRead, &dwBytesRead, NULL);

  0002f	48 83 64 24 20
	00		 and	 QWORD PTR [rsp+32], 0
  00035	4c 8d 4c 24 30	 lea	 r9, QWORD PTR dwBytesRead$106933[rsp]
  0003a	44 8b c7	 mov	 r8d, edi
  0003d	48 8b d6	 mov	 rdx, rsi
  00040	48 8b cd	 mov	 rcx, rbp
  00043	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ReadFile

; 243  : 
; 244  :         if (!bResult)

  00049	85 c0		 test	 eax, eax
  0004b	75 16		 jne	 SHORT $LN14@ReadFileCo

; 245  :         {
; 246  :             DWORD dwError = GetLastError();

  0004d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError

; 247  :             hr = HRESULT_FROM_WIN32(dwError);

  00053	0f b7 d8	 movzx	 ebx, ax
  00056	81 cb 00 00 07
	80		 or	 ebx, -2147024896	; ffffffff80070000H
  0005c	85 c0		 test	 eax, eax
  0005e	0f 4e d8	 cmovle	 ebx, eax
  00061	eb 0d		 jmp	 SHORT $LN1@ReadFileCo
$LN14@ReadFileCo:

; 248  :         }
; 249  :         else if (bResult && 0 == dwBytesRead)

  00063	8b 4c 24 30	 mov	 ecx, DWORD PTR dwBytesRead$106933[rsp]
  00067	85 c9		 test	 ecx, ecx
  00069	74 0b		 je	 SHORT $LN15@ReadFileCo

; 252  :         }
; 253  :         else
; 254  :         {
; 255  :             lpBuffer = (void *)((BYTE *)lpBuffer + dwBytesRead);

  0006b	48 03 f1	 add	 rsi, rcx

; 256  :             nNumberOfBytesToRead -= dwBytesRead;

  0006e	2b f9		 sub	 edi, ecx
$LN1@ReadFileCo:

; 237  : 
; 238  :     while (SUCCEEDED(hr) && nNumberOfBytesToRead > 0)

  00070	85 db		 test	 ebx, ebx
  00072	78 07		 js	 SHORT $LN5@ReadFileCo
  00074	eb b0		 jmp	 SHORT $LL6@ReadFileCo
$LN15@ReadFileCo:

; 250  :         {
; 251  :             hr = HRESULT_FROM_WIN32(ERROR_HANDLE_EOF);

  00076	bb 26 00 07 80	 mov	 ebx, -2147024858	; ffffffff80070026H
$LN5@ReadFileCo:

; 257  :         }
; 258  :     }
; 259  :     
; 260  :     return hr;

  0007b	8b c3		 mov	 eax, ebx

; 261  : }

  0007d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00082	48 33 cc	 xor	 rcx, rsp
  00085	e8 00 00 00 00	 call	 __security_check_cookie
  0008a	48 8b 5c 24 78	 mov	 rbx, QWORD PTR [rsp+120]
  0008f	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00093	5f		 pop	 rdi
  00094	5e		 pop	 rsi
  00095	5d		 pop	 rbp
  00096	c3		 ret	 0
?ReadFileComplete@@YAJPEAX0K@Z ENDP			; ReadFileComplete
_TEXT	ENDS
EXTRN	__ImageBase:BYTE
;	COMDAT pdata
; File c:\program files\microsoft sdks\windows\v6.0a\include\guiddef.h
pdata	SEGMENT
$pdata$?QueryInterface@CPdnShellExtension@@UEAAJAEBU_GUID@@PEAPEAX@Z DD imagerel $LN38
	DD	imagerel $LN38+232
	DD	imagerel $unwind$?QueryInterface@CPdnShellExtension@@UEAAJAEBU_GUID@@PEAPEAX@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?QueryInterface@CPdnShellExtension@@UEAAJAEBU_GUID@@PEAPEAX@Z DD 020601H
	DD	030023206H
; Function compile flags: /Ogspy
; File e:\my_project\openpdn\openpdn-e28f1ff0077e\src\shellextension\pdnshellextension.cpp
xdata	ENDS
;	COMDAT ?QueryInterface@CPdnShellExtension@@UEAAJAEBU_GUID@@PEAPEAX@Z
_TEXT	SEGMENT
this$ = 48
iid$ = 56
ppvObject$ = 64
?QueryInterface@CPdnShellExtension@@UEAAJAEBU_GUID@@PEAPEAX@Z PROC ; CPdnShellExtension::QueryInterface, COMDAT

; 61   : {

$LN38:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 62   :     HRESULT hr = S_OK;
; 63   :     TraceEnter();
; 64   :     TraceOut("riid=%S", GuidToString(iid));
; 65   : 
; 66   :     if (NULL == ppvObject)

  00006	33 db		 xor	 ebx, ebx
  00008	4c 8b ca	 mov	 r9, rdx
  0000b	4c 3b c3	 cmp	 r8, rbx
  0000e	75 0a		 jne	 SHORT $LN27@QueryInter

; 67   :     {
; 68   :         return E_INVALIDARG;

  00010	b8 57 00 07 80	 mov	 eax, -2147024809	; ffffffff80070057H
  00015	e9 c8 00 00 00	 jmp	 $LN15@QueryInter
$LN27@QueryInter:

; 69   :     }
; 70   : 
; 71   :     if (SUCCEEDED(hr))
; 72   :     {
; 73   :         *ppvObject = NULL;

  0001a	49 89 18	 mov	 QWORD PTR [r8], rbx

; 74   : 
; 75   :         if (IsEqualCLSID(iid, IID_IUnknown))

  0001d	4c 8b 12	 mov	 r10, QWORD PTR [rdx]
  00020	4c 8d 1d 00 00
	00 00		 lea	 r11, OFFSET FLAT:__ImageBase
  00027	4d 3b 93 00 00
	00 00		 cmp	 r10, QWORD PTR IID_IUnknown[r11]
  0002e	75 11		 jne	 SHORT $LN35@QueryInter
  00030	4c 8b 52 08	 mov	 r10, QWORD PTR [rdx+8]
  00034	4d 3b 93 08 00
	00 00		 cmp	 r10, QWORD PTR IID_IUnknown[r11+8]
  0003b	75 04		 jne	 SHORT $LN35@QueryInter
  0003d	8b c3		 mov	 eax, ebx
  0003f	eb 05		 jmp	 SHORT $LN36@QueryInter
$LN35@QueryInter:
  00041	1b c0		 sbb	 eax, eax
  00043	83 d8 ff	 sbb	 eax, -1
$LN36@QueryInter:
  00046	3b c3		 cmp	 eax, ebx

; 76   :         {
; 77   :             *ppvObject = this;

  00048	0f 84 82 00 00
	00		 je	 $LN37@QueryInter

; 78   :         }
; 79   :         else if (IsEqualCLSID(iid, IID_IPersistFile))

  0004e	4c 8b 12	 mov	 r10, QWORD PTR [rdx]
  00051	4d 3b 93 00 00
	00 00		 cmp	 r10, QWORD PTR IID_IPersistFile[r11]
  00058	75 11		 jne	 SHORT $LN33@QueryInter
  0005a	4c 8b 52 08	 mov	 r10, QWORD PTR [rdx+8]
  0005e	4d 3b 93 08 00
	00 00		 cmp	 r10, QWORD PTR IID_IPersistFile[r11+8]
  00065	75 04		 jne	 SHORT $LN33@QueryInter
  00067	8b c3		 mov	 eax, ebx
  00069	eb 05		 jmp	 SHORT $LN34@QueryInter
$LN33@QueryInter:
  0006b	1b c0		 sbb	 eax, eax
  0006d	83 d8 ff	 sbb	 eax, -1
$LN34@QueryInter:
  00070	3b c3		 cmp	 eax, ebx

; 80   :         {
; 81   :             *ppvObject = (IPersistFile *)this;

  00072	74 5c		 je	 SHORT $LN37@QueryInter

; 82   :         }
; 83   :         else if (IsEqualCLSID(iid, IID_IExtractImage))

  00074	4c 8b 12	 mov	 r10, QWORD PTR [rdx]
  00077	4d 3b 93 00 00
	00 00		 cmp	 r10, QWORD PTR IID_IExtractImage[r11]
  0007e	75 11		 jne	 SHORT $LN31@QueryInter
  00080	4c 8b 52 08	 mov	 r10, QWORD PTR [rdx+8]
  00084	4d 3b 93 08 00
	00 00		 cmp	 r10, QWORD PTR IID_IExtractImage[r11+8]
  0008b	75 04		 jne	 SHORT $LN31@QueryInter
  0008d	8b c3		 mov	 eax, ebx
  0008f	eb 05		 jmp	 SHORT $LN32@QueryInter
$LN31@QueryInter:
  00091	1b c0		 sbb	 eax, eax
  00093	83 d8 ff	 sbb	 eax, -1
$LN32@QueryInter:
  00096	3b c3		 cmp	 eax, ebx
  00098	75 10		 jne	 SHORT $LN6@QueryInter

; 84   :         {
; 85   :             *ppvObject = (IExtractImage *)this;

  0009a	48 3b cb	 cmp	 rcx, rbx
  0009d	74 06		 je	 SHORT $LN17@QueryInter
  0009f	48 83 c1 08	 add	 rcx, 8
  000a3	eb 2b		 jmp	 SHORT $LN37@QueryInter
$LN17@QueryInter:
  000a5	48 8b cb	 mov	 rcx, rbx
  000a8	eb 26		 jmp	 SHORT $LN37@QueryInter
$LN6@QueryInter:

; 86   :         }
; 87   :         else if (IsEqualCLSID(iid, CLSID_PdnShellExtension))

  000aa	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  000ad	49 3b 93 00 00
	00 00		 cmp	 rdx, QWORD PTR CLSID_PdnShellExtension[r11]
  000b4	75 11		 jne	 SHORT $LN29@QueryInter
  000b6	49 8b 51 08	 mov	 rdx, QWORD PTR [r9+8]
  000ba	49 3b 93 08 00
	00 00		 cmp	 rdx, QWORD PTR CLSID_PdnShellExtension[r11+8]
  000c1	75 04		 jne	 SHORT $LN29@QueryInter
  000c3	8b c3		 mov	 eax, ebx
  000c5	eb 05		 jmp	 SHORT $LN30@QueryInter
$LN29@QueryInter:
  000c7	1b c0		 sbb	 eax, eax
  000c9	83 d8 ff	 sbb	 eax, -1
$LN30@QueryInter:
  000cc	3b c3		 cmp	 eax, ebx
  000ce	75 0b		 jne	 SHORT $LN4@QueryInter
$LN37@QueryInter:

; 88   :         {
; 89   :             *ppvObject = this;

  000d0	49 89 08	 mov	 QWORD PTR [r8], rcx

; 94   :         }
; 95   :     }
; 96   : 
; 97   :     if (SUCCEEDED(hr))
; 98   :     {
; 99   :         (*(IUnknown **)ppvObject)->AddRef();

  000d3	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  000d6	ff 50 08	 call	 QWORD PTR [rax+8]

; 100  :         hr = S_OK;

  000d9	eb 05		 jmp	 SHORT $LN2@QueryInter
$LN4@QueryInter:

; 90   :         }
; 91   :         else
; 92   :         {
; 93   :             hr = E_NOINTERFACE;

  000db	bb 02 40 00 80	 mov	 ebx, -2147467262	; ffffffff80004002H
$LN2@QueryInter:

; 101  :     }
; 102  : 
; 103  :     TraceLeaveHr(hr);
; 104  :     return hr;

  000e0	8b c3		 mov	 eax, ebx
$LN15@QueryInter:

; 105  : }

  000e2	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000e6	5b		 pop	 rbx
  000e7	c3		 ret	 0
?QueryInterface@CPdnShellExtension@@UEAAJAEBU_GUID@@PEAPEAX@Z ENDP ; CPdnShellExtension::QueryInterface
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GCPdnShellExtension@@QEAAPEAXI@Z DD imagerel $LN6
	DD	imagerel $LN6+52
	DD	imagerel $unwind$??_GCPdnShellExtension@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GCPdnShellExtension@@QEAAPEAXI@Z DD 020601H
	DD	030023206H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT ??_GCPdnShellExtension@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_GCPdnShellExtension@@QEAAPEAXI@Z PROC		; CPdnShellExtension::`scalar deleting destructor', COMDAT
$LN6:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7CPdnShellExtension@@6BIPersistFile@@@
  0000d	48 8b d9	 mov	 rbx, rcx
  00010	48 89 01	 mov	 QWORD PTR [rcx], rax
  00013	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7CPdnShellExtension@@6BIExtractImage@@@
  0001a	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
  0001e	f0 83 05 00 00
	00 00 ff	 lock add DWORD PTR ?g_lRefCount@@3JC, -1 ; g_lRefCount
  00026	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
  0002b	48 8b c3	 mov	 rax, rbx
  0002e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00032	5b		 pop	 rbx
  00033	c3		 ret	 0
??_GCPdnShellExtension@@QEAAPEAXI@Z ENDP		; CPdnShellExtension::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Release@CPdnShellExtension@@UEAAKXZ DD imagerel $LN13
	DD	imagerel $LN13+66
	DD	imagerel $unwind$?Release@CPdnShellExtension@@UEAAKXZ
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Release@CPdnShellExtension@@UEAAKXZ DD 020601H
	DD	030023206H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT ?Release@CPdnShellExtension@@UEAAKXZ
_TEXT	SEGMENT
this$ = 48
?Release@CPdnShellExtension@@UEAAKXZ PROC		; CPdnShellExtension::Release, COMDAT

; 47   : {

$LN13:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 48   :     TraceEnter();
; 49   :     DWORD dwRefCount = (DWORD)InterlockedDecrement(&m_lRefCount);

  00006	83 cb ff	 or	 ebx, -1
  00009	f0 0f c1 59 10	 lock xadd DWORD PTR [rcx+16], ebx
  0000e	83 c3 ff	 add	 ebx, -1

; 50   : 
; 51   :     if (0 == dwRefCount)

  00011	75 27		 jne	 SHORT $LN6@Release

; 52   :     {
; 53   :         delete this;

  00013	48 85 c9	 test	 rcx, rcx
  00016	74 22		 je	 SHORT $LN6@Release
  00018	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7CPdnShellExtension@@6BIPersistFile@@@
  0001f	48 89 01	 mov	 QWORD PTR [rcx], rax
  00022	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7CPdnShellExtension@@6BIExtractImage@@@
  00029	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
  0002d	f0 83 05 00 00
	00 00 ff	 lock add DWORD PTR ?g_lRefCount@@3JC, -1 ; g_lRefCount
  00035	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN6@Release:

; 54   :     }
; 55   : 
; 56   :     TraceLeave();
; 57   :     return dwRefCount;

  0003a	8b c3		 mov	 eax, ebx

; 58   : }

  0003c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00040	5b		 pop	 rbx
  00041	c3		 ret	 0
?Release@CPdnShellExtension@@UEAAKXZ ENDP		; CPdnShellExtension::Release
; Function compile flags: /Ogspy
_TEXT	ENDS
;	COMDAT ??0IPersist@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0IPersist@@QEAA@XZ PROC				; IPersist::IPersist, COMDAT
  00000	48 8b c1	 mov	 rax, rcx
  00003	c3		 ret	 0
??0IPersist@@QEAA@XZ ENDP				; IPersist::IPersist
; Function compile flags: /Ogspy
_TEXT	ENDS
;	COMDAT ??0IExtractImage@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0IExtractImage@@QEAA@XZ PROC				; IExtractImage::IExtractImage, COMDAT
  00000	48 8b c1	 mov	 rax, rcx
  00003	c3		 ret	 0
??0IExtractImage@@QEAA@XZ ENDP				; IExtractImage::IExtractImage
; Function compile flags: /Ogspy
_TEXT	ENDS
;	COMDAT ??0IPersistFile@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0IPersistFile@@QEAA@XZ PROC				; IPersistFile::IPersistFile, COMDAT
  00000	48 8b c1	 mov	 rax, rcx
  00003	c3		 ret	 0
??0IPersistFile@@QEAA@XZ ENDP				; IPersistFile::IPersistFile
_TEXT	ENDS
PUBLIC	??0CPdnShellExtension@@QEAA@XZ			; CPdnShellExtension::CPdnShellExtension
; Function compile flags: /Ogspy
;	COMDAT ??0CPdnShellExtension@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0CPdnShellExtension@@QEAA@XZ PROC			; CPdnShellExtension::CPdnShellExtension, COMDAT

; 28   : {

  00000	48 83 61 18 00	 and	 QWORD PTR [rcx+24], 0
  00005	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7CPdnShellExtension@@6BIPersistFile@@@
  0000c	48 89 01	 mov	 QWORD PTR [rcx], rax
  0000f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7CPdnShellExtension@@6BIExtractImage@@@
  00016	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 29   :     m_size.cx = -1;

  0001a	83 c8 ff	 or	 eax, -1
  0001d	c7 41 10 01 00
	00 00		 mov	 DWORD PTR [rcx+16], 1
  00024	89 41 20	 mov	 DWORD PTR [rcx+32], eax

; 30   :     m_size.cy = -1;

  00027	89 41 24	 mov	 DWORD PTR [rcx+36], eax

; 31   :     InterlockedIncrement(&g_lRefCount);

  0002a	f0 83 05 00 00
	00 00 01	 lock add DWORD PTR ?g_lRefCount@@3JC, 1 ; g_lRefCount

; 32   : }

  00032	48 8b c1	 mov	 rax, rcx
  00035	c3		 ret	 0
??0CPdnShellExtension@@QEAA@XZ ENDP			; CPdnShellExtension::CPdnShellExtension
_TEXT	ENDS
;	COMDAT pdata
; File c:\program files (x86)\microsoft visual studio 9.0\vc\atlmfc\include\atlenc.h
pdata	SEGMENT
$pdata$?Base64Decode@ATL@@YAHPEBDHPEAEPEAH@Z DD imagerel $LN36
	DD	imagerel $LN36+339
	DD	imagerel $unwind$?Base64Decode@ATL@@YAHPEBDHPEAEPEAH@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Base64Decode@ATL@@YAHPEBDHPEAEPEAH@Z DD 0b1901H
	DD	077419H
	DD	066419H
	DD	055419H
	DD	043419H
	DD	0d017e019H
	DD	0c015H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT ?Base64Decode@ATL@@YAHPEBDHPEAEPEAH@Z
_TEXT	SEGMENT
szSrc$ = 32
nSrcLen$ = 40
pbDest$ = 48
pnDestLen$ = 56
?Base64Decode@ATL@@YAHPEBDHPEAEPEAH@Z PROC		; ATL::Base64Decode, COMDAT

; 193  : {

$LN36:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 68 10	 mov	 QWORD PTR [rax+16], rbp
  0000b	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  0000f	48 89 78 20	 mov	 QWORD PTR [rax+32], rdi
  00013	41 54		 push	 r12
  00015	41 55		 push	 r13
  00017	41 56		 push	 r14

; 194  : 	// walk the source buffer
; 195  : 	// each four character sequence is converted to 3 bytes
; 196  : 	// CRLFs and =, and any characters not in the encoding table
; 197  : 	// are skiped
; 198  : 
; 199  : 	if (szSrc == NULL || pnDestLen == NULL)

  00019	45 33 d2	 xor	 r10d, r10d
  0001c	4d 8b e1	 mov	 r12, r9
  0001f	49 8b f0	 mov	 rsi, r8
  00022	4c 8b d9	 mov	 r11, rcx
  00025	4d 3b ca	 cmp	 r9, r10
  00028	75 07		 jne	 SHORT $LN16@Base64Deco

; 200  : 	{
; 201  : 		ATLASSERT(FALSE);
; 202  : 		return FALSE;

  0002a	33 c0		 xor	 eax, eax
  0002c	e9 07 01 00 00	 jmp	 $LN2@Base64Deco
$LN16@Base64Deco:

; 203  : 	}
; 204  : 	
; 205  : 	LPCSTR szSrcEnd = szSrc + nSrcLen;

  00031	4c 63 c2	 movsxd	 r8, edx

; 206  : 	int nWritten = 0;
; 207  : 	
; 208  : 	BOOL bOverflow = (pbDest == NULL) ? TRUE : FALSE;

  00034	41 8b da	 mov	 ebx, r10d
  00037	41 8b ea	 mov	 ebp, r10d
  0003a	4c 03 c1	 add	 r8, rcx
  0003d	49 3b f2	 cmp	 rsi, r10
  00040	0f 94 c3	 sete	 bl

; 209  : 	
; 210  : 	while (szSrc < szSrcEnd &&(*szSrc) != 0)

  00043	49 3b c8	 cmp	 rcx, r8
  00046	0f 83 de 00 00
	00		 jae	 $LN13@Base64Deco
  0004c	41 be 01 00 00
	00		 mov	 r14d, 1
$LL14@Base64Deco:
  00052	45 38 13	 cmp	 BYTE PTR [r11], r10b
  00055	0f 84 cf 00 00
	00		 je	 $LN13@Base64Deco

; 211  : 	{
; 212  : 		DWORD dwCurr = 0;

  0005b	45 8b ca	 mov	 r9d, r10d

; 213  : 		int i;
; 214  : 		int nBits = 0;

  0005e	45 8b ea	 mov	 r13d, r10d

; 215  : 		for (i=0; i<4; i++)

  00061	41 8b d2	 mov	 edx, r10d
$LL12@Base64Deco:

; 216  : 		{
; 217  : 			if (szSrc >= szSrcEnd)

  00064	4d 3b d8	 cmp	 r11, r8
  00067	73 61		 jae	 SHORT $LN32@Base64Deco

; 218  : 				break;
; 219  : 			int nCh = DecodeBase64Char(*szSrc);

  00069	41 0f be 0b	 movsx	 ecx, BYTE PTR [r11]
  0006d	8d 41 bf	 lea	 eax, DWORD PTR [rcx-65]
  00070	83 f8 19	 cmp	 eax, 25
  00073	77 05		 ja	 SHORT $LN26@Base64Deco
  00075	8d 41 bf	 lea	 eax, DWORD PTR [rcx-65]
  00078	eb 30		 jmp	 SHORT $LN22@Base64Deco
$LN26@Base64Deco:
  0007a	8d 41 9f	 lea	 eax, DWORD PTR [rcx-97]
  0007d	83 f8 19	 cmp	 eax, 25
  00080	77 05		 ja	 SHORT $LN25@Base64Deco
  00082	8d 41 b9	 lea	 eax, DWORD PTR [rcx-71]
  00085	eb 23		 jmp	 SHORT $LN22@Base64Deco
$LN25@Base64Deco:
  00087	8d 41 d0	 lea	 eax, DWORD PTR [rcx-48]
  0008a	83 f8 09	 cmp	 eax, 9
  0008d	77 05		 ja	 SHORT $LN24@Base64Deco
  0008f	8d 41 04	 lea	 eax, DWORD PTR [rcx+4]
  00092	eb 16		 jmp	 SHORT $LN22@Base64Deco
$LN24@Base64Deco:
  00094	83 f9 2b	 cmp	 ecx, 43			; 0000002bH
  00097	75 05		 jne	 SHORT $LN23@Base64Deco
  00099	8d 41 13	 lea	 eax, QWORD PTR [rcx+19]
  0009c	eb 0c		 jmp	 SHORT $LN22@Base64Deco
$LN23@Base64Deco:
  0009e	83 c8 ff	 or	 eax, -1
  000a1	83 f9 2f	 cmp	 ecx, 47			; 0000002fH
  000a4	8d 78 40	 lea	 edi, QWORD PTR [rax+64]
  000a7	0f 44 c7	 cmove	 eax, edi
$LN22@Base64Deco:

; 220  : 			szSrc++;

  000aa	4d 03 de	 add	 r11, r14

; 221  : 			if (nCh == -1)

  000ad	83 f8 ff	 cmp	 eax, -1
  000b0	75 05		 jne	 SHORT $LN8@Base64Deco

; 222  : 			{
; 223  : 				// skip this char
; 224  : 				i--;

  000b2	41 2b d6	 sub	 edx, r14d

; 225  : 				continue;

  000b5	eb 0b		 jmp	 SHORT $LN11@Base64Deco
$LN8@Base64Deco:

; 226  : 			}
; 227  : 			dwCurr <<= 6;

  000b7	41 c1 e1 06	 shl	 r9d, 6

; 228  : 			dwCurr |= nCh;

  000bb	44 0b c8	 or	 r9d, eax

; 229  : 			nBits += 6;

  000be	41 83 c5 06	 add	 r13d, 6
$LN11@Base64Deco:
  000c2	41 03 d6	 add	 edx, r14d
  000c5	83 fa 04	 cmp	 edx, 4
  000c8	7c 9a		 jl	 SHORT $LL12@Base64Deco
$LN32@Base64Deco:

; 230  : 		}
; 231  : 
; 232  : 		if(!bOverflow && nWritten + (nBits/8) > (*pnDestLen))

  000ca	41 3b da	 cmp	 ebx, r10d
  000cd	75 16		 jne	 SHORT $LN7@Base64Deco
  000cf	41 8b c5	 mov	 eax, r13d
  000d2	99		 cdq
  000d3	83 e2 07	 and	 edx, 7
  000d6	03 c2		 add	 eax, edx
  000d8	c1 f8 03	 sar	 eax, 3
  000db	03 c5		 add	 eax, ebp
  000dd	41 3b 04 24	 cmp	 eax, DWORD PTR [r12]
  000e1	41 0f 4f de	 cmovg	 ebx, r14d
$LN7@Base64Deco:

; 233  : 			bOverflow = TRUE;
; 234  : 
; 235  : 		// dwCurr has the 3 bytes to write to the output buffer
; 236  : 		// left to right
; 237  : 		dwCurr <<= 24-nBits;
; 238  : 		for (i=0; i<nBits/8; i++)

  000e5	41 8b c5	 mov	 eax, r13d
  000e8	b9 18 00 00 00	 mov	 ecx, 24

; 239  : 		{
; 240  : 			if(!bOverflow)

  000ed	48 63 fb	 movsxd	 rdi, ebx
  000f0	99		 cdq
  000f1	41 2b cd	 sub	 ecx, r13d
  000f4	83 e2 07	 and	 edx, 7
  000f7	41 d3 e1	 shl	 r9d, cl
  000fa	03 c2		 add	 eax, edx
  000fc	c1 f8 03	 sar	 eax, 3
  000ff	41 3b c2	 cmp	 eax, r10d
  00102	7e 1d		 jle	 SHORT $LN4@Base64Deco
  00104	8b c8		 mov	 ecx, eax
  00106	03 e8		 add	 ebp, eax
$LL6@Base64Deco:
  00108	49 3b fa	 cmp	 rdi, r10
  0010b	75 0b		 jne	 SHORT $LN3@Base64Deco

; 241  : 			{
; 242  : 				*pbDest = (BYTE) ((dwCurr & 0x00ff0000) >> 16);

  0010d	41 8b c1	 mov	 eax, r9d
  00110	c1 e8 10	 shr	 eax, 16
  00113	88 06		 mov	 BYTE PTR [rsi], al

; 243  : 				pbDest++;

  00115	49 03 f6	 add	 rsi, r14
$LN3@Base64Deco:

; 244  : 			}
; 245  : 			dwCurr <<= 8;

  00118	41 c1 e1 08	 shl	 r9d, 8
  0011c	49 2b ce	 sub	 rcx, r14
  0011f	75 e7		 jne	 SHORT $LL6@Base64Deco
$LN4@Base64Deco:

; 209  : 	
; 210  : 	while (szSrc < szSrcEnd &&(*szSrc) != 0)

  00121	4d 3b d8	 cmp	 r11, r8
  00124	0f 82 28 ff ff
	ff		 jb	 $LL14@Base64Deco
$LN13@Base64Deco:

; 246  : 			nWritten++;
; 247  : 		}
; 248  : 
; 249  : 	}
; 250  : 	
; 251  : 	*pnDestLen = nWritten;
; 252  : 	
; 253  : 	if(bOverflow)

  0012a	41 3b da	 cmp	 ebx, r10d
  0012d	41 89 2c 24	 mov	 DWORD PTR [r12], ebp
  00131	41 0f 94 c2	 sete	 r10b
  00135	41 8b c2	 mov	 eax, r10d
$LN2@Base64Deco:

; 254  : 	{
; 255  : 		if(pbDest != NULL)
; 256  : 		{
; 257  : 			ATLASSERT(FALSE);
; 258  : 		}
; 259  : 	
; 260  : 		return FALSE;
; 261  : 	}
; 262  : 	
; 263  : 	return TRUE;
; 264  : }

  00138	48 8b 5c 24 20	 mov	 rbx, QWORD PTR [rsp+32]
  0013d	48 8b 6c 24 28	 mov	 rbp, QWORD PTR [rsp+40]
  00142	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  00147	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]
  0014c	41 5e		 pop	 r14
  0014e	41 5d		 pop	 r13
  00150	41 5c		 pop	 r12
  00152	c3		 ret	 0
?Base64Decode@ATL@@YAHPEBDHPEAEPEAH@Z ENDP		; ATL::Base64Decode
; Function compile flags: /Ogspy
; File c:\program files\microsoft sdks\windows\v6.0a\include\gdiplusbitmap.h
_TEXT	ENDS
;	COMDAT ??0Bitmap@Gdiplus@@IEAA@PEAVGpBitmap@1@@Z
_TEXT	SEGMENT
this$ = 8
nativeBitmap$ = 16
??0Bitmap@Gdiplus@@IEAA@PEAVGpBitmap@1@@Z PROC		; Gdiplus::Bitmap::Bitmap, COMDAT

; 874  :     lastResult = Ok;

  00000	83 61 10 00	 and	 DWORD PTR [rcx+16], 0
  00004	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7Bitmap@Gdiplus@@6B@

; 875  : 
; 876  :     SetNativeImage(nativeBitmap);

  0000b	48 89 51 08	 mov	 QWORD PTR [rcx+8], rdx
  0000f	48 89 01	 mov	 QWORD PTR [rcx], rax

; 877  : }

  00012	48 8b c1	 mov	 rax, rcx
  00015	c3		 ret	 0
??0Bitmap@Gdiplus@@IEAA@PEAVGpBitmap@1@@Z ENDP		; Gdiplus::Bitmap::Bitmap
_TEXT	ENDS
PUBLIC	__$ArrayPad$
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Clone@Bitmap@Gdiplus@@QEAAPEAV12@HHHHH@Z DD imagerel $LN20
	DD	imagerel $LN20+192
	DD	imagerel $unwind$?Clone@Bitmap@Gdiplus@@QEAAPEAV12@HHHHH@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Clone@Bitmap@Gdiplus@@QEAAPEAV12@HHHHH@Z DD 031619H
	DD	07003a207H
	DD	03002H
	DD	imagerel __GSHandlerCheck
	DD	048H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT ?Clone@Bitmap@Gdiplus@@QEAAPEAV12@HHHHH@Z
_TEXT	SEGMENT
gpdstBitmap$ = 64
__$ArrayPad$ = 72
this$ = 112
x$ = 120
y$ = 128
width$ = 136
height$ = 144
format$ = 152
?Clone@Bitmap@Gdiplus@@QEAAPEAV12@HHHHH@Z PROC		; Gdiplus::Bitmap::Clone, COMDAT

; 803  : {

$LN20:
  00000	40 53		 push	 rbx
  00002	57		 push	 rdi
  00003	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  00007	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0000e	48 33 c4	 xor	 rax, rsp
  00011	48 89 44 24 48	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 804  :    GpBitmap* gpdstBitmap = NULL;

  00016	48 83 64 24 40
	00		 and	 QWORD PTR gpdstBitmap$[rsp], 0
  0001c	41 8b d9	 mov	 ebx, r9d

; 805  :    Bitmap* bitmap;
; 806  : 
; 807  :    if (SetStatus(DllExports::GdipCloneBitmapAreaI(
; 808  :                                x,
; 809  :                                y,
; 810  :                                width,
; 811  :                                height,
; 812  :                                format,
; 813  :                                (GpBitmap *)nativeImage,
; 814  :                                &gpdstBitmap)) == Ok)

  0001f	44 8b 8c 24 90
	00 00 00	 mov	 r9d, DWORD PTR height$[rsp]
  00027	45 8b d8	 mov	 r11d, r8d
  0002a	44 8b d2	 mov	 r10d, edx
  0002d	48 8d 44 24 40	 lea	 rax, QWORD PTR gpdstBitmap$[rsp]
  00032	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00037	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  0003b	48 8b f9	 mov	 rdi, rcx
  0003e	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00043	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR format$[rsp]
  0004a	44 8b c3	 mov	 r8d, ebx
  0004d	41 8b d3	 mov	 edx, r11d
  00050	41 8b ca	 mov	 ecx, r10d
  00053	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00057	e8 00 00 00 00	 call	 GdipCloneBitmapAreaI
  0005c	85 c0		 test	 eax, eax
  0005e	74 05		 je	 SHORT $LN9@Clone
  00060	89 47 10	 mov	 DWORD PTR [rdi+16], eax
  00063	eb 02		 jmp	 SHORT $LN8@Clone
$LN9@Clone:
  00065	33 c0		 xor	 eax, eax
$LN8@Clone:
  00067	85 c0		 test	 eax, eax
  00069	75 3f		 jne	 SHORT $LN3@Clone

; 815  :    {
; 816  :        bitmap = new Bitmap(gpdstBitmap);

  0006b	8d 48 18	 lea	 ecx, QWORD PTR [rax+24]
  0006e	e8 00 00 00 00	 call	 GdipAlloc
  00073	48 8b d8	 mov	 rbx, rax
  00076	48 85 c0	 test	 rax, rax
  00079	74 19		 je	 SHORT $LN6@Clone
  0007b	48 8b 44 24 40	 mov	 rax, QWORD PTR gpdstBitmap$[rsp]
  00080	83 63 10 00	 and	 DWORD PTR [rbx+16], 0
  00084	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_7Bitmap@Gdiplus@@6B@
  0008b	48 89 43 08	 mov	 QWORD PTR [rbx+8], rax
  0008f	48 89 0b	 mov	 QWORD PTR [rbx], rcx
  00092	eb 02		 jmp	 SHORT $LN7@Clone
$LN6@Clone:
  00094	33 db		 xor	 ebx, ebx
$LN7@Clone:

; 817  : 
; 818  :        if (bitmap == NULL) 

  00096	48 85 db	 test	 rbx, rbx
  00099	75 0a		 jne	 SHORT $LN2@Clone

; 819  :        {
; 820  :            DllExports::GdipDisposeImage(gpdstBitmap);

  0009b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR gpdstBitmap$[rsp]
  000a0	e8 00 00 00 00	 call	 GdipDisposeImage
$LN2@Clone:

; 821  :        }
; 822  : 
; 823  :        return bitmap;

  000a5	48 8b c3	 mov	 rax, rbx
  000a8	eb 02		 jmp	 SHORT $LN1@Clone
$LN3@Clone:

; 824  :    }
; 825  :    else
; 826  :        return NULL;

  000aa	33 c0		 xor	 eax, eax
$LN1@Clone:

; 827  : }

  000ac	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000b1	48 33 cc	 xor	 rcx, rsp
  000b4	e8 00 00 00 00	 call	 __security_check_cookie
  000b9	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000bd	5f		 pop	 rdi
  000be	5b		 pop	 rbx
  000bf	c3		 ret	 0
?Clone@Bitmap@Gdiplus@@QEAAPEAV12@HHHHH@Z ENDP		; Gdiplus::Bitmap::Clone
_TEXT	ENDS
PUBLIC	__$ArrayPad$
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Clone@Bitmap@Gdiplus@@QEAAPEAV12@AEBVRect@2@H@Z DD imagerel $LN22
	DD	imagerel $LN22+168
	DD	imagerel $unwind$?Clone@Bitmap@Gdiplus@@QEAAPEAV12@AEBVRect@2@H@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Clone@Bitmap@Gdiplus@@QEAAPEAV12@AEBVRect@2@H@Z DD 021719H
	DD	030049208H
	DD	imagerel __GSHandlerCheck
	DD	048H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT ?Clone@Bitmap@Gdiplus@@QEAAPEAV12@AEBVRect@2@H@Z
_TEXT	SEGMENT
gpdstBitmap$112285 = 64
__$ArrayPad$ = 72
this$ = 96
rect$ = 104
format$ = 112
?Clone@Bitmap@Gdiplus@@QEAAPEAV12@AEBVRect@2@H@Z PROC	; Gdiplus::Bitmap::Clone, COMDAT

; 791  : {

$LN22:
  00000	4c 8b dc	 mov	 r11, rsp
  00003	53		 push	 rbx
  00004	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00008	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0000f	48 33 c4	 xor	 rax, rsp
  00012	48 89 44 24 48	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 792  :     return Clone(rect.X, rect.Y, rect.Width, rect.Height, format);

  00017	44 8b 4a 0c	 mov	 r9d, DWORD PTR [rdx+12]
  0001b	49 83 63 e8 00	 and	 QWORD PTR [r11-24], 0
  00020	49 8d 43 e8	 lea	 rax, QWORD PTR [r11-24]
  00024	49 89 43 d8	 mov	 QWORD PTR [r11-40], rax
  00028	48 8b d9	 mov	 rbx, rcx
  0002b	8b 0a		 mov	 ecx, DWORD PTR [rdx]
  0002d	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
  00031	49 89 43 d0	 mov	 QWORD PTR [r11-48], rax
  00035	45 89 43 c8	 mov	 DWORD PTR [r11-56], r8d
  00039	44 8b 42 08	 mov	 r8d, DWORD PTR [rdx+8]
  0003d	8b 52 04	 mov	 edx, DWORD PTR [rdx+4]
  00040	e8 00 00 00 00	 call	 GdipCloneBitmapAreaI
  00045	85 c0		 test	 eax, eax
  00047	74 05		 je	 SHORT $LN11@Clone@2
  00049	89 43 10	 mov	 DWORD PTR [rbx+16], eax
  0004c	eb 02		 jmp	 SHORT $LN10@Clone@2
$LN11@Clone@2:
  0004e	33 c0		 xor	 eax, eax
$LN10@Clone@2:
  00050	85 c0		 test	 eax, eax
  00052	75 3c		 jne	 SHORT $LN5@Clone@2
  00054	8d 48 18	 lea	 ecx, QWORD PTR [rax+24]
  00057	e8 00 00 00 00	 call	 GdipAlloc
  0005c	48 8b d8	 mov	 rbx, rax
  0005f	48 85 c0	 test	 rax, rax
  00062	74 19		 je	 SHORT $LN8@Clone@2
  00064	48 8b 44 24 40	 mov	 rax, QWORD PTR gpdstBitmap$112285[rsp]
  00069	83 63 10 00	 and	 DWORD PTR [rbx+16], 0
  0006d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_7Bitmap@Gdiplus@@6B@
  00074	48 89 43 08	 mov	 QWORD PTR [rbx+8], rax
  00078	48 89 0b	 mov	 QWORD PTR [rbx], rcx
  0007b	eb 02		 jmp	 SHORT $LN9@Clone@2
$LN8@Clone@2:
  0007d	33 db		 xor	 ebx, ebx
$LN9@Clone@2:
  0007f	48 85 db	 test	 rbx, rbx
  00082	75 0e		 jne	 SHORT $LN3@Clone@2
  00084	48 8b 4c 24 40	 mov	 rcx, QWORD PTR gpdstBitmap$112285[rsp]
  00089	e8 00 00 00 00	 call	 GdipDisposeImage
  0008e	eb 02		 jmp	 SHORT $LN3@Clone@2
$LN5@Clone@2:
  00090	33 db		 xor	 ebx, ebx
$LN3@Clone@2:
  00092	48 8b c3	 mov	 rax, rbx

; 793  : }

  00095	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0009a	48 33 cc	 xor	 rcx, rsp
  0009d	e8 00 00 00 00	 call	 __security_check_cookie
  000a2	48 83 c4 50	 add	 rsp, 80			; 00000050H
  000a6	5b		 pop	 rbx
  000a7	c3		 ret	 0
?Clone@Bitmap@Gdiplus@@QEAAPEAV12@AEBVRect@2@H@Z ENDP	; Gdiplus::Bitmap::Clone
_TEXT	ENDS
;	COMDAT pdata
; File c:\program files\microsoft sdks\windows\v6.0a\include\gdiplusheaders.h
pdata	SEGMENT
$pdata$?GetHBITMAP@Bitmap@Gdiplus@@QEAA?AW4Status@2@AEBVColor@2@PEAPEAUHBITMAP__@@@Z DD imagerel $LN9
	DD	imagerel $LN9+44
	DD	imagerel $unwind$?GetHBITMAP@Bitmap@Gdiplus@@QEAA?AW4Status@2@AEBVColor@2@PEAPEAUHBITMAP__@@@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetHBITMAP@Bitmap@Gdiplus@@QEAA?AW4Status@2@AEBVColor@2@PEAPEAUHBITMAP__@@@Z DD 020601H
	DD	030023206H
; Function compile flags: /Ogspy
; File c:\program files\microsoft sdks\windows\v6.0a\include\gdiplusbitmap.h
xdata	ENDS
;	COMDAT ?GetHBITMAP@Bitmap@Gdiplus@@QEAA?AW4Status@2@AEBVColor@2@PEAPEAUHBITMAP__@@@Z
_TEXT	SEGMENT
this$ = 48
colorBackground$ = 56
hbmReturn$ = 64
?GetHBITMAP@Bitmap@Gdiplus@@QEAA?AW4Status@2@AEBVColor@2@PEAPEAUHBITMAP__@@@Z PROC ; Gdiplus::Bitmap::GetHBITMAP, COMDAT

; 769  : {

$LN9:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	49 8b c0	 mov	 rax, r8

; 770  :     return SetStatus(DllExports::GdipCreateHBITMAPFromBitmap(
; 771  :                                         static_cast<GpBitmap*>(nativeImage),
; 772  :                                         hbmReturn,
; 773  :                                         colorBackground.GetValue()));

  00009	44 8b 02	 mov	 r8d, DWORD PTR [rdx]
  0000c	48 8b d9	 mov	 rbx, rcx
  0000f	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00013	48 8b d0	 mov	 rdx, rax
  00016	e8 00 00 00 00	 call	 GdipCreateHBITMAPFromBitmap
  0001b	85 c0		 test	 eax, eax
  0001d	74 05		 je	 SHORT $LN6@GetHBITMAP
  0001f	89 43 10	 mov	 DWORD PTR [rbx+16], eax
  00022	eb 02		 jmp	 SHORT $LN5@GetHBITMAP
$LN6@GetHBITMAP:
  00024	33 c0		 xor	 eax, eax
$LN5@GetHBITMAP:

; 774  : }

  00026	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002a	5b		 pop	 rbx
  0002b	c3		 ret	 0
?GetHBITMAP@Bitmap@Gdiplus@@QEAA?AW4Status@2@AEBVColor@2@PEAPEAUHBITMAP__@@@Z ENDP ; Gdiplus::Bitmap::GetHBITMAP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0Bitmap@Gdiplus@@QEAA@HHH@Z DD imagerel $LN7
	DD	imagerel $LN7+116
	DD	imagerel $unwind$??0Bitmap@Gdiplus@@QEAA@HHH@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0Bitmap@Gdiplus@@QEAA@HHH@Z DD 021519H
	DD	030027206H
	DD	imagerel __GSHandlerCheck
	DD	038H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT ??0Bitmap@Gdiplus@@QEAA@HHH@Z
_TEXT	SEGMENT
bitmap$ = 48
__$ArrayPad$ = 56
this$ = 80
width$ = 88
height$ = 96
format$ = 104
??0Bitmap@Gdiplus@@QEAA@HHH@Z PROC			; Gdiplus::Bitmap::Bitmap, COMDAT

; 601  : {

$LN7:
  00000	40 53		 push	 rbx
  00002	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00006	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0000d	48 33 c4	 xor	 rax, rsp
  00010	48 89 44 24 38	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 602  :     GpBitmap *bitmap = NULL;

  00015	48 83 64 24 30
	00		 and	 QWORD PTR bitmap$[rsp], 0
  0001b	45 8b d8	 mov	 r11d, r8d
  0001e	44 8b d2	 mov	 r10d, edx
  00021	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7Bitmap@Gdiplus@@6B@
  00028	48 8b d9	 mov	 rbx, rcx

; 603  : 
; 604  :     lastResult = DllExports::GdipCreateBitmapFromScan0(width,
; 605  :                                                        height,
; 606  :                                                        0,
; 607  :                                                        format,
; 608  :                                                        NULL,
; 609  :                                                        &bitmap);

  0002b	41 b9 0a 20 26
	00		 mov	 r9d, 2498570		; 0026200aH
  00031	48 89 01	 mov	 QWORD PTR [rcx], rax
  00034	48 8d 44 24 30	 lea	 rax, QWORD PTR bitmap$[rsp]
  00039	45 33 c0	 xor	 r8d, r8d
  0003c	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00041	48 83 64 24 20
	00		 and	 QWORD PTR [rsp+32], 0
  00047	41 8b d3	 mov	 edx, r11d
  0004a	41 8b ca	 mov	 ecx, r10d
  0004d	e8 00 00 00 00	 call	 GdipCreateBitmapFromScan0

; 610  : 
; 611  :     SetNativeImage(bitmap);

  00052	48 8b 4c 24 30	 mov	 rcx, QWORD PTR bitmap$[rsp]
  00057	89 43 10	 mov	 DWORD PTR [rbx+16], eax
  0005a	48 89 4b 08	 mov	 QWORD PTR [rbx+8], rcx

; 612  : }

  0005e	48 8b c3	 mov	 rax, rbx
  00061	48 8b 4c 24 38	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00066	48 33 cc	 xor	 rcx, rsp
  00069	e8 00 00 00 00	 call	 __security_check_cookie
  0006e	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00072	5b		 pop	 rbx
  00073	c3		 ret	 0
??0Bitmap@Gdiplus@@QEAA@HHH@Z ENDP			; Gdiplus::Bitmap::Bitmap
_TEXT	ENDS
PUBLIC	__$ArrayPad$
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0Bitmap@Gdiplus@@QEAA@PEAUIStream@@H@Z DD imagerel $LN9
	DD	imagerel $LN9+90
	DD	imagerel $unwind$??0Bitmap@Gdiplus@@QEAA@PEAUIStream@@H@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0Bitmap@Gdiplus@@QEAA@PEAUIStream@@H@Z DD 021519H
	DD	030025206H
	DD	imagerel __GSHandlerCheck
	DD	028H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT ??0Bitmap@Gdiplus@@QEAA@PEAUIStream@@H@Z
_TEXT	SEGMENT
bitmap$ = 32
__$ArrayPad$ = 40
this$ = 64
stream$ = 72
useEmbeddedColorManagement$ = 80
??0Bitmap@Gdiplus@@QEAA@PEAUIStream@@H@Z PROC		; Gdiplus::Bitmap::Bitmap, COMDAT

; 559  : {

$LN9:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0000d	48 33 c4	 xor	 rax, rsp
  00010	48 89 44 24 28	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 560  :     GpBitmap *bitmap = NULL;

  00015	48 83 64 24 20
	00		 and	 QWORD PTR bitmap$[rsp], 0
  0001b	4c 8b c2	 mov	 r8, rdx
  0001e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7Bitmap@Gdiplus@@6B@
  00025	48 8b d9	 mov	 rbx, rcx
  00028	48 89 01	 mov	 QWORD PTR [rcx], rax

; 561  : 
; 562  :     if(useEmbeddedColorManagement)
; 563  :     {
; 564  :         lastResult = DllExports::GdipCreateBitmapFromStreamICM(stream, &bitmap);
; 565  :     }
; 566  :     else
; 567  :     {
; 568  :         lastResult = DllExports::GdipCreateBitmapFromStream(stream, &bitmap);

  0002b	48 8d 54 24 20	 lea	 rdx, QWORD PTR bitmap$[rsp]
  00030	49 8b c8	 mov	 rcx, r8
  00033	e8 00 00 00 00	 call	 GdipCreateBitmapFromStream

; 569  :     }
; 570  : 
; 571  :     SetNativeImage(bitmap);

  00038	48 8b 4c 24 20	 mov	 rcx, QWORD PTR bitmap$[rsp]
  0003d	89 43 10	 mov	 DWORD PTR [rbx+16], eax
  00040	48 89 4b 08	 mov	 QWORD PTR [rbx+8], rcx

; 572  : }

  00044	48 8b c3	 mov	 rax, rbx
  00047	48 8b 4c 24 28	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0004c	48 33 cc	 xor	 rcx, rsp
  0004f	e8 00 00 00 00	 call	 __security_check_cookie
  00054	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00058	5b		 pop	 rbx
  00059	c3		 ret	 0
??0Bitmap@Gdiplus@@QEAA@PEAUIStream@@H@Z ENDP		; Gdiplus::Bitmap::Bitmap
; Function compile flags: /Ogspy
_TEXT	ENDS
;	COMDAT ??1Bitmap@Gdiplus@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1Bitmap@Gdiplus@@UEAA@XZ PROC				; Gdiplus::Bitmap::~Bitmap, COMDAT
  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7Image@Gdiplus@@6B@
  00007	48 89 01	 mov	 QWORD PTR [rcx], rax
  0000a	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0000e	e9 00 00 00 00	 jmp	 GdipDisposeImage
??1Bitmap@Gdiplus@@UEAA@XZ ENDP				; Gdiplus::Bitmap::~Bitmap
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GBitmap@Gdiplus@@UEAAPEAXI@Z DD imagerel $LN10
	DD	imagerel $LN10+61
	DD	imagerel $unwind$??_GBitmap@Gdiplus@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GBitmap@Gdiplus@@UEAAPEAXI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT ??_GBitmap@Gdiplus@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_GBitmap@Gdiplus@@UEAAPEAXI@Z PROC			; Gdiplus::Bitmap::`scalar deleting destructor', COMDAT
$LN10:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7Image@Gdiplus@@6B@
  00011	48 8b f9	 mov	 rdi, rcx
  00014	8b da		 mov	 ebx, edx
  00016	48 89 01	 mov	 QWORD PTR [rcx], rax
  00019	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0001d	e8 00 00 00 00	 call	 GdipDisposeImage
  00022	f6 c3 01	 test	 bl, 1
  00025	74 08		 je	 SHORT $LN8@scalar
  00027	48 8b cf	 mov	 rcx, rdi
  0002a	e8 00 00 00 00	 call	 GdipFree
$LN8@scalar:
  0002f	48 8b c7	 mov	 rax, rdi
  00032	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00037	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003b	5f		 pop	 rdi
  0003c	c3		 ret	 0
??_GBitmap@Gdiplus@@UEAAPEAXI@Z ENDP			; Gdiplus::Bitmap::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	__$ArrayPad$
;	COMDAT pdata
; File c:\program files\microsoft sdks\windows\v6.0a\include\gdiplusheaders.h
pdata	SEGMENT
$pdata$?GetPixelFormat@Image@Gdiplus@@QEAAHXZ DD imagerel $LN7
	DD	imagerel $LN7+68
	DD	imagerel $unwind$?GetPixelFormat@Image@Gdiplus@@QEAAHXZ
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetPixelFormat@Image@Gdiplus@@QEAAHXZ DD 021519H
	DD	030025206H
	DD	imagerel __GSHandlerCheck
	DD	028H
; Function compile flags: /Ogspy
; File c:\program files\microsoft sdks\windows\v6.0a\include\gdiplusbitmap.h
xdata	ENDS
;	COMDAT ?GetPixelFormat@Image@Gdiplus@@QEAAHXZ
_TEXT	SEGMENT
format$ = 32
__$ArrayPad$ = 40
this$ = 64
?GetPixelFormat@Image@Gdiplus@@QEAAHXZ PROC		; Gdiplus::Image::GetPixelFormat, COMDAT

; 281  : {

$LN7:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0000d	48 33 c4	 xor	 rax, rsp
  00010	48 89 44 24 28	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00015	48 8b d9	 mov	 rbx, rcx

; 282  :     PixelFormat format;
; 283  : 
; 284  :     SetStatus(DllExports::GdipGetImagePixelFormat(nativeImage, &format));

  00018	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0001c	48 8d 54 24 20	 lea	 rdx, QWORD PTR format$[rsp]
  00021	e8 00 00 00 00	 call	 GdipGetImagePixelFormat
  00026	85 c0		 test	 eax, eax
  00028	74 03		 je	 SHORT $LN4@GetPixelFo
  0002a	89 43 10	 mov	 DWORD PTR [rbx+16], eax
$LN4@GetPixelFo:

; 285  : 
; 286  :     return format;

  0002d	8b 44 24 20	 mov	 eax, DWORD PTR format$[rsp]

; 287  : }

  00031	48 8b 4c 24 28	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00036	48 33 cc	 xor	 rcx, rsp
  00039	e8 00 00 00 00	 call	 __security_check_cookie
  0003e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00042	5b		 pop	 rbx
  00043	c3		 ret	 0
?GetPixelFormat@Image@Gdiplus@@QEAAHXZ ENDP		; Gdiplus::Image::GetPixelFormat
_TEXT	ENDS
PUBLIC	__$ArrayPad$
;	COMDAT pdata
; File c:\program files\microsoft sdks\windows\v6.0a\include\gdiplusheaders.h
pdata	SEGMENT
$pdata$?GetHeight@Image@Gdiplus@@QEAAIXZ DD imagerel $LN7
	DD	imagerel $LN7+73
	DD	imagerel $unwind$?GetHeight@Image@Gdiplus@@QEAAIXZ
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetHeight@Image@Gdiplus@@QEAAIXZ DD 021519H
	DD	030025206H
	DD	imagerel __GSHandlerCheck
	DD	028H
; Function compile flags: /Ogspy
; File c:\program files\microsoft sdks\windows\v6.0a\include\gdiplusbitmap.h
xdata	ENDS
;	COMDAT ?GetHeight@Image@Gdiplus@@QEAAIXZ
_TEXT	SEGMENT
height$ = 32
__$ArrayPad$ = 40
this$ = 64
?GetHeight@Image@Gdiplus@@QEAAIXZ PROC			; Gdiplus::Image::GetHeight, COMDAT

; 235  : {

$LN7:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0000d	48 33 c4	 xor	 rax, rsp
  00010	48 89 44 24 28	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 236  :     UINT height = 0;

  00015	83 64 24 20 00	 and	 DWORD PTR height$[rsp], 0
  0001a	48 8b d9	 mov	 rbx, rcx

; 237  : 
; 238  :     SetStatus(DllExports::GdipGetImageHeight(nativeImage, &height));

  0001d	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00021	48 8d 54 24 20	 lea	 rdx, QWORD PTR height$[rsp]
  00026	e8 00 00 00 00	 call	 GdipGetImageHeight
  0002b	85 c0		 test	 eax, eax
  0002d	74 03		 je	 SHORT $LN4@GetHeight
  0002f	89 43 10	 mov	 DWORD PTR [rbx+16], eax
$LN4@GetHeight:

; 239  : 
; 240  :     return height;

  00032	8b 44 24 20	 mov	 eax, DWORD PTR height$[rsp]

; 241  : }

  00036	48 8b 4c 24 28	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0003b	48 33 cc	 xor	 rcx, rsp
  0003e	e8 00 00 00 00	 call	 __security_check_cookie
  00043	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00047	5b		 pop	 rbx
  00048	c3		 ret	 0
?GetHeight@Image@Gdiplus@@QEAAIXZ ENDP			; Gdiplus::Image::GetHeight
_TEXT	ENDS
PUBLIC	__$ArrayPad$
;	COMDAT pdata
; File c:\program files\microsoft sdks\windows\v6.0a\include\gdiplusheaders.h
pdata	SEGMENT
$pdata$?GetWidth@Image@Gdiplus@@QEAAIXZ DD imagerel $LN7
	DD	imagerel $LN7+73
	DD	imagerel $unwind$?GetWidth@Image@Gdiplus@@QEAAIXZ
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetWidth@Image@Gdiplus@@QEAAIXZ DD 021519H
	DD	030025206H
	DD	imagerel __GSHandlerCheck
	DD	028H
; Function compile flags: /Ogspy
; File c:\program files\microsoft sdks\windows\v6.0a\include\gdiplusbitmap.h
xdata	ENDS
;	COMDAT ?GetWidth@Image@Gdiplus@@QEAAIXZ
_TEXT	SEGMENT
width$ = 32
__$ArrayPad$ = 40
this$ = 64
?GetWidth@Image@Gdiplus@@QEAAIXZ PROC			; Gdiplus::Image::GetWidth, COMDAT

; 225  : {

$LN7:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0000d	48 33 c4	 xor	 rax, rsp
  00010	48 89 44 24 28	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 226  :     UINT width = 0;

  00015	83 64 24 20 00	 and	 DWORD PTR width$[rsp], 0
  0001a	48 8b d9	 mov	 rbx, rcx

; 227  : 
; 228  :     SetStatus(DllExports::GdipGetImageWidth(nativeImage, &width));

  0001d	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00021	48 8d 54 24 20	 lea	 rdx, QWORD PTR width$[rsp]
  00026	e8 00 00 00 00	 call	 GdipGetImageWidth
  0002b	85 c0		 test	 eax, eax
  0002d	74 03		 je	 SHORT $LN4@GetWidth
  0002f	89 43 10	 mov	 DWORD PTR [rbx+16], eax
$LN4@GetWidth:

; 229  : 
; 230  :     return width;

  00032	8b 44 24 20	 mov	 eax, DWORD PTR width$[rsp]

; 231  : }

  00036	48 8b 4c 24 28	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0003b	48 33 cc	 xor	 rcx, rsp
  0003e	e8 00 00 00 00	 call	 __security_check_cookie
  00043	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00047	5b		 pop	 rbx
  00048	c3		 ret	 0
?GetWidth@Image@Gdiplus@@QEAAIXZ ENDP			; Gdiplus::Image::GetWidth
_TEXT	ENDS
PUBLIC	__$ArrayPad$
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Clone@Image@Gdiplus@@UEAAPEAV12@XZ DD imagerel $LN15
	DD	imagerel $LN15+114
	DD	imagerel $unwind$?Clone@Image@Gdiplus@@UEAAPEAV12@XZ
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Clone@Image@Gdiplus@@UEAAPEAV12@XZ DD 021519H
	DD	030025206H
	DD	imagerel __GSHandlerCheck
	DD	028H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT ?Clone@Image@Gdiplus@@UEAAPEAV12@XZ
_TEXT	SEGMENT
cloneimage$ = 32
__$ArrayPad$ = 40
this$ = 64
?Clone@Image@Gdiplus@@UEAAPEAV12@XZ PROC		; Gdiplus::Image::Clone, COMDAT

; 96   : {

$LN15:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0000d	48 33 c4	 xor	 rax, rsp
  00010	48 89 44 24 28	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 97   :     GpImage *cloneimage = NULL;

  00015	48 83 64 24 20
	00		 and	 QWORD PTR cloneimage$[rsp], 0
  0001b	48 8b d9	 mov	 rbx, rcx

; 98   : 
; 99   :     SetStatus(DllExports::GdipCloneImage(nativeImage, &cloneimage));

  0001e	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00022	48 8d 54 24 20	 lea	 rdx, QWORD PTR cloneimage$[rsp]
  00027	e8 00 00 00 00	 call	 GdipCloneImage
  0002c	85 c0		 test	 eax, eax
  0002e	74 03		 je	 SHORT $LN6@Clone@3
  00030	89 43 10	 mov	 DWORD PTR [rbx+16], eax
$LN6@Clone@3:

; 100  : 
; 101  :     return new Image(cloneimage, lastResult);

  00033	b9 18 00 00 00	 mov	 ecx, 24
  00038	e8 00 00 00 00	 call	 GdipAlloc
  0003d	48 85 c0	 test	 rax, rax
  00040	74 1b		 je	 SHORT $LN3@Clone@3
  00042	8b 53 10	 mov	 edx, DWORD PTR [rbx+16]
  00045	48 8b 4c 24 20	 mov	 rcx, QWORD PTR cloneimage$[rsp]
  0004a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_7Image@Gdiplus@@6B@
  00051	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  00055	89 50 10	 mov	 DWORD PTR [rax+16], edx
  00058	4c 89 00	 mov	 QWORD PTR [rax], r8
  0005b	eb 02		 jmp	 SHORT $LN4@Clone@3
$LN3@Clone@3:
  0005d	33 c0		 xor	 eax, eax
$LN4@Clone@3:

; 102  : }

  0005f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00064	48 33 cc	 xor	 rcx, rsp
  00067	e8 00 00 00 00	 call	 __security_check_cookie
  0006c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00070	5b		 pop	 rbx
  00071	c3		 ret	 0
?Clone@Image@Gdiplus@@UEAAPEAV12@XZ ENDP		; Gdiplus::Image::Clone
_TEXT	ENDS
;	COMDAT pdata
; File c:\program files\microsoft sdks\windows\v6.0a\include\gdiplusgraphics.h
pdata	SEGMENT
$pdata$?Clear@Graphics@Gdiplus@@QEAA?AW4Status@2@AEBVColor@2@@Z DD imagerel $LN9
	DD	imagerel $LN9+36
	DD	imagerel $unwind$?Clear@Graphics@Gdiplus@@QEAA?AW4Status@2@AEBVColor@2@@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Clear@Graphics@Gdiplus@@QEAA?AW4Status@2@AEBVColor@2@@Z DD 020601H
	DD	030023206H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT ?Clear@Graphics@Gdiplus@@QEAA?AW4Status@2@AEBVColor@2@@Z
_TEXT	SEGMENT
this$ = 48
color$ = 56
?Clear@Graphics@Gdiplus@@QEAA?AW4Status@2@AEBVColor@2@@Z PROC ; Gdiplus::Graphics::Clear, COMDAT

; 943  :     {

$LN9:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 944  :         return SetStatus(DllExports::GdipGraphicsClear(
; 945  :             nativeGraphics,
; 946  :             color.GetValue()));

  00006	8b 12		 mov	 edx, DWORD PTR [rdx]
  00008	48 8b d9	 mov	 rbx, rcx
  0000b	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0000e	e8 00 00 00 00	 call	 GdipGraphicsClear
  00013	85 c0		 test	 eax, eax
  00015	74 05		 je	 SHORT $LN6@Clear
  00017	89 43 08	 mov	 DWORD PTR [rbx+8], eax
  0001a	eb 02		 jmp	 SHORT $LN5@Clear
$LN6@Clear:
  0001c	33 c0		 xor	 eax, eax
$LN5@Clear:

; 947  :     }

  0001e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00022	5b		 pop	 rbx
  00023	c3		 ret	 0
?Clear@Graphics@Gdiplus@@QEAA?AW4Status@2@AEBVColor@2@@Z ENDP ; Gdiplus::Graphics::Clear
_TEXT	ENDS
PUBLIC	__$ArrayPad$
;	COMDAT pdata
pdata	SEGMENT
$pdata$?FromImage@Graphics@Gdiplus@@SAPEAV12@PEAVImage@2@@Z DD imagerel $LN12
	DD	imagerel $LN12+115
	DD	imagerel $unwind$?FromImage@Graphics@Gdiplus@@SAPEAV12@PEAVImage@2@@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?FromImage@Graphics@Gdiplus@@SAPEAV12@PEAVImage@2@@Z DD 041919H
	DD	09340aH
	DD	07006520aH
	DD	imagerel __GSHandlerCheck
	DD	028H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT ?FromImage@Graphics@Gdiplus@@SAPEAV12@PEAVImage@2@@Z
_TEXT	SEGMENT
graphics$112552 = 32
__$ArrayPad$ = 40
image$ = 64
?FromImage@Graphics@Gdiplus@@SAPEAV12@PEAVImage@2@@Z PROC ; Gdiplus::Graphics::FromImage, COMDAT

; 49   :     {

$LN12:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00011	48 33 c4	 xor	 rax, rsp
  00014	48 89 44 24 28	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00019	48 8b f9	 mov	 rdi, rcx

; 50   :         return new Graphics(image);

  0001c	b9 10 00 00 00	 mov	 ecx, 16
  00021	e8 00 00 00 00	 call	 GdipAlloc
  00026	33 d2		 xor	 edx, edx
  00028	48 8b d8	 mov	 rbx, rax
  0002b	48 3b c2	 cmp	 rax, rdx
  0002e	74 25		 je	 SHORT $LN3@FromImage
  00030	48 89 54 24 20	 mov	 QWORD PTR graphics$112552[rsp], rdx
  00035	48 3b fa	 cmp	 rdi, rdx
  00038	74 16		 je	 SHORT $LN7@FromImage
  0003a	48 8b 4f 08	 mov	 rcx, QWORD PTR [rdi+8]
  0003e	48 8d 54 24 20	 lea	 rdx, QWORD PTR graphics$112552[rsp]
  00043	e8 00 00 00 00	 call	 GdipGetImageGraphicsContext
  00048	48 8b 54 24 20	 mov	 rdx, QWORD PTR graphics$112552[rsp]
  0004d	89 43 08	 mov	 DWORD PTR [rbx+8], eax
$LN7@FromImage:
  00050	48 89 13	 mov	 QWORD PTR [rbx], rdx
  00053	eb 03		 jmp	 SHORT $LN4@FromImage
$LN3@FromImage:
  00055	48 8b da	 mov	 rbx, rdx
$LN4@FromImage:
  00058	48 8b c3	 mov	 rax, rbx

; 51   :     }

  0005b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00060	48 33 cc	 xor	 rcx, rsp
  00063	e8 00 00 00 00	 call	 __security_check_cookie
  00068	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  0006d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00071	5f		 pop	 rdi
  00072	c3		 ret	 0
?FromImage@Graphics@Gdiplus@@SAPEAV12@PEAVImage@2@@Z ENDP ; Gdiplus::Graphics::FromImage
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GImage@Gdiplus@@UEAAPEAXI@Z DD imagerel $LN8
	DD	imagerel $LN8+61
	DD	imagerel $unwind$??_GImage@Gdiplus@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GImage@Gdiplus@@UEAAPEAXI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT ??_GImage@Gdiplus@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_GImage@Gdiplus@@UEAAPEAXI@Z PROC			; Gdiplus::Image::`scalar deleting destructor', COMDAT
$LN8:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7Image@Gdiplus@@6B@
  00011	48 8b f9	 mov	 rdi, rcx
  00014	8b da		 mov	 ebx, edx
  00016	48 89 01	 mov	 QWORD PTR [rcx], rax
  00019	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0001d	e8 00 00 00 00	 call	 GdipDisposeImage
  00022	f6 c3 01	 test	 bl, 1
  00025	74 08		 je	 SHORT $LN6@scalar@2
  00027	48 8b cf	 mov	 rcx, rdi
  0002a	e8 00 00 00 00	 call	 GdipFree
$LN6@scalar@2:
  0002f	48 8b c7	 mov	 rax, rdi
  00032	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00037	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003b	5f		 pop	 rdi
  0003c	c3		 ret	 0
??_GImage@Gdiplus@@UEAAPEAXI@Z ENDP			; Gdiplus::Image::`scalar deleting destructor'
; Function compile flags: /Odspy
;	COMDAT ?Release@CPdnShellExtension@@W7EAAKXZ
_TEXT	SEGMENT
?Release@CPdnShellExtension@@W7EAAKXZ PROC		; [thunk]:CPdnShellExtension::Release`adjustor{8}', COMDAT
  00000	48 83 e9 08	 sub	 rcx, 8
  00004	e9 00 00 00 00	 jmp	 ?Release@CPdnShellExtension@@UEAAKXZ ; CPdnShellExtension::Release
?Release@CPdnShellExtension@@W7EAAKXZ ENDP		; [thunk]:CPdnShellExtension::Release`adjustor{8}'
; Function compile flags: /Odspy
_TEXT	ENDS
;	COMDAT ?QueryInterface@CPdnShellExtension@@W7EAAJAEBU_GUID@@PEAPEAX@Z
_TEXT	SEGMENT
?QueryInterface@CPdnShellExtension@@W7EAAJAEBU_GUID@@PEAPEAX@Z PROC ; [thunk]:CPdnShellExtension::QueryInterface`adjustor{8}', COMDAT
  00000	48 83 e9 08	 sub	 rcx, 8
  00004	e9 00 00 00 00	 jmp	 ?QueryInterface@CPdnShellExtension@@UEAAJAEBU_GUID@@PEAPEAX@Z ; CPdnShellExtension::QueryInterface
?QueryInterface@CPdnShellExtension@@W7EAAJAEBU_GUID@@PEAPEAX@Z ENDP ; [thunk]:CPdnShellExtension::QueryInterface`adjustor{8}'
_TEXT	ENDS
PUBLIC	__$ArrayPad$
;	COMDAT pdata
; File c:\program files\microsoft sdks\windows\v6.0a\include\gdiplusbitmap.h
pdata	SEGMENT
$pdata$?FromStream@Bitmap@Gdiplus@@SAPEAV12@PEAUIStream@@H@Z DD imagerel $LN15
	DD	imagerel $LN15+118
	DD	imagerel $unwind$?FromStream@Bitmap@Gdiplus@@SAPEAV12@PEAUIStream@@H@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?FromStream@Bitmap@Gdiplus@@SAPEAV12@PEAUIStream@@H@Z DD 041919H
	DD	09340aH
	DD	07006520aH
	DD	imagerel __GSHandlerCheck
	DD	028H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT ?FromStream@Bitmap@Gdiplus@@SAPEAV12@PEAUIStream@@H@Z
_TEXT	SEGMENT
bitmap$113065 = 32
__$ArrayPad$ = 40
stream$ = 64
useEmbeddedColorManagement$ = 72
?FromStream@Bitmap@Gdiplus@@SAPEAV12@PEAUIStream@@H@Z PROC ; Gdiplus::Bitmap::FromStream, COMDAT

; 716  : {

$LN15:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00011	48 33 c4	 xor	 rax, rsp
  00014	48 89 44 24 28	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00019	48 8b f9	 mov	 rdi, rcx

; 717  :     return new Bitmap(
; 718  :         stream, 
; 719  :         useEmbeddedColorManagement
; 720  :     );

  0001c	b9 18 00 00 00	 mov	 ecx, 24
  00021	e8 00 00 00 00	 call	 GdipAlloc
  00026	48 8b d8	 mov	 rbx, rax
  00029	48 85 c0	 test	 rax, rax
  0002c	74 2b		 je	 SHORT $LN3@FromStream
  0002e	48 83 64 24 20
	00		 and	 QWORD PTR bitmap$113065[rsp], 0
  00034	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7Bitmap@Gdiplus@@6B@
  0003b	48 8d 54 24 20	 lea	 rdx, QWORD PTR bitmap$113065[rsp]
  00040	48 8b cf	 mov	 rcx, rdi
  00043	48 89 03	 mov	 QWORD PTR [rbx], rax
  00046	e8 00 00 00 00	 call	 GdipCreateBitmapFromStream
  0004b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR bitmap$113065[rsp]
  00050	48 89 4b 08	 mov	 QWORD PTR [rbx+8], rcx
  00054	89 43 10	 mov	 DWORD PTR [rbx+16], eax
  00057	eb 02		 jmp	 SHORT $LN4@FromStream
$LN3@FromStream:
  00059	33 db		 xor	 ebx, ebx
$LN4@FromStream:
  0005b	48 8b c3	 mov	 rax, rbx

; 721  : }

  0005e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00063	48 33 cc	 xor	 rcx, rsp
  00066	e8 00 00 00 00	 call	 __security_check_cookie
  0006b	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00070	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00074	5f		 pop	 rdi
  00075	c3		 ret	 0
?FromStream@Bitmap@Gdiplus@@SAPEAV12@PEAUIStream@@H@Z ENDP ; Gdiplus::Bitmap::FromStream
PUBLIC	__$ArrayPad$
;	COMDAT pdata
; File c:\program files\microsoft sdks\windows\v6.0a\include\winerror.h
pdata	SEGMENT
$pdata$?Extract@CPdnShellExtension@@UEAAJPEAPEAUHBITMAP__@@@Z DD imagerel $LN377
	DD	imagerel $LN377+2610
	DD	imagerel $unwind$?Extract@CPdnShellExtension@@UEAAJPEAPEAUHBITMAP__@@@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Extract@CPdnShellExtension@@UEAAJPEAPEAUHBITMAP__@@@Z DD 0b2919H
	DD	0283417H
	DD	01e0117H
	DD	0e00ef010H
	DD	0c00ad00cH
	DD	060077008H
	DD	05006H
	DD	imagerel __GSHandlerCheck
	DD	0e0H
; Function compile flags: /Ogspy
; File e:\my_project\openpdn\openpdn-e28f1ff0077e\src\shellextension\pdnshellextension.cpp
xdata	ENDS
;	COMDAT ?Extract@CPdnShellExtension@@UEAAJPEAPEAUHBITMAP__@@@Z
_TEXT	SEGMENT
pMemoryStream$1$ = 112
pbImgBytes$1$ = 120
hFile$1$ = 128
phBmpImage$GSCopy$1$ = 136
height$113625 = 144
width$113552 = 144
graphics$113360 = 144
thumbSize$113294 = 144
bitmap$113250 = 144
status$107166 = 144
gpdstBitmap$113720 = 152
width$113518 = 152
height$113269 = 152
bIsVista$107203 = 152
nDestLen$107140 = 152
bLength$107024 = 160
format$113608 = 164
height$113501 = 164
width$113286 = 164
bMagic$ = 168
this$GSCopy$1$ = 176
width$113642 = 176
height$113535 = 176
bitmap$113331 = 176
pGdiToken$107162 = 184
hBitmap$107231 = 192
gdiplusStartupInput$107165 = 200
__$ArrayPad$ = 224
this$ = 304
phBmpImage$ = 312
?Extract@CPdnShellExtension@@UEAAJPEAPEAUHBITMAP__@@@Z PROC ; CPdnShellExtension::Extract, COMDAT

; 348  : {

$LN377:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	41 54		 push	 r12
  0000a	41 55		 push	 r13
  0000c	41 56		 push	 r14
  0000e	41 57		 push	 r15
  00010	48 81 ec f0 00
	00 00		 sub	 rsp, 240		; 000000f0H
  00017	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001e	48 33 c4	 xor	 rax, rsp
  00021	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 349  :     HRESULT hr = S_OK;

  00029	33 ff		 xor	 edi, edi
  0002b	48 89 8c 24 b0
	00 00 00	 mov	 QWORD PTR this$GSCopy$1$[rsp], rcx

; 350  :     DWORD dwError = ERROR_SUCCESS;
; 351  :     BOOL bResult = TRUE;
; 352  :     TraceEnter();
; 353  : 
; 354  :     // Open file
; 355  :     HANDLE hFile = INVALID_HANDLE_VALUE;
; 356  :     if (SUCCEEDED(hr))
; 357  :     {
; 358  :         LPCWSTR lpFileName = (LPCWSTR)m_bstrFileName;
; 359  :         DWORD dwDesiredAccess = GENERIC_READ;
; 360  :         DWORD dwShareMode = FILE_SHARE_READ;
; 361  :         LPSECURITY_ATTRIBUTES lpSecurityAttributes = NULL;
; 362  :         DWORD dwCreationDisposition = OPEN_EXISTING;
; 363  :         DWORD dwFlagsAndAttributes = FILE_FLAG_SEQUENTIAL_SCAN;
; 364  :         HANDLE hTemplateFile = NULL;
; 365  : 
; 366  :         hFile = CreateFileW(
; 367  :             lpFileName, 
; 368  :             dwDesiredAccess, 
; 369  :             dwShareMode, 
; 370  :             lpSecurityAttributes, 
; 371  :             dwCreationDisposition, 
; 372  :             dwFlagsAndAttributes, 
; 373  :             hTemplateFile);

  00033	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00037	48 21 7c 24 30	 and	 QWORD PTR [rsp+48], rdi
  0003c	48 89 94 24 88
	00 00 00	 mov	 QWORD PTR phBmpImage$GSCopy$1$[rsp], rdx
  00044	8d 5f 03	 lea	 ebx, QWORD PTR [rdi+3]
  00047	44 8d 47 01	 lea	 r8d, QWORD PTR [rdi+1]
  0004b	45 33 c9	 xor	 r9d, r9d
  0004e	ba 00 00 00 80	 mov	 edx, -2147483648	; 80000000H
  00053	c7 44 24 28 00
	00 00 08	 mov	 DWORD PTR [rsp+40], 134217728 ; 08000000H
  0005b	89 5c 24 20	 mov	 DWORD PTR [rsp+32], ebx
  0005f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateFileW

; 374  : 
; 375  :         if (INVALID_HANDLE_VALUE == hFile)

  00065	48 83 cd ff	 or	 rbp, -1
  00069	48 8b f0	 mov	 rsi, rax
  0006c	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR hFile$1$[rsp], rax
  00074	48 3b c5	 cmp	 rax, rbp
  00077	75 14		 jne	 SHORT $LN103@Extract

; 376  :         {
; 377  :             dwError = GetLastError();

  00079	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError

; 378  :             hr = HRESULT_FROM_WIN32(dwError);

  0007f	0f b7 f8	 movzx	 edi, ax
  00082	81 cf 00 00 07
	80		 or	 edi, -2147024896	; ffffffff80070000H
  00088	85 c0		 test	 eax, eax
  0008a	0f 4e f8	 cmovle	 edi, eax
$LN103@Extract:

; 379  :             TraceOut("CreateFile failed, hr=0x%x", hr);
; 380  :         }
; 381  :     }
; 382  : 
; 383  :     // Read magic numbers
; 384  :     BOOL bPdn3File = FALSE;
; 385  :     BYTE bMagic[4];
; 386  :     ZeroMemory(bMagic, sizeof(bMagic));

  0008d	33 c0		 xor	 eax, eax

; 387  : 
; 388  :     if (SUCCEEDED(hr))

  0008f	41 bc 05 40 00
	80		 mov	 r12d, -2147467259	; ffffffff80004005H
  00095	89 84 24 a8 00
	00 00		 mov	 DWORD PTR bMagic$[rsp], eax
  0009c	85 ff		 test	 edi, edi
  0009e	0f 88 4a 09 00
	00		 js	 $LN3@Extract

; 389  :     {
; 390  :         hr = ReadFileComplete(hFile, (LPVOID)bMagic, sizeof(bMagic));

  000a4	44 8d 40 04	 lea	 r8d, QWORD PTR [rax+4]
  000a8	48 8d 94 24 a8
	00 00 00	 lea	 rdx, QWORD PTR bMagic$[rsp]
  000b0	48 8b ce	 mov	 rcx, rsi
  000b3	e8 00 00 00 00	 call	 ?ReadFileComplete@@YAJPEAX0K@Z ; ReadFileComplete

; 391  :     }
; 392  : 
; 393  :     if (SUCCEEDED(hr))

  000b8	85 c0		 test	 eax, eax
  000ba	0f 88 2e 09 00
	00		 js	 $LN3@Extract

; 394  :     {
; 395  :         if ('P' == bMagic[0] &&
; 396  :             'D' == bMagic[1] &&
; 397  :             'N' == bMagic[2] &&
; 398  :             '3' == bMagic[3])

  000c0	80 bc 24 a8 00
	00 00 50	 cmp	 BYTE PTR bMagic$[rsp], 80 ; 00000050H
  000c8	0f 85 20 09 00
	00		 jne	 $LN3@Extract
  000ce	80 bc 24 a9 00
	00 00 44	 cmp	 BYTE PTR bMagic$[rsp+1], 68 ; 00000044H
  000d6	0f 85 12 09 00
	00		 jne	 $LN3@Extract
  000dc	80 bc 24 aa 00
	00 00 4e	 cmp	 BYTE PTR bMagic$[rsp+2], 78 ; 0000004eH
  000e4	0f 85 04 09 00
	00		 jne	 $LN3@Extract
  000ea	80 bc 24 ab 00
	00 00 33	 cmp	 BYTE PTR bMagic$[rsp+3], 51 ; 00000033H
  000f2	0f 85 f6 08 00
	00		 jne	 $LN3@Extract

; 399  :         {
; 400  :             bPdn3File = TRUE;
; 401  :         }
; 402  :     }
; 403  :     else
; 404  :     {
; 405  :         TraceOut("ReadFile(1) failed, hr=0x%x", hr);
; 406  :     }
; 407  : 
; 408  :     if (SUCCEEDED(hr) && bPdn3File)
; 409  :     {
; 410  :         TraceOut("we have a pdn3 file");
; 411  : 
; 412  :         TraceOut("Read + decode length");
; 413  : 
; 414  :         int iLength = -1;
; 415  :         BYTE bLength[3];
; 416  :         ZeroMemory(bLength, sizeof(bLength));

  000f8	33 c0		 xor	 eax, eax

; 417  : 
; 418  :         if (SUCCEEDED(hr))
; 419  :         {
; 420  :             hr = ReadFileComplete(hFile, (LPVOID)bLength, sizeof(bLength));

  000fa	48 8d 94 24 a0
	00 00 00	 lea	 rdx, QWORD PTR bLength$107024[rsp]
  00102	44 8b c3	 mov	 r8d, ebx
  00105	48 8b ce	 mov	 rcx, rsi
  00108	8b fd		 mov	 edi, ebp
  0010a	66 89 84 24 a0
	00 00 00	 mov	 WORD PTR bLength$107024[rsp], ax
  00112	88 84 24 a2 00
	00 00		 mov	 BYTE PTR bLength$107024[rsp+2], al
  00119	e8 00 00 00 00	 call	 ?ReadFileComplete@@YAJPEAX0K@Z ; ReadFileComplete
  0011e	8b d8		 mov	 ebx, eax

; 421  :         }
; 422  : 
; 423  :         if (SUCCEEDED(hr))

  00120	85 c0		 test	 eax, eax
  00122	78 22		 js	 SHORT $LN93@Extract

; 424  :         {
; 425  :             iLength = bLength[0] + (bLength[1] << 8) + (bLength[2] << 16);

  00124	0f b6 8c 24 a1
	00 00 00	 movzx	 ecx, BYTE PTR bLength$107024[rsp+1]
  0012c	0f b6 bc 24 a2
	00 00 00	 movzx	 edi, BYTE PTR bLength$107024[rsp+2]
  00134	c1 e7 08	 shl	 edi, 8
  00137	03 f9		 add	 edi, ecx
  00139	0f b6 8c 24 a0
	00 00 00	 movzx	 ecx, BYTE PTR bLength$107024[rsp]
  00141	c1 e7 08	 shl	 edi, 8
  00144	03 f9		 add	 edi, ecx
$LN93@Extract:

; 426  :         }
; 427  :         else
; 428  :         {
; 429  :             TraceOut("ReadFile(2) failed, hr=0x%x", hr);
; 430  :         }
; 431  : 
; 432  :         TraceOut("Allocate buffer");
; 433  :         BYTE *pbHeaderBytes = NULL;

  00146	45 33 ff	 xor	 r15d, r15d

; 434  : 
; 435  :         if (SUCCEEDED(hr))

  00149	41 bc 0e 00 07
	80		 mov	 r12d, -2147024882	; ffffffff8007000eH
  0014f	85 c0		 test	 eax, eax
  00151	78 38		 js	 SHORT $LN84@Extract

; 436  :         {
; 437  :             pbHeaderBytes = new BYTE[1 + iLength];

  00153	8d 47 01	 lea	 eax, DWORD PTR [rdi+1]
  00156	48 63 d8	 movsxd	 rbx, eax
  00159	48 8b cb	 mov	 rcx, rbx
  0015c	e8 00 00 00 00	 call	 ??_U@YAPEAX_K@Z		; operator new[]
  00161	4c 8b f8	 mov	 r15, rax

; 438  : 
; 439  :             if (NULL == pbHeaderBytes)

  00164	48 85 c0	 test	 rax, rax
  00167	75 05		 jne	 SHORT $LN88@Extract

; 440  :             {
; 441  :                 hr = E_OUTOFMEMORY;

  00169	41 8b dc	 mov	 ebx, r12d

; 442  :                 TraceOut("pbHeaderBytes alloc failed");
; 443  :             }
; 444  :             else

  0016c	eb 1d		 jmp	 SHORT $LN84@Extract
$LN88@Extract:

; 445  :             {
; 446  :                 ZeroMemory(pbHeaderBytes, 1 + iLength);

  0016e	4c 8b c3	 mov	 r8, rbx
  00171	33 d2		 xor	 edx, edx
  00173	48 8b c8	 mov	 rcx, rax
  00176	e8 00 00 00 00	 call	 memset

; 447  :             }
; 448  :         }
; 449  : 
; 450  :         TraceOut("Read N bytes");
; 451  :         if (SUCCEEDED(hr))
; 452  :         {
; 453  :             hr = ReadFileComplete(hFile, (LPVOID)pbHeaderBytes, iLength);

  0017b	44 8b c7	 mov	 r8d, edi
  0017e	49 8b d7	 mov	 rdx, r15
  00181	48 8b ce	 mov	 rcx, rsi
  00184	e8 00 00 00 00	 call	 ?ReadFileComplete@@YAJPEAX0K@Z ; ReadFileComplete
  00189	8b d8		 mov	 ebx, eax
$LN84@Extract:

; 454  :         }
; 455  : 
; 456  :         if (FAILED(hr))
; 457  :         {
; 458  :             TraceOut("ReadFile(3) failed, hr=0x%x", hr);
; 459  :         }
; 460  : 
; 461  :         TraceOut("Convert to UTF8 string");
; 462  :         CHAR *szHeader = (CHAR *)pbHeaderBytes;
; 463  : 
; 464  :         TraceOut("Search for \"<thumb\"");
; 465  :         const CHAR *szThumbTag = "<thumb ";
; 466  :         __int64 iThumbTagIndex = -1;
; 467  : 
; 468  :         if (SUCCEEDED(hr))

  0018b	4c 8d 2d 00 00
	00 00		 lea	 r13, OFFSET FLAT:??_C@_07JCJGGECG@?$DMthumb?5?$AA@
  00192	41 bc ff ff 00
	80		 mov	 r12d, -2147418113	; ffffffff8000ffffH
  00198	85 db		 test	 ebx, ebx
  0019a	78 1b		 js	 SHORT $LN76@Extract

; 469  :         {
; 470  :             CHAR *szFoundHere = strstr(szHeader, szThumbTag);

  0019c	49 8b d5	 mov	 rdx, r13
  0019f	49 8b cf	 mov	 rcx, r15
  001a2	e8 00 00 00 00	 call	 strstr

; 471  : 
; 472  :             if (NULL == szFoundHere)

  001a7	48 85 c0	 test	 rax, rax
  001aa	75 05		 jne	 SHORT $LN78@Extract

; 473  :             {
; 474  :                 TraceOut("Did not find opening tag, \"%s\"", szThumbTag);
; 475  :                 hr = E_UNEXPECTED;

  001ac	41 8b dc	 mov	 ebx, r12d

; 476  :             }
; 477  :             else

  001af	eb 06		 jmp	 SHORT $LN76@Extract
$LN78@Extract:

; 478  :             {
; 479  :                 iThumbTagIndex = szFoundHere - szHeader;

  001b1	48 8b e8	 mov	 rbp, rax
  001b4	49 2b ef	 sub	 rbp, r15
$LN76@Extract:

; 480  :             }
; 481  :         }
; 482  : 
; 483  :         TraceOut("Search for \"png=\" or \"gif=\"");
; 484  :         const char *szPngTag = "png=\"";
; 485  :         const char *szGifTag = "gif=\"";
; 486  :         const char *szImgTag = NULL; // the tag that we found

  001b7	45 33 f6	 xor	 r14d, r14d

; 487  : 
; 488  :         __int64 iImgTagIndex = -1;

  001ba	48 83 ce ff	 or	 rsi, -1

; 489  :         if (SUCCEEDED(hr))

  001be	85 db		 test	 ebx, ebx
  001c0	78 67		 js	 SHORT $LN68@Extract

; 490  :         {
; 491  :             CHAR *szPngFoundHere = strstr(szHeader + iThumbTagIndex + strlen(szThumbTag), szPngTag);

  001c2	48 0b ce	 or	 rcx, rsi
  001c5	33 c0		 xor	 eax, eax
  001c7	49 8b fd	 mov	 rdi, r13
  001ca	f2 ae		 repne scasb
  001cc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05EOONGFOI@png?$DN?$CC?$AA@
  001d3	48 f7 d1	 not	 rcx
  001d6	48 ff c9	 dec	 rcx
  001d9	48 03 cd	 add	 rcx, rbp
  001dc	49 03 cf	 add	 rcx, r15
  001df	e8 00 00 00 00	 call	 strstr

; 492  : 
; 493  :             if (NULL == szPngFoundHere)

  001e4	48 85 c0	 test	 rax, rax
  001e7	75 33		 jne	 SHORT $LN73@Extract

; 494  :             {
; 495  :                 TraceOut("Did not find png tag, \"%s\"", szPngTag);
; 496  : 
; 497  :                 CHAR *szGifFoundHere = strstr(szHeader + iThumbTagIndex + strlen(szThumbTag), szGifTag);

  001e9	48 0b ce	 or	 rcx, rsi
  001ec	49 8b fd	 mov	 rdi, r13
  001ef	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05FKKCOMLO@gif?$DN?$CC?$AA@
  001f6	f2 ae		 repne scasb
  001f8	48 f7 d1	 not	 rcx
  001fb	48 ff c9	 dec	 rcx
  001fe	48 03 cd	 add	 rcx, rbp
  00201	49 03 cf	 add	 rcx, r15
  00204	e8 00 00 00 00	 call	 strstr

; 498  : 
; 499  :                 if (NULL == szGifFoundHere)

  00209	48 85 c0	 test	 rax, rax
  0020c	75 05		 jne	 SHORT $LN71@Extract

; 500  :                 {
; 501  :                     TraceOut("Did not find gif tag, \"%s\"", szGifTag);
; 502  :                     hr = E_UNEXPECTED;

  0020e	41 8b dc	 mov	 ebx, r12d

; 503  :                 }
; 504  :                 else

  00211	eb 16		 jmp	 SHORT $LN68@Extract
$LN71@Extract:

; 505  :                 {
; 506  :                     szImgTag = szGifTag;

  00213	4c 8d 35 00 00
	00 00		 lea	 r14, OFFSET FLAT:??_C@_05FKKCOMLO@gif?$DN?$CC?$AA@

; 507  :                     iImgTagIndex = szGifFoundHere - szHeader;
; 508  :                 }
; 509  :             }
; 510  :             else

  0021a	eb 07		 jmp	 SHORT $LN372@Extract
$LN73@Extract:

; 511  :             {
; 512  :                 szImgTag = szPngTag;

  0021c	4c 8d 35 00 00
	00 00		 lea	 r14, OFFSET FLAT:??_C@_05EOONGFOI@png?$DN?$CC?$AA@
$LN372@Extract:

; 513  :                 iImgTagIndex = szPngFoundHere - szHeader;

  00223	48 8b f0	 mov	 rsi, rax
  00226	49 2b f7	 sub	 rsi, r15
$LN68@Extract:

; 514  :             }
; 515  :         }
; 516  : 
; 517  :         TraceOut("Search for \"");
; 518  :         const char *szQuoteEnd = "\"";
; 519  :         __int64 iQuoteEndIndex = -1;

  00229	49 83 cd ff	 or	 r13, -1

; 520  :         if (SUCCEEDED(hr))

  0022d	85 db		 test	 ebx, ebx
  0022f	78 32		 js	 SHORT $LN63@Extract

; 521  :         {
; 522  :             CHAR *szFoundHere = strstr(szHeader + iImgTagIndex + strlen(szImgTag), szQuoteEnd);

  00231	49 0b cd	 or	 rcx, r13
  00234	33 c0		 xor	 eax, eax
  00236	49 8b fe	 mov	 rdi, r14
  00239	f2 ae		 repne scasb
  0023b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01BJJEKLCA@?$CC?$AA@
  00242	48 f7 d1	 not	 rcx
  00245	48 ff c9	 dec	 rcx
  00248	48 03 ce	 add	 rcx, rsi
  0024b	49 03 cf	 add	 rcx, r15
  0024e	e8 00 00 00 00	 call	 strstr

; 523  : 
; 524  :             if (NULL == szFoundHere)

  00253	48 85 c0	 test	 rax, rax
  00256	75 05		 jne	 SHORT $LN65@Extract

; 525  :             {
; 526  :                 TraceOut("Did not find closing quote, \"%s\"", szQuoteEnd);
; 527  :                 hr = E_UNEXPECTED;

  00258	41 8b dc	 mov	 ebx, r12d

; 528  :             }
; 529  :             else

  0025b	eb 06		 jmp	 SHORT $LN63@Extract
$LN65@Extract:

; 530  :             {
; 531  :                 iQuoteEndIndex = szFoundHere - szHeader;

  0025d	4c 8b e8	 mov	 r13, rax
  00260	4d 2b ef	 sub	 r13, r15
$LN63@Extract:

; 532  :             }
; 533  :         }
; 534  : 
; 535  :         TraceOut("Stomp out the portion of the string that is the image in base64 format");
; 536  :         CHAR *szImgBase64 = NULL;

  00263	33 ed		 xor	 ebp, ebp

; 537  :         int iImgBase64Len = -1;

  00265	41 83 cc ff	 or	 r12d, -1

; 538  :         if (SUCCEEDED(hr))

  00269	85 db		 test	 ebx, ebx
  0026b	78 37		 js	 SHORT $LN368@Extract

; 539  :         {
; 540  :             szImgBase64 = szHeader + iImgTagIndex + strlen(szImgTag);

  0026d	48 83 c9 ff	 or	 rcx, -1
  00271	8d 55 01	 lea	 edx, QWORD PTR [rbp+1]
  00274	33 c0		 xor	 eax, eax
  00276	49 8b fe	 mov	 rdi, r14

; 541  :             szHeader[iQuoteEndIndex] = '\0';

  00279	45 33 f6	 xor	 r14d, r14d
  0027c	f2 ae		 repne scasb
  0027e	47 88 74 3d 00	 mov	 BYTE PTR [r13+r15], r14b
  00283	48 f7 d1	 not	 rcx
  00286	48 2b ca	 sub	 rcx, rdx
  00289	48 8d 2c 0e	 lea	 rbp, QWORD PTR [rsi+rcx]

; 542  :             iImgBase64Len = (int)strlen(szImgBase64);

  0028d	48 83 c9 ff	 or	 rcx, -1
  00291	49 03 ef	 add	 rbp, r15
  00294	48 8b fd	 mov	 rdi, rbp
  00297	f2 ae		 repne scasb
  00299	48 f7 d1	 not	 rcx
  0029c	48 2b ca	 sub	 rcx, rdx
  0029f	4c 8b e1	 mov	 r12, rcx
  002a2	eb 03		 jmp	 SHORT $LN60@Extract
$LN368@Extract:

; 749  :         {
; 750  :             *phBmpImage = hBitmap;

  002a4	45 33 f6	 xor	 r14d, r14d
$LN60@Extract:

; 543  :             TraceOut("iImgBase64Len=%d", iImgBase64Len);
; 544  :         }
; 545  : 
; 546  :         TraceOut("Get required length of byte[] array for base64->byte[] conversion");
; 547  :         int nImgBytes = -1;
; 548  :         if (SUCCEEDED(hr))

  002a7	83 c8 ff	 or	 eax, -1
  002aa	41 3b de	 cmp	 ebx, r14d

; 549  :         {
; 550  :             nImgBytes = Base64DecodeGetRequiredLength(iImgBase64Len);
; 551  :             TraceOut("nImgBytes=%d", nImgBytes);
; 552  :         }
; 553  : 
; 554  :         TraceOut("Allocate %d byte buffer for base64->byte[] conversion", nImgBytes);
; 555  :         BYTE *pbImgBytes = NULL;

  002ad	4d 8b ee	 mov	 r13, r14
  002b0	41 0f 4d c4	 cmovge	 eax, r12d

; 556  :         if (SUCCEEDED(hr))

  002b4	41 3b de	 cmp	 ebx, r14d
  002b7	4c 89 74 24 78	 mov	 QWORD PTR pbImgBytes$1$[rsp], r14
  002bc	7c 2c		 jl	 SHORT $LN52@Extract

; 557  :         {
; 558  :             pbImgBytes = new BYTE[nImgBytes];

  002be	48 63 f8	 movsxd	 rdi, eax
  002c1	48 8b cf	 mov	 rcx, rdi
  002c4	e8 00 00 00 00	 call	 ??_U@YAPEAX_K@Z		; operator new[]
  002c9	4c 8b e8	 mov	 r13, rax
  002cc	48 89 44 24 78	 mov	 QWORD PTR pbImgBytes$1$[rsp], rax

; 559  : 
; 560  :             if (NULL == pbImgBytes)

  002d1	49 3b c6	 cmp	 rax, r14
  002d4	75 07		 jne	 SHORT $LN54@Extract

; 561  :             {
; 562  :                 hr = E_OUTOFMEMORY;

  002d6	bb 0e 00 07 80	 mov	 ebx, -2147024882	; ffffffff8007000eH

; 563  :                 TraceOut("pbImgBytes alloc failed");
; 564  :             }
; 565  :             else

  002db	eb 0d		 jmp	 SHORT $LN52@Extract
$LN54@Extract:

; 566  :             {
; 567  :                 ZeroMemory(pbImgBytes, nImgBytes);

  002dd	4c 8b c7	 mov	 r8, rdi
  002e0	33 d2		 xor	 edx, edx
  002e2	48 8b c8	 mov	 rcx, rax
  002e5	e8 00 00 00 00	 call	 memset
$LN52@Extract:

; 568  :             }
; 569  :         }
; 570  : 
; 571  :         TraceOut("Convert from base64 to byte[]");
; 572  :         int iImgLen = -1;

  002ea	83 cf ff	 or	 edi, -1

; 573  :         if (SUCCEEDED(hr))

  002ed	41 3b de	 cmp	 ebx, r14d
  002f0	7c 3f		 jl	 SHORT $LN47@Extract

; 574  :         {
; 575  :             int nDestLen = iImgBase64Len;

  002f2	44 89 a4 24 98
	00 00 00	 mov	 DWORD PTR nDestLen$107140[rsp], r12d

; 576  : 
; 577  :             bResult = Base64Decode(szImgBase64, iImgBase64Len, pbImgBytes, &nDestLen);

  002fa	49 3b ee	 cmp	 rbp, r14
  002fd	74 20		 je	 SHORT $LN147@Extract
  002ff	4c 8d 8c 24 98
	00 00 00	 lea	 r9, QWORD PTR nDestLen$107140[rsp]
  00307	4d 8b c5	 mov	 r8, r13
  0030a	41 8b d4	 mov	 edx, r12d
  0030d	48 8b cd	 mov	 rcx, rbp
  00310	e8 00 00 00 00	 call	 ?Base64Decode@ATL@@YAHPEBDHPEAEPEAH@Z ; ATL::Base64Decode
  00315	44 8b a4 24 98
	00 00 00	 mov	 r12d, DWORD PTR nDestLen$107140[rsp]
  0031d	eb 03		 jmp	 SHORT $LN149@Extract
$LN147@Extract:
  0031f	41 8b c6	 mov	 eax, r14d
$LN149@Extract:

; 578  : 
; 579  :             if (!bResult)

  00322	41 3b c6	 cmp	 eax, r14d
  00325	75 07		 jne	 SHORT $LN49@Extract

; 580  :             {
; 581  :                 TraceOut("Base64Decode failed");
; 582  :                 hr = E_FAIL;

  00327	bb 05 40 00 80	 mov	 ebx, -2147467259	; ffffffff80004005H

; 583  :             }
; 584  :             else

  0032c	eb 03		 jmp	 SHORT $LN47@Extract
$LN49@Extract:

; 585  :             {
; 586  :                 iImgLen = nDestLen;

  0032e	41 8b fc	 mov	 edi, r12d
$LN47@Extract:

; 587  :             }
; 588  :         }
; 589  : 
; 590  :         TraceOut("iImgLen = %d", iImgLen);
; 591  :         TraceOut("Wrap a memory stream around it");
; 592  :         CMemoryStream *pMemoryStream = NULL;
; 593  :         if (SUCCEEDED(hr))

  00331	41 3b de	 cmp	 ebx, r14d
  00334	49 8b f6	 mov	 rsi, r14
  00337	4c 89 74 24 70	 mov	 QWORD PTR pMemoryStream$1$[rsp], r14
  0033c	7c 30		 jl	 SHORT $LN43@Extract

; 594  :         {
; 595  :             pMemoryStream = new CMemoryStream(pbImgBytes, iImgLen);

  0033e	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  00343	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00348	49 3b c6	 cmp	 rax, r14
  0034b	74 11		 je	 SHORT $LN109@Extract
  0034d	44 8b c7	 mov	 r8d, edi
  00350	49 8b d5	 mov	 rdx, r13
  00353	48 8b c8	 mov	 rcx, rax
  00356	e8 00 00 00 00	 call	 ??0CMemoryStream@@QEAA@PEAEH@Z ; CMemoryStream::CMemoryStream
  0035b	48 8b f0	 mov	 rsi, rax
$LN109@Extract:

; 596  : 
; 597  :             if (NULL == pMemoryStream)

  0035e	49 3b f6	 cmp	 rsi, r14
  00361	b8 0e 00 07 80	 mov	 eax, -2147024882	; ffffffff8007000eH
  00366	48 89 74 24 70	 mov	 QWORD PTR pMemoryStream$1$[rsp], rsi
  0036b	0f 44 d8	 cmove	 ebx, eax
$LN43@Extract:

; 598  :             {
; 599  :                 TraceOut("pMemoryStream alloc failed");
; 600  :                 hr = E_OUTOFMEMORY;
; 601  :             }
; 602  :         }
; 603  : 
; 604  :         TraceOut("Startup GDI+");
; 605  :         ULONG_PTR pGdiToken = NULL;
; 606  : 
; 607  :         if (SUCCEEDED(hr))

  0036e	41 3b de	 cmp	 ebx, r14d
  00371	4c 89 b4 24 b8
	00 00 00	 mov	 QWORD PTR pGdiToken$107162[rsp], r14
  00379	7c 5d		 jl	 SHORT $LN370@Extract

; 608  :         {
; 609  :             GdiplusStartupInput gdiplusStartupInput;
; 610  :             Status status;
; 611  :             
; 612  : 			hr = DoGdiplusStartup(&status, &pGdiToken, &gdiplusStartupInput);

  0037b	4c 8d 84 24 c8
	00 00 00	 lea	 r8, QWORD PTR gdiplusStartupInput$107165[rsp]
  00383	48 8d 94 24 b8
	00 00 00	 lea	 rdx, QWORD PTR pGdiToken$107162[rsp]
  0038b	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR status$107166[rsp]
  00393	c7 84 24 c8 00
	00 00 01 00 00
	00		 mov	 DWORD PTR gdiplusStartupInput$107165[rsp], 1
  0039e	4c 89 b4 24 d0
	00 00 00	 mov	 QWORD PTR gdiplusStartupInput$107165[rsp+8], r14
  003a6	44 89 b4 24 d8
	00 00 00	 mov	 DWORD PTR gdiplusStartupInput$107165[rsp+16], r14d
  003ae	44 89 b4 24 dc
	00 00 00	 mov	 DWORD PTR gdiplusStartupInput$107165[rsp+20], r14d
  003b6	e8 00 00 00 00	 call	 ?DoGdiplusStartup@@YAJPEAW4Status@Gdiplus@@PEA_KPEAUGdiplusStartupInput@2@@Z ; DoGdiplusStartup

; 613  : 
; 614  :             if (status != Ok)
; 615  :             {
; 616  :                 hr = E_FAIL;

  003bb	bf 05 40 00 80	 mov	 edi, -2147467259	; ffffffff80004005H
  003c0	8b d8		 mov	 ebx, eax
  003c2	44 39 b4 24 90
	00 00 00	 cmp	 DWORD PTR status$107166[rsp], r14d
  003ca	74 11		 je	 SHORT $LN365@Extract
  003cc	8b df		 mov	 ebx, edi

; 617  :                 pGdiToken = NULL;

  003ce	4c 89 b4 24 b8
	00 00 00	 mov	 QWORD PTR pGdiToken$107162[rsp], r14
  003d6	eb 05		 jmp	 SHORT $LN365@Extract
$LN370@Extract:

; 712  :                 {
; 713  :                     hr = E_OUTOFMEMORY;
; 714  :                 }
; 715  :             }
; 716  :         }
; 717  : 
; 718  :         if (NULL != pBitmap)
; 719  :         {
; 720  :             delete pBitmap;

  003d8	bf 05 40 00 80	 mov	 edi, -2147467259	; ffffffff80004005H
$LN365@Extract:

; 618  :                 TraceOut("GdiplusStartup failed");
; 619  :             }
; 620  :         }
; 621  : 
; 622  :         TraceOut("Load image");
; 623  :         Bitmap *pBitmap = NULL;        
; 624  :         if (SUCCEEDED(hr))

  003dd	41 3b de	 cmp	 ebx, r14d
  003e0	49 8b ee	 mov	 rbp, r14
  003e3	41 bd 18 00 00
	00		 mov	 r13d, 24
  003e9	4c 8d 25 00 00
	00 00		 lea	 r12, OFFSET FLAT:??_7Bitmap@Gdiplus@@6B@
  003f0	7c 45		 jl	 SHORT $LN34@Extract

; 625  :         {
; 626  :             pBitmap = Bitmap::FromStream(pMemoryStream, FALSE);

  003f2	49 8b cd	 mov	 rcx, r13
  003f5	e8 00 00 00 00	 call	 GdipAlloc
  003fa	48 8b e8	 mov	 rbp, rax
  003fd	49 3b c6	 cmp	 rax, r14
  00400	74 2c		 je	 SHORT $LN157@Extract
  00402	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR bitmap$113250[rsp]
  0040a	48 8b ce	 mov	 rcx, rsi
  0040d	4c 89 20	 mov	 QWORD PTR [rax], r12
  00410	4c 89 b4 24 90
	00 00 00	 mov	 QWORD PTR bitmap$113250[rsp], r14
  00418	e8 00 00 00 00	 call	 GdipCreateBitmapFromStream
  0041d	89 45 10	 mov	 DWORD PTR [rbp+16], eax
  00420	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR bitmap$113250[rsp]
  00428	48 89 45 08	 mov	 QWORD PTR [rbp+8], rax
  0042c	eb 03		 jmp	 SHORT $LN158@Extract
$LN157@Extract:
  0042e	49 8b ee	 mov	 rbp, r14
$LN158@Extract:

; 627  : 
; 628  :             if (NULL == pBitmap)

  00431	49 3b ee	 cmp	 rbp, r14
  00434	0f 44 df	 cmove	 ebx, edi
$LN34@Extract:

; 629  :             {
; 630  :                 hr = E_FAIL;
; 631  :                 TraceOut("Bitmap::FromStream returned NULL");
; 632  :             }
; 633  :         }
; 634  : 
; 635  :         Bitmap *pResizedBitmap = NULL;
; 636  :         if (SUCCEEDED(hr))

  00437	41 3b de	 cmp	 ebx, r14d
  0043a	49 8b fe	 mov	 rdi, r14
  0043d	0f 8c ca 04 00
	00		 jl	 $LN22@Extract

; 637  :         {
; 638  :             if (m_size.cx > 0 && m_size.cy > 0)

  00443	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR this$GSCopy$1$[rsp]
  0044b	8b 41 18	 mov	 eax, DWORD PTR [rcx+24]
  0044e	41 3b c6	 cmp	 eax, r14d
  00451	0f 8e bb 03 00
	00		 jle	 $LN32@Extract
  00457	8b 71 1c	 mov	 esi, DWORD PTR [rcx+28]
  0045a	41 3b f6	 cmp	 esi, r14d
  0045d	0f 8e af 03 00
	00		 jle	 $LN32@Extract

; 639  :             {
; 640  :                 UINT nMaxEdge = min(m_size.cx, m_size.cy);
; 641  :                 SIZE newSize = ComputeThumbnailSize(pBitmap->GetWidth(), pBitmap->GetHeight(), nMaxEdge);

  00463	48 8b 4d 08	 mov	 rcx, QWORD PTR [rbp+8]
  00467	3b c6		 cmp	 eax, esi
  00469	48 8d 94 24 98
	00 00 00	 lea	 rdx, QWORD PTR height$113269[rsp]
  00471	0f 4c f0	 cmovl	 esi, eax
  00474	44 89 b4 24 98
	00 00 00	 mov	 DWORD PTR height$113269[rsp], r14d
  0047c	e8 00 00 00 00	 call	 GdipGetImageHeight
  00481	41 3b c6	 cmp	 eax, r14d
  00484	74 03		 je	 SHORT $LN172@Extract
  00486	89 45 10	 mov	 DWORD PTR [rbp+16], eax
$LN172@Extract:
  00489	48 8b 4d 08	 mov	 rcx, QWORD PTR [rbp+8]
  0048d	44 8b a4 24 98
	00 00 00	 mov	 r12d, DWORD PTR height$113269[rsp]
  00495	48 8d 94 24 a4
	00 00 00	 lea	 rdx, QWORD PTR width$113286[rsp]
  0049d	44 89 b4 24 a4
	00 00 00	 mov	 DWORD PTR width$113286[rsp], r14d
  004a5	e8 00 00 00 00	 call	 GdipGetImageWidth
  004aa	41 3b c6	 cmp	 eax, r14d
  004ad	74 03		 je	 SHORT $LN178@Extract
  004af	89 45 10	 mov	 DWORD PTR [rbp+16], eax
$LN178@Extract:
  004b2	8b bc 24 a4 00
	00 00		 mov	 edi, DWORD PTR width$113286[rsp]
  004b9	33 c0		 xor	 eax, eax
  004bb	41 3b fe	 cmp	 edi, r14d
  004be	89 84 24 90 00
	00 00		 mov	 DWORD PTR thumbSize$113294[rsp], eax
  004c5	89 84 24 94 00
	00 00		 mov	 DWORD PTR thumbSize$113294[rsp+4], eax
  004cc	7e 76		 jle	 SHORT $LN186@Extract
  004ce	45 3b e6	 cmp	 r12d, r14d
  004d1	7e 71		 jle	 SHORT $LN186@Extract
  004d3	44 3b e7	 cmp	 r12d, edi
  004d6	7d 24		 jge	 SHORT $LN373@Extract
  004d8	3b fe		 cmp	 edi, esi
  004da	0f 4c f7	 cmovl	 esi, edi
  004dd	8b c6		 mov	 eax, esi
  004df	89 b4 24 90 00
	00 00		 mov	 DWORD PTR thumbSize$113294[rsp], esi
  004e6	41 0f af c4	 imul	 eax, r12d
  004ea	99		 cdq
  004eb	41 bc 01 00 00
	00		 mov	 r12d, 1
  004f1	f7 ff		 idiv	 edi
  004f3	41 3b c4	 cmp	 eax, r12d
  004f6	41 0f 4c c4	 cmovl	 eax, r12d
  004fa	eb 56		 jmp	 SHORT $LN374@Extract
$LN373@Extract:
  004fc	7e 31		 jle	 SHORT $LN182@Extract
  004fe	44 3b e6	 cmp	 r12d, esi
  00501	41 0f 4c f4	 cmovl	 esi, r12d
  00505	8b c6		 mov	 eax, esi
  00507	8b ce		 mov	 ecx, esi
  00509	89 8c 24 94 00
	00 00		 mov	 DWORD PTR thumbSize$113294[rsp+4], ecx
  00510	0f af c7	 imul	 eax, edi
  00513	99		 cdq
  00514	41 f7 fc	 idiv	 r12d
  00517	41 bc 01 00 00
	00		 mov	 r12d, 1
  0051d	8b f0		 mov	 esi, eax
  0051f	41 3b c4	 cmp	 eax, r12d
  00522	41 0f 4c f4	 cmovl	 esi, r12d
  00526	89 b4 24 90 00
	00 00		 mov	 DWORD PTR thumbSize$113294[rsp], esi
  0052d	eb 2a		 jmp	 SHORT $LN181@Extract
$LN182@Extract:
  0052f	3b fe		 cmp	 edi, esi
  00531	0f 4c f7	 cmovl	 esi, edi
  00534	89 b4 24 90 00
	00 00		 mov	 DWORD PTR thumbSize$113294[rsp], esi
  0053b	89 b4 24 94 00
	00 00		 mov	 DWORD PTR thumbSize$113294[rsp+4], esi
  00542	eb 15		 jmp	 SHORT $LN181@Extract
$LN186@Extract:
  00544	b8 01 00 00 00	 mov	 eax, 1
  00549	8b f0		 mov	 esi, eax
  0054b	89 84 24 90 00
	00 00		 mov	 DWORD PTR thumbSize$113294[rsp], eax
$LN374@Extract:
  00552	89 84 24 94 00
	00 00		 mov	 DWORD PTR thumbSize$113294[rsp+4], eax
$LN181@Extract:

; 642  :                 UINT nNewWidth = newSize.cx;
; 643  :                 UINT nNewHeight = newSize.cy;
; 644  : 
; 645  :                 if (SUCCEEDED(hr))
; 646  :                 {
; 647  :                     pResizedBitmap = new Bitmap(nNewWidth, nNewHeight, PixelFormat32bppARGB);

  00559	49 8b cd	 mov	 rcx, r13
  0055c	e8 00 00 00 00	 call	 GdipAlloc
  00561	48 8b f8	 mov	 rdi, rax
  00564	49 3b c6	 cmp	 rax, r14
  00567	74 51		 je	 SHORT $LN113@Extract
  00569	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR thumbSize$113294[rsp]
  00571	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR bitmap$113331[rsp]
  00579	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7Bitmap@Gdiplus@@6B@
  00580	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00585	41 b9 0a 20 26
	00		 mov	 r9d, 2498570		; 0026200aH
  0058b	45 33 c0	 xor	 r8d, r8d
  0058e	48 c1 ea 20	 shr	 rdx, 32			; 00000020H
  00592	8b ce		 mov	 ecx, esi
  00594	48 89 07	 mov	 QWORD PTR [rdi], rax
  00597	4c 89 b4 24 b0
	00 00 00	 mov	 QWORD PTR bitmap$113331[rsp], r14
  0059f	4c 89 74 24 20	 mov	 QWORD PTR [rsp+32], r14
  005a4	e8 00 00 00 00	 call	 GdipCreateBitmapFromScan0
  005a9	89 47 10	 mov	 DWORD PTR [rdi+16], eax
  005ac	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR bitmap$113331[rsp]
  005b4	48 89 47 08	 mov	 QWORD PTR [rdi+8], rax
  005b8	eb 03		 jmp	 SHORT $LN114@Extract
$LN113@Extract:
  005ba	49 8b fe	 mov	 rdi, r14
$LN114@Extract:

; 648  : 
; 649  :                     if (NULL == pResizedBitmap)

  005bd	49 3b fe	 cmp	 rdi, r14
  005c0	41 bc 0e 00 07
	80		 mov	 r12d, -2147024882	; ffffffff8007000eH
  005c6	41 0f 44 dc	 cmove	 ebx, r12d

; 650  :                     {
; 651  :                         hr = E_OUTOFMEMORY;
; 652  :                     }
; 653  :                 }
; 654  : 
; 655  :                 Graphics *pG = NULL;
; 656  :                 if (SUCCEEDED(hr))

  005ca	41 3b de	 cmp	 ebx, r14d
  005cd	0f 8c 3a 03 00
	00		 jl	 $LN22@Extract

; 657  :                 {
; 658  :                     pG = Graphics::FromImage(pResizedBitmap);

  005d3	b9 10 00 00 00	 mov	 ecx, 16
  005d8	e8 00 00 00 00	 call	 GdipAlloc
  005dd	48 8b f0	 mov	 rsi, rax
  005e0	49 3b c6	 cmp	 rax, r14
  005e3	74 31		 je	 SHORT $LN204@Extract
  005e5	49 8b c6	 mov	 rax, r14
  005e8	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR graphics$113360[rsp], rax
  005f0	49 3b fe	 cmp	 rdi, r14
  005f3	74 1c		 je	 SHORT $LN208@Extract
  005f5	48 8b 4f 08	 mov	 rcx, QWORD PTR [rdi+8]
  005f9	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR graphics$113360[rsp]
  00601	e8 00 00 00 00	 call	 GdipGetImageGraphicsContext
  00606	89 46 08	 mov	 DWORD PTR [rsi+8], eax
  00609	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR graphics$113360[rsp]
$LN208@Extract:
  00611	48 89 06	 mov	 QWORD PTR [rsi], rax
  00614	eb 03		 jmp	 SHORT $LN205@Extract
$LN204@Extract:
  00616	49 8b f6	 mov	 rsi, r14
$LN205@Extract:

; 659  : 
; 660  :                     if (NULL == pG)

  00619	49 3b f6	 cmp	 rsi, r14
  0061c	41 0f 44 dc	 cmove	 ebx, r12d

; 661  :                     {
; 662  :                         hr = E_OUTOFMEMORY;
; 663  :                     }
; 664  :                 }
; 665  : 
; 666  :                 if (SUCCEEDED(hr))

  00620	41 3b de	 cmp	 ebx, r14d
  00623	0f 8c cb 01 00
	00		 jl	 $LN302@Extract

; 667  :                 {
; 668  : 					// In Windows Vista, we can have a transparent background and it works great.
; 669  : 					// In XP, our alpha channel gets stomped to black.
; 670  : 					BOOL bIsVista = FALSE;
; 671  : 					HRESULT hrx = VerifyWindowsVersion(6, 0, &bIsVista);

  00629	48 8d 84 24 98
	00 00 00	 lea	 rax, QWORD PTR bIsVista$107203[rsp]
  00631	45 8b e6	 mov	 r12d, r14d
  00634	44 89 b4 24 98
	00 00 00	 mov	 DWORD PTR bIsVista$107203[rsp], r14d
  0063c	49 3b c6	 cmp	 rax, r14
  0063f	75 08		 jne	 SHORT $LN224@Extract
  00641	41 bd 57 00 07
	80		 mov	 r13d, -2147024809	; ffffffff80070057H
  00647	eb 18		 jmp	 SHORT $LN219@Extract
$LN224@Extract:
  00649	48 8d 8c 24 98
	00 00 00	 lea	 rcx, QWORD PTR bIsVista$107203[rsp]
  00651	e8 00 00 00 00	 call	 ?VerifyWindowsVersion@@YAJKKPEAH@Z ; VerifyWindowsVersion
  00656	44 8b a4 24 98
	00 00 00	 mov	 r12d, DWORD PTR bIsVista$107203[rsp]
  0065e	44 8b e8	 mov	 r13d, eax
$LN219@Extract:

; 672  : 
; 673  : 					pG->SetCompositingMode(CompositingModeSourceCopy);

  00661	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
  00664	ba 01 00 00 00	 mov	 edx, 1
  00669	e8 00 00 00 00	 call	 GdipSetCompositingMode
  0066e	41 3b c6	 cmp	 eax, r14d
  00671	74 03		 je	 SHORT $LN228@Extract
  00673	89 46 08	 mov	 DWORD PTR [rsi+8], eax
$LN228@Extract:

; 674  : 
; 675  : 					if (SUCCEEDED(hrx) && bIsVista)

  00676	45 3b ee	 cmp	 r13d, r14d
  00679	7c 0c		 jl	 SHORT $LN26@Extract
  0067b	45 3b e6	 cmp	 r12d, r14d
  0067e	74 07		 je	 SHORT $LN26@Extract

; 676  : 					{
; 677  : 						pG->Clear(Color::Transparent);

  00680	ba ff ff ff 00	 mov	 edx, 16777215		; 00ffffffH

; 678  : 					}
; 679  : 					else

  00685	eb 03		 jmp	 SHORT $LN375@Extract
$LN26@Extract:

; 680  : 					{
; 681  : 						pG->Clear(Color::White);

  00687	83 ca ff	 or	 edx, -1			; ffffffffH
$LN375@Extract:
  0068a	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
  0068d	e8 00 00 00 00	 call	 GdipGraphicsClear
  00692	41 3b c6	 cmp	 eax, r14d
  00695	74 03		 je	 SHORT $LN248@Extract
  00697	89 46 08	 mov	 DWORD PTR [rsi+8], eax
$LN248@Extract:

; 682  : 					}
; 683  : 
; 684  : 					pG->SetCompositingMode(CompositingModeSourceOver);

  0069a	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
  0069d	33 d2		 xor	 edx, edx
  0069f	e8 00 00 00 00	 call	 GdipSetCompositingMode
  006a4	41 3b c6	 cmp	 eax, r14d
  006a7	74 03		 je	 SHORT $LN254@Extract
  006a9	89 46 08	 mov	 DWORD PTR [rsi+8], eax
$LN254@Extract:

; 685  : 
; 686  : 					// Fit the thumbnail to the output bitmap
; 687  :                     pG->SetInterpolationMode(InterpolationModeBicubic);

  006ac	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
  006af	41 bc 04 00 00
	00		 mov	 r12d, 4
  006b5	41 8b d4	 mov	 edx, r12d
  006b8	e8 00 00 00 00	 call	 GdipSetInterpolationMode
  006bd	41 3b c6	 cmp	 eax, r14d
  006c0	74 03		 je	 SHORT $LN260@Extract
  006c2	89 46 08	 mov	 DWORD PTR [rsi+8], eax
$LN260@Extract:

; 688  : 
; 689  :                     pG->SetPixelOffsetMode(PixelOffsetModeHalf);

  006c5	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
  006c8	41 8b d4	 mov	 edx, r12d
  006cb	e8 00 00 00 00	 call	 GdipSetPixelOffsetMode
  006d0	41 3b c6	 cmp	 eax, r14d
  006d3	74 03		 je	 SHORT $LN266@Extract
  006d5	89 46 08	 mov	 DWORD PTR [rsi+8], eax
$LN266@Extract:

; 690  : 
; 691  :                     pG->DrawImage(
; 692  :                         pBitmap, 
; 693  :                         RectF((REAL)0, (REAL)0, (REAL)pResizedBitmap->GetWidth(), (REAL)pResizedBitmap->GetHeight()),
; 694  :                         (REAL)0,
; 695  :                         (REAL)0,
; 696  :                         (REAL)pBitmap->GetWidth(),
; 697  :                         (REAL)pBitmap->GetHeight(),
; 698  :                         UnitPixel);

  006d8	48 8b 4d 08	 mov	 rcx, QWORD PTR [rbp+8]
  006dc	48 8d 94 24 a4
	00 00 00	 lea	 rdx, QWORD PTR height$113501[rsp]
  006e4	44 89 b4 24 a4
	00 00 00	 mov	 DWORD PTR height$113501[rsp], r14d
  006ec	e8 00 00 00 00	 call	 GdipGetImageHeight
  006f1	41 3b c6	 cmp	 eax, r14d
  006f4	74 03		 je	 SHORT $LN272@Extract
  006f6	89 45 10	 mov	 DWORD PTR [rbp+16], eax
$LN272@Extract:
  006f9	48 8b 4d 08	 mov	 rcx, QWORD PTR [rbp+8]
  006fd	44 8b b4 24 a4
	00 00 00	 mov	 r14d, DWORD PTR height$113501[rsp]
  00705	83 a4 24 98 00
	00 00 00	 and	 DWORD PTR width$113518[rsp], 0
  0070d	48 8d 94 24 98
	00 00 00	 lea	 rdx, QWORD PTR width$113518[rsp]
  00715	e8 00 00 00 00	 call	 GdipGetImageWidth
  0071a	85 c0		 test	 eax, eax
  0071c	74 03		 je	 SHORT $LN278@Extract
  0071e	89 45 10	 mov	 DWORD PTR [rbp+16], eax
$LN278@Extract:
  00721	48 8b 4f 08	 mov	 rcx, QWORD PTR [rdi+8]
  00725	44 8b ac 24 98
	00 00 00	 mov	 r13d, DWORD PTR width$113518[rsp]
  0072d	83 a4 24 b0 00
	00 00 00	 and	 DWORD PTR height$113535[rsp], 0
  00735	48 8d 94 24 b0
	00 00 00	 lea	 rdx, QWORD PTR height$113535[rsp]
  0073d	e8 00 00 00 00	 call	 GdipGetImageHeight
  00742	85 c0		 test	 eax, eax
  00744	74 03		 je	 SHORT $LN284@Extract
  00746	89 47 10	 mov	 DWORD PTR [rdi+16], eax
$LN284@Extract:
  00749	48 8b 4f 08	 mov	 rcx, QWORD PTR [rdi+8]
  0074d	44 8b a4 24 b0
	00 00 00	 mov	 r12d, DWORD PTR height$113535[rsp]
  00755	83 a4 24 90 00
	00 00 00	 and	 DWORD PTR width$113552[rsp], 0
  0075d	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR width$113552[rsp]
  00765	e8 00 00 00 00	 call	 GdipGetImageWidth
  0076a	85 c0		 test	 eax, eax
  0076c	74 03		 je	 SHORT $LN290@Extract
  0076e	89 47 10	 mov	 DWORD PTR [rdi+16], eax
$LN290@Extract:
  00771	0f 57 d2	 xorps	 xmm2, xmm2
  00774	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR width$113552[rsp]
  0077b	48 8b 55 08	 mov	 rdx, QWORD PTR [rbp+8]
  0077f	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
  00782	66 0f ef db	 pxor	 xmm3, xmm3
  00786	66 0f ef c9	 pxor	 xmm1, xmm1
  0078a	f3 49 0f 2a ce	 cvtsi2ss xmm1, r14
  0078f	f3 49 0f 2a dc	 cvtsi2ss xmm3, r12
  00794	45 33 f6	 xor	 r14d, r14d
  00797	4c 89 74 24 68	 mov	 QWORD PTR [rsp+104], r14
  0079c	4c 89 74 24 60	 mov	 QWORD PTR [rsp+96], r14
  007a1	4c 89 74 24 58	 mov	 QWORD PTR [rsp+88], r14
  007a6	c7 44 24 50 02
	00 00 00	 mov	 DWORD PTR [rsp+80], 2
  007ae	f3 0f 11 4c 24
	48		 movss	 DWORD PTR [rsp+72], xmm1
  007b4	66 0f ef c0	 pxor	 xmm0, xmm0
  007b8	66 0f ef e4	 pxor	 xmm4, xmm4
  007bc	f3 49 0f 2a c5	 cvtsi2ss xmm0, r13
  007c1	f3 48 0f 2a e0	 cvtsi2ss xmm4, rax
  007c6	f3 0f 11 44 24
	40		 movss	 DWORD PTR [rsp+64], xmm0
  007cc	f3 0f 11 54 24
	38		 movss	 DWORD PTR [rsp+56], xmm2
  007d2	f3 0f 11 54 24
	30		 movss	 DWORD PTR [rsp+48], xmm2
  007d8	f3 0f 11 5c 24
	28		 movss	 DWORD PTR [rsp+40], xmm3
  007de	f3 0f 11 64 24
	20		 movss	 DWORD PTR [rsp+32], xmm4
  007e4	0f 28 da	 movaps	 xmm3, xmm2
  007e7	e8 00 00 00 00	 call	 GdipDrawImageRectRect
  007ec	41 3b c6	 cmp	 eax, r14d
  007ef	74 03		 je	 SHORT $LN302@Extract
  007f1	89 46 08	 mov	 DWORD PTR [rsi+8], eax
$LN302@Extract:

; 699  :                 }
; 700  : 
; 701  :                 if (NULL != pG)

  007f4	49 3b f6	 cmp	 rsi, r14
  007f7	0f 84 10 01 00
	00		 je	 $LN22@Extract

; 702  :                 {
; 703  :                     delete pG;

  007fd	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
  00800	e8 00 00 00 00	 call	 GdipDeleteGraphics
  00805	48 8b ce	 mov	 rcx, rsi
  00808	e8 00 00 00 00	 call	 GdipFree

; 704  :                     pG = NULL;
; 705  :                 }
; 706  :             }
; 707  :             else

  0080d	e9 fb 00 00 00	 jmp	 $LN22@Extract
$LN32@Extract:

; 708  :             {
; 709  :                 pResizedBitmap = pBitmap->Clone(Rect(0, 0, pBitmap->GetWidth(), pBitmap->GetHeight()), pBitmap->GetPixelFormat());

  00812	48 8b 4d 08	 mov	 rcx, QWORD PTR [rbp+8]
  00816	48 8d 94 24 a4
	00 00 00	 lea	 rdx, QWORD PTR format$113608[rsp]
  0081e	e8 00 00 00 00	 call	 GdipGetImagePixelFormat
  00823	41 3b c6	 cmp	 eax, r14d
  00826	74 03		 je	 SHORT $LN315@Extract
  00828	89 45 10	 mov	 DWORD PTR [rbp+16], eax
$LN315@Extract:
  0082b	48 8b 4d 08	 mov	 rcx, QWORD PTR [rbp+8]
  0082f	8b b4 24 a4 00
	00 00		 mov	 esi, DWORD PTR format$113608[rsp]
  00836	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR height$113625[rsp]
  0083e	44 89 b4 24 90
	00 00 00	 mov	 DWORD PTR height$113625[rsp], r14d
  00846	e8 00 00 00 00	 call	 GdipGetImageHeight
  0084b	41 3b c6	 cmp	 eax, r14d
  0084e	74 03		 je	 SHORT $LN321@Extract
  00850	89 45 10	 mov	 DWORD PTR [rbp+16], eax
$LN321@Extract:
  00853	48 8b 4d 08	 mov	 rcx, QWORD PTR [rbp+8]
  00857	8b bc 24 90 00
	00 00		 mov	 edi, DWORD PTR height$113625[rsp]
  0085e	48 8d 94 24 b0
	00 00 00	 lea	 rdx, QWORD PTR width$113642[rsp]
  00866	44 89 b4 24 b0
	00 00 00	 mov	 DWORD PTR width$113642[rsp], r14d
  0086e	e8 00 00 00 00	 call	 GdipGetImageWidth
  00873	41 3b c6	 cmp	 eax, r14d
  00876	74 03		 je	 SHORT $LN327@Extract
  00878	89 45 10	 mov	 DWORD PTR [rbp+16], eax
$LN327@Extract:
  0087b	44 8b 84 24 b0
	00 00 00	 mov	 r8d, DWORD PTR width$113642[rsp]
  00883	48 8d 84 24 98
	00 00 00	 lea	 rax, QWORD PTR gpdstBitmap$113720[rsp]
  0088b	44 8b cf	 mov	 r9d, edi
  0088e	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00893	48 8b 45 08	 mov	 rax, QWORD PTR [rbp+8]
  00897	33 d2		 xor	 edx, edx
  00899	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0089e	33 c9		 xor	 ecx, ecx
  008a0	4c 89 b4 24 98
	00 00 00	 mov	 QWORD PTR gpdstBitmap$113720[rsp], r14
  008a8	89 74 24 20	 mov	 DWORD PTR [rsp+32], esi
  008ac	e8 00 00 00 00	 call	 GdipCloneBitmapAreaI
  008b1	41 3b c6	 cmp	 eax, r14d
  008b4	74 05		 je	 SHORT $LN342@Extract
  008b6	89 45 10	 mov	 DWORD PTR [rbp+16], eax
  008b9	eb 03		 jmp	 SHORT $LN341@Extract
$LN342@Extract:
  008bb	41 8b c6	 mov	 eax, r14d
$LN341@Extract:
  008be	41 3b c6	 cmp	 eax, r14d
  008c1	75 3c		 jne	 SHORT $LN336@Extract
  008c3	49 8b cd	 mov	 rcx, r13
  008c6	e8 00 00 00 00	 call	 GdipAlloc
  008cb	48 8b f8	 mov	 rdi, rax
  008ce	49 3b c6	 cmp	 rax, r14
  008d1	74 15		 je	 SHORT $LN339@Extract
  008d3	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR gpdstBitmap$113720[rsp]
  008db	4c 89 27	 mov	 QWORD PTR [rdi], r12
  008de	44 89 77 10	 mov	 DWORD PTR [rdi+16], r14d
  008e2	48 89 47 08	 mov	 QWORD PTR [rdi+8], rax
  008e6	eb 03		 jmp	 SHORT $LN340@Extract
$LN339@Extract:
  008e8	49 8b fe	 mov	 rdi, r14
$LN340@Extract:
  008eb	49 3b fe	 cmp	 rdi, r14
  008ee	75 15		 jne	 SHORT $LN376@Extract
  008f0	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR gpdstBitmap$113720[rsp]
  008f8	e8 00 00 00 00	 call	 GdipDisposeImage
  008fd	eb 03		 jmp	 SHORT $LN334@Extract
$LN336@Extract:
  008ff	49 8b fe	 mov	 rdi, r14
$LN334@Extract:

; 710  : 
; 711  :                 if (NULL == pResizedBitmap)

  00902	49 3b fe	 cmp	 rdi, r14
$LN376@Extract:
  00905	b8 0e 00 07 80	 mov	 eax, -2147024882	; ffffffff8007000eH
  0090a	0f 44 d8	 cmove	 ebx, eax
$LN22@Extract:

; 712  :                 {
; 713  :                     hr = E_OUTOFMEMORY;
; 714  :                 }
; 715  :             }
; 716  :         }
; 717  : 
; 718  :         if (NULL != pBitmap)
; 719  :         {
; 720  :             delete pBitmap;

  0090d	be 01 00 00 00	 mov	 esi, 1
  00912	49 3b ee	 cmp	 rbp, r14
  00915	74 0b		 je	 SHORT $LN117@Extract
  00917	48 8b 45 00	 mov	 rax, QWORD PTR [rbp]
  0091b	8b d6		 mov	 edx, esi
  0091d	48 8b cd	 mov	 rcx, rbp
  00920	ff 10		 call	 QWORD PTR [rax]
$LN117@Extract:

; 721  :             pBitmap = NULL;
; 722  :         }
; 723  : 
; 724  :         TraceOut("Get HBITMAP from it");
; 725  :         HBITMAP hBitmap = NULL;
; 726  :         if (SUCCEEDED(hr))

  00922	41 3b de	 cmp	 ebx, r14d
  00925	4c 89 b4 24 c0
	00 00 00	 mov	 QWORD PTR hBitmap$107231[rsp], r14
  0092d	7c 5f		 jl	 SHORT $LN367@Extract

; 727  :         {
; 728  :             Status status = pResizedBitmap->GetHBITMAP(Color(0), &hBitmap);

  0092f	48 8b 4f 08	 mov	 rcx, QWORD PTR [rdi+8]
  00933	48 8d 94 24 c0
	00 00 00	 lea	 rdx, QWORD PTR hBitmap$107231[rsp]
  0093b	45 33 c0	 xor	 r8d, r8d
  0093e	e8 00 00 00 00	 call	 GdipCreateHBITMAPFromBitmap
  00943	41 3b c6	 cmp	 eax, r14d
  00946	74 05		 je	 SHORT $LN360@Extract
  00948	89 47 10	 mov	 DWORD PTR [rdi+16], eax
  0094b	eb 03		 jmp	 SHORT $LN359@Extract
$LN360@Extract:
  0094d	41 8b c6	 mov	 eax, r14d
$LN359@Extract:

; 729  :             TraceOut("status=%d", status);
; 730  : 
; 731  :             if (Ok != status)

  00950	41 3b c6	 cmp	 eax, r14d
  00953	74 21		 je	 SHORT $LN14@Extract

; 732  :             {
; 733  :                 if (Win32Error == status)

  00955	83 f8 07	 cmp	 eax, 7
  00958	75 17		 jne	 SHORT $LN16@Extract

; 734  :                 {
; 735  :                     dwError = GetLastError();

  0095a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError

; 736  :                     hr = HRESULT_FROM_WIN32(dwError);

  00960	0f b7 d8	 movzx	 ebx, ax
  00963	81 cb 00 00 07
	80		 or	 ebx, -2147024896	; ffffffff80070000H
  00969	41 3b c6	 cmp	 eax, r14d
  0096c	0f 4e d8	 cmovle	 ebx, eax

; 737  :                     TraceOut("pResizedBitmap->GetHBITMAP failed, hr=0x%x", hr);
; 738  :                 }
; 739  :                 else

  0096f	eb 05		 jmp	 SHORT $LN14@Extract
$LN16@Extract:

; 740  :                 {
; 741  :                     TraceOut("pResizedBitmap->GetHBITMAP failed, not Win32Error, hr is now = E_FAIL");
; 742  :                     hr = E_FAIL;

  00971	bb 05 40 00 80	 mov	 ebx, -2147467259	; ffffffff80004005H
$LN14@Extract:

; 743  :                 }
; 744  :             }
; 745  :         }
; 746  : 
; 747  :         TraceOut("Give bitmap to the caller!");
; 748  :         if (SUCCEEDED(hr))

  00976	41 3b de	 cmp	 ebx, r14d
  00979	7c 13		 jl	 SHORT $LN367@Extract

; 749  :         {
; 750  :             *phBmpImage = hBitmap;

  0097b	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR phBmpImage$GSCopy$1$[rsp]
  00983	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR hBitmap$107231[rsp]
  0098b	48 89 01	 mov	 QWORD PTR [rcx], rax
$LN367@Extract:

; 751  :         }
; 752  : 
; 753  :         TraceOut("Cleanup");
; 754  :         if (NULL != pResizedBitmap)

  0098e	49 3b fe	 cmp	 rdi, r14
  00991	74 0a		 je	 SHORT $LN119@Extract

; 755  :         {
; 756  :             delete pResizedBitmap;

  00993	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  00996	8b d6		 mov	 edx, esi
  00998	48 8b cf	 mov	 rcx, rdi
  0099b	ff 10		 call	 QWORD PTR [rax]
$LN119@Extract:

; 757  :             pResizedBitmap = NULL;
; 758  :         }
; 759  : 
; 760  :         if (NULL != pGdiToken)

  0099d	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR pGdiToken$107162[rsp]
  009a5	49 3b ce	 cmp	 rcx, r14
  009a8	74 0d		 je	 SHORT $LN8@Extract

; 761  :         {
; 762  :             GdiplusShutdown(pGdiToken);

  009aa	e8 00 00 00 00	 call	 GdiplusShutdown

; 763  :             pGdiToken = NULL;

  009af	4c 89 b4 24 b8
	00 00 00	 mov	 QWORD PTR pGdiToken$107162[rsp], r14
$LN8@Extract:

; 764  :         }
; 765  : 
; 766  :         if (NULL != pMemoryStream)

  009b7	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pMemoryStream$1$[rsp]
  009bc	49 3b ce	 cmp	 rcx, r14
  009bf	74 06		 je	 SHORT $LN7@Extract

; 767  :         {
; 768  :             pMemoryStream->Release();

  009c1	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  009c4	ff 50 10	 call	 QWORD PTR [rax+16]
$LN7@Extract:

; 769  :             pMemoryStream = NULL;
; 770  :         }
; 771  : 
; 772  :         if (NULL != pbHeaderBytes)

  009c7	4d 3b fe	 cmp	 r15, r14
  009ca	74 08		 je	 SHORT $LN6@Extract

; 773  :         {
; 774  :             delete [] pbHeaderBytes;

  009cc	49 8b cf	 mov	 rcx, r15
  009cf	e8 00 00 00 00	 call	 ??_V@YAXPEAX@Z		; operator delete[]
$LN6@Extract:

; 775  :             pbHeaderBytes = NULL;
; 776  :         }
; 777  : 
; 778  :         if (NULL != pbImgBytes)

  009d4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pbImgBytes$1$[rsp]
  009d9	49 3b ce	 cmp	 rcx, r14
  009dc	74 05		 je	 SHORT $LN5@Extract

; 779  :         {
; 780  :             delete [] pbImgBytes;

  009de	e8 00 00 00 00	 call	 ??_V@YAXPEAX@Z		; operator delete[]
$LN5@Extract:

; 781  :             pbImgBytes = NULL;
; 782  :         }
; 783  :     }
; 784  : 
; 785  :     if (!bPdn3File || FAILED(hr))

  009e3	41 3b de	 cmp	 ebx, r14d
  009e6	7d 09		 jge	 SHORT $LN4@Extract
  009e8	41 bc 05 40 00
	80		 mov	 r12d, -2147467259	; ffffffff80004005H
$LN3@Extract:

; 786  :     {
; 787  :         // Give generic PDN icon of some sort
; 788  :         hr = E_FAIL;

  009ee	41 8b dc	 mov	 ebx, r12d
$LN4@Extract:

; 789  :     }    
; 790  : 
; 791  :     // Cleanup
; 792  :     if (INVALID_HANDLE_VALUE != hFile)

  009f1	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR hFile$1$[rsp]
  009f9	48 83 f9 ff	 cmp	 rcx, -1
  009fd	74 06		 je	 SHORT $LN2@Extract

; 793  :     {
; 794  :         CloseHandle(hFile);

  009ff	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle
$LN2@Extract:

; 795  :         hFile = INVALID_HANDLE_VALUE;
; 796  :     }
; 797  : 
; 798  :     TraceLeaveHr(hr);
; 799  :     return hr;

  00a05	8b c3		 mov	 eax, ebx

; 800  : }

  00a07	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00a0f	48 33 cc	 xor	 rcx, rsp
  00a12	e8 00 00 00 00	 call	 __security_check_cookie
  00a17	48 8b 9c 24 40
	01 00 00	 mov	 rbx, QWORD PTR [rsp+320]
  00a1f	48 81 c4 f0 00
	00 00		 add	 rsp, 240		; 000000f0H
  00a26	41 5f		 pop	 r15
  00a28	41 5e		 pop	 r14
  00a2a	41 5d		 pop	 r13
  00a2c	41 5c		 pop	 r12
  00a2e	5f		 pop	 rdi
  00a2f	5e		 pop	 rsi
  00a30	5d		 pop	 rbp
  00a31	c3		 ret	 0
?Extract@CPdnShellExtension@@UEAAJPEAPEAUHBITMAP__@@@Z ENDP ; CPdnShellExtension::Extract
PUBLIC	?clash@Define_the_symbol__ATL_MIXED@@3UThank_you@1@A ; Define_the_symbol__ATL_MIXED::clash
;	COMDAT ?clash@Define_the_symbol__ATL_MIXED@@3UThank_you@1@A
; File c:\program files (x86)\microsoft visual studio 9.0\vc\atlmfc\include\atldef.h
_DATA	SEGMENT
?clash@Define_the_symbol__ATL_MIXED@@3UThank_you@1@A DQ FLAT:??_7Thank_you@Define_the_symbol__ATL_MIXED@@6B@ ; Define_the_symbol__ATL_MIXED::clash
_DATA	ENDS
PUBLIC	?clash@Inconsistent_definition_of_symbol__ATL_MIXED@@3U_Please_define_it_the_same_throughout_your_project@1@A ; Inconsistent_definition_of_symbol__ATL_MIXED::clash
;	COMDAT ?clash@Inconsistent_definition_of_symbol__ATL_MIXED@@3U_Please_define_it_the_same_throughout_your_project@1@A
_BSS	SEGMENT
?clash@Inconsistent_definition_of_symbol__ATL_MIXED@@3U_Please_define_it_the_same_throughout_your_project@1@A DB 01H DUP (?) ; Inconsistent_definition_of_symbol__ATL_MIXED::clash
_BSS	ENDS
END
