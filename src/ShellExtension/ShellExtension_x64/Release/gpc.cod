; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	next_h_state
PUBLIC	??_C@_0O@PACJOHFA@LMT?5insertion?$AA@		; `string'
PUBLIC	??_C@_0BI@GBJAADOD@gpc?5malloc?5failure?3?5?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_0BI@KNFEDHGK@scanbeam?5tree?5insertion?$AA@ ; `string'
PUBLIC	??_C@_0BE@DDDONHEA@edge?5table?5creation?$AA@	; `string'
PUBLIC	??_C@_0N@IFBDNEFP@IT?5insertion?$AA@		; `string'
PUBLIC	??_C@_0N@LELBEKD@ST?5insertion?$AA@		; `string'
PUBLIC	??_C@_0BF@EBLPDDCK@vertex?5node?5creation?$AA@	; `string'
PUBLIC	??_C@_0BG@KDIMFLIB@polygon?5node?5creation?$AA@	; `string'
PUBLIC	??_C@_0BG@CIAEENND@Bounding?5box?5creation?$AA@	; `string'
PUBLIC	??_C@_0BH@KNBJDBCH@overlap?5table?5creation?$AA@ ; `string'
PUBLIC	??_C@_0BG@JNAHPLPG@contour?5hole?5addition?$AA@	; `string'
PUBLIC	??_C@_0BB@DMABKBKA@contour?5addition?$AA@	; `string'
PUBLIC	??_C@_0N@FBEONJIC@sbt?5creation?$AA@		; `string'
PUBLIC	??_C@_0BJ@CMCBODNK@hole?5flag?5table?5creation?$AA@ ; `string'
PUBLIC	??_C@_0BB@OCAHDIFD@contour?5creation?$AA@	; `string'
PUBLIC	??_C@_0BA@EHDPPPDI@vertex?5creation?$AA@	; `string'
EXTRN	free:PROC
EXTRN	__iob_func:PROC
EXTRN	fprintf:PROC
EXTRN	exit:PROC
EXTRN	malloc:PROC
;	COMDAT ??_C@_0BA@EHDPPPDI@vertex?5creation?$AA@
CONST	SEGMENT
??_C@_0BA@EHDPPPDI@vertex?5creation?$AA@ DB 'vertex creation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@OCAHDIFD@contour?5creation?$AA@
CONST	SEGMENT
??_C@_0BB@OCAHDIFD@contour?5creation?$AA@ DB 'contour creation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@CMCBODNK@hole?5flag?5table?5creation?$AA@
CONST	SEGMENT
??_C@_0BJ@CMCBODNK@hole?5flag?5table?5creation?$AA@ DB 'hole flag table c'
	DB	'reation', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FBEONJIC@sbt?5creation?$AA@
CONST	SEGMENT
??_C@_0N@FBEONJIC@sbt?5creation?$AA@ DB 'sbt creation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@DMABKBKA@contour?5addition?$AA@
CONST	SEGMENT
??_C@_0BB@DMABKBKA@contour?5addition?$AA@ DB 'contour addition', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@JNAHPLPG@contour?5hole?5addition?$AA@
CONST	SEGMENT
??_C@_0BG@JNAHPLPG@contour?5hole?5addition?$AA@ DB 'contour hole addition'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@KNBJDBCH@overlap?5table?5creation?$AA@
CONST	SEGMENT
??_C@_0BH@KNBJDBCH@overlap?5table?5creation?$AA@ DB 'overlap table creati'
	DB	'on', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@CIAEENND@Bounding?5box?5creation?$AA@
CONST	SEGMENT
??_C@_0BG@CIAEENND@Bounding?5box?5creation?$AA@ DB 'Bounding box creation'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@KDIMFLIB@polygon?5node?5creation?$AA@
CONST	SEGMENT
??_C@_0BG@KDIMFLIB@polygon?5node?5creation?$AA@ DB 'polygon node creation'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@EBLPDDCK@vertex?5node?5creation?$AA@
CONST	SEGMENT
??_C@_0BF@EBLPDDCK@vertex?5node?5creation?$AA@ DB 'vertex node creation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LELBEKD@ST?5insertion?$AA@
CONST	SEGMENT
??_C@_0N@LELBEKD@ST?5insertion?$AA@ DB 'ST insertion', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@IFBDNEFP@IT?5insertion?$AA@
CONST	SEGMENT
??_C@_0N@IFBDNEFP@IT?5insertion?$AA@ DB 'IT insertion', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@DDDONHEA@edge?5table?5creation?$AA@
CONST	SEGMENT
??_C@_0BE@DDDONHEA@edge?5table?5creation?$AA@ DB 'edge table creation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@KNFEDHGK@scanbeam?5tree?5insertion?$AA@
CONST	SEGMENT
??_C@_0BI@KNFEDHGK@scanbeam?5tree?5insertion?$AA@ DB 'scanbeam tree inser'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@GBJAADOD@gpc?5malloc?5failure?3?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BI@GBJAADOD@gpc?5malloc?5failure?3?5?$CFs?6?$AA@ DB 'gpc malloc fa'
	DB	'ilure: %s', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@PACJOHFA@LMT?5insertion?$AA@
CONST	SEGMENT
??_C@_0O@PACJOHFA@LMT?5insertion?$AA@ DB 'LMT insertion', 00H ; `string'
next_h_state DD	01H
	DD	02H
	DD	02H
	DD	01H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	02H
	DD	02H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	01H
PUBLIC	gpc_add_contour
;	COMDAT pdata
; File e:\my_project\openpdn\openpdn-e28f1ff0077e\src\shellextension\gpc.c
pdata	SEGMENT
$pdata$gpc_add_contour DD imagerel $LN25
	DD	imagerel $LN25+431
	DD	imagerel $unwind$gpc_add_contour
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gpc_add_contour DD 0a1801H
	DD	0a6418H
	DD	095418H
	DD	083418H
	DD	0d0143218H
	DD	07010c012H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT gpc_add_contour
_TEXT	SEGMENT
p$ = 64
new_contour$ = 72
hole$ = 80
gpc_add_contour PROC					; COMDAT

; 1103 : {

$LN25:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1104 :   int             *extended_hole, c, v;
; 1105 :   gpc_vertex_list *extended_contour;
; 1106 : 
; 1107 :   /* Create an extended hole array */
; 1108 :   MALLOC(extended_hole, (p->num_contours + 1)
; 1109 :          * sizeof(int), "contour hole addition", int);

  00018	8b 01		 mov	 eax, DWORD PTR [rcx]
  0001a	48 8b d9	 mov	 rbx, rcx
  0001d	41 8b f0	 mov	 esi, r8d
  00020	ff c0		 inc	 eax
  00022	4c 8b ea	 mov	 r13, rdx
  00025	48 63 c8	 movsxd	 rcx, eax
  00028	48 c1 e1 02	 shl	 rcx, 2
  0002c	48 85 c9	 test	 rcx, rcx
  0002f	74 31		 je	 SHORT $LN17@gpc_add_co
  00031	e8 00 00 00 00	 call	 malloc
  00036	48 8b e8	 mov	 rbp, rax
  00039	48 85 c0	 test	 rax, rax
  0003c	75 26		 jne	 SHORT $LN15@gpc_add_co
  0003e	e8 00 00 00 00	 call	 __iob_func
  00043	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BG@JNAHPLPG@contour?5hole?5addition?$AA@
  0004a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@GBJAADOD@gpc?5malloc?5failure?3?5?$CFs?6?$AA@
  00051	48 8d 48 60	 lea	 rcx, QWORD PTR [rax+96]
  00055	e8 00 00 00 00	 call	 fprintf
  0005a	33 c9		 xor	 ecx, ecx
  0005c	e8 00 00 00 00	 call	 exit
  00061	cc		 int	 3
$LN17@gpc_add_co:
  00062	33 ed		 xor	 ebp, ebp
$LN15@gpc_add_co:

; 1110 : 
; 1111 :   /* Create an extended contour array */
; 1112 :   MALLOC(extended_contour, (p->num_contours + 1)
; 1113 :          * sizeof(gpc_vertex_list), "contour addition", gpc_vertex_list);

  00064	8b 03		 mov	 eax, DWORD PTR [rbx]
  00066	ff c0		 inc	 eax
  00068	48 63 c8	 movsxd	 rcx, eax
  0006b	48 c1 e1 04	 shl	 rcx, 4
  0006f	48 85 c9	 test	 rcx, rcx
  00072	74 31		 je	 SHORT $LN14@gpc_add_co
  00074	e8 00 00 00 00	 call	 malloc
  00079	48 8b f8	 mov	 rdi, rax
  0007c	48 85 c0	 test	 rax, rax
  0007f	75 26		 jne	 SHORT $LN12@gpc_add_co
  00081	e8 00 00 00 00	 call	 __iob_func
  00086	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BB@DMABKBKA@contour?5addition?$AA@
  0008d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@GBJAADOD@gpc?5malloc?5failure?3?5?$CFs?6?$AA@
  00094	48 8d 48 60	 lea	 rcx, QWORD PTR [rax+96]
  00098	e8 00 00 00 00	 call	 fprintf
  0009d	33 c9		 xor	 ecx, ecx
  0009f	e8 00 00 00 00	 call	 exit
  000a4	cc		 int	 3
$LN14@gpc_add_co:
  000a5	33 ff		 xor	 edi, edi
$LN12@gpc_add_co:

; 1114 : 
; 1115 :   /* Copy the old contour and hole data into the extended arrays */
; 1116 :   for (c= 0; c < p->num_contours; c++)

  000a7	33 d2		 xor	 edx, edx
  000a9	39 13		 cmp	 DWORD PTR [rbx], edx
  000ab	7e 30		 jle	 SHORT $LN9@gpc_add_co
  000ad	45 33 c0	 xor	 r8d, r8d
  000b0	45 33 c9	 xor	 r9d, r9d
$LL11@gpc_add_co:

; 1117 :   {
; 1118 :     extended_hole[c]= p->hole[c];

  000b3	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
  000b7	ff c2		 inc	 edx
  000b9	41 8b 0c 01	 mov	 ecx, DWORD PTR [r9+rax]
  000bd	41 89 0c 29	 mov	 DWORD PTR [r9+rbp], ecx

; 1119 :     extended_contour[c]= p->contour[c];

  000c1	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  000c5	49 83 c1 04	 add	 r9, 4
  000c9	f3 41 0f 6f 04
	00		 movdqu	 xmm0, XMMWORD PTR [r8+rax]
  000cf	f3 41 0f 7f 04
	38		 movdqu	 XMMWORD PTR [r8+rdi], xmm0
  000d5	49 83 c0 10	 add	 r8, 16
  000d9	3b 13		 cmp	 edx, DWORD PTR [rbx]
  000db	7c d6		 jl	 SHORT $LL11@gpc_add_co
$LN9@gpc_add_co:

; 1120 :   }
; 1121 : 
; 1122 :   /* Copy the new contour and hole onto the end of the extended arrays */
; 1123 :   c= p->num_contours;
; 1124 :   extended_hole[c]= hole;

  000dd	4c 63 23	 movsxd	 r12, DWORD PTR [rbx]
  000e0	42 89 74 a5 00	 mov	 DWORD PTR [rbp+r12*4], esi

; 1125 :   extended_contour[c].num_vertices= new_contour->num_vertices;

  000e5	41 8b 45 00	 mov	 eax, DWORD PTR [r13]
  000e9	49 8b f4	 mov	 rsi, r12
  000ec	48 03 f6	 add	 rsi, rsi
  000ef	89 04 f7	 mov	 DWORD PTR [rdi+rsi*8], eax

; 1126 :   MALLOC(extended_contour[c].vertex, new_contour->num_vertices
; 1127 :          * sizeof(gpc_vertex), "contour addition", gpc_vertex);

  000f2	49 63 4d 00	 movsxd	 rcx, DWORD PTR [r13]
  000f6	48 c1 e1 04	 shl	 rcx, 4
  000fa	48 85 c9	 test	 rcx, rcx
  000fd	74 33		 je	 SHORT $LN8@gpc_add_co
  000ff	e8 00 00 00 00	 call	 malloc
  00104	48 89 44 f7 08	 mov	 QWORD PTR [rdi+rsi*8+8], rax
  00109	48 85 c0	 test	 rax, rax
  0010c	75 2a		 jne	 SHORT $LN6@gpc_add_co
  0010e	e8 00 00 00 00	 call	 __iob_func
  00113	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BB@DMABKBKA@contour?5addition?$AA@
  0011a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@GBJAADOD@gpc?5malloc?5failure?3?5?$CFs?6?$AA@
  00121	48 8d 48 60	 lea	 rcx, QWORD PTR [rax+96]
  00125	e8 00 00 00 00	 call	 fprintf
  0012a	33 c9		 xor	 ecx, ecx
  0012c	e8 00 00 00 00	 call	 exit
  00131	cc		 int	 3
$LN8@gpc_add_co:
  00132	48 83 64 f7 08
	00		 and	 QWORD PTR [rdi+rsi*8+8], 0
$LN6@gpc_add_co:

; 1128 :   for (v= 0; v < new_contour->num_vertices; v++)

  00138	45 33 c0	 xor	 r8d, r8d
  0013b	45 39 45 00	 cmp	 DWORD PTR [r13], r8d
  0013f	7e 25		 jle	 SHORT $LN3@gpc_add_co
  00141	4d 03 e4	 add	 r12, r12
  00144	33 d2		 xor	 edx, edx
$LL5@gpc_add_co:

; 1129 :     extended_contour[c].vertex[v]= new_contour->vertex[v];

  00146	49 8b 45 08	 mov	 rax, QWORD PTR [r13+8]
  0014a	4a 8b 4c e7 08	 mov	 rcx, QWORD PTR [rdi+r12*8+8]
  0014f	41 ff c0	 inc	 r8d
  00152	f3 0f 6f 04 02	 movdqu	 xmm0, XMMWORD PTR [rdx+rax]
  00157	f3 0f 7f 04 11	 movdqu	 XMMWORD PTR [rcx+rdx], xmm0
  0015c	48 83 c2 10	 add	 rdx, 16
  00160	45 3b 45 00	 cmp	 r8d, DWORD PTR [r13]
  00164	7c e0		 jl	 SHORT $LL5@gpc_add_co
$LN3@gpc_add_co:

; 1130 : 
; 1131 :   /* Dispose of the old contour */
; 1132 :   FREE(p->contour);

  00166	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  0016a	48 85 c9	 test	 rcx, rcx
  0016d	74 0a		 je	 SHORT $LN2@gpc_add_co
  0016f	e8 00 00 00 00	 call	 free
  00174	48 83 63 10 00	 and	 QWORD PTR [rbx+16], 0
$LN2@gpc_add_co:

; 1133 :   FREE(p->hole);

  00179	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
  0017d	48 85 c9	 test	 rcx, rcx
  00180	74 0a		 je	 SHORT $LN1@gpc_add_co
  00182	e8 00 00 00 00	 call	 free
  00187	48 83 63 08 00	 and	 QWORD PTR [rbx+8], 0
$LN1@gpc_add_co:

; 1134 : 
; 1135 :   /* Update the polygon information */
; 1136 :   p->num_contours++;

  0018c	ff 03		 inc	 DWORD PTR [rbx]

; 1137 :   p->hole= extended_hole;
; 1138 :   p->contour= extended_contour;
; 1139 : }

  0018e	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  00193	48 89 6b 08	 mov	 QWORD PTR [rbx+8], rbp
  00197	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  0019c	48 89 7b 10	 mov	 QWORD PTR [rbx+16], rdi
  001a0	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  001a5	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001a9	41 5d		 pop	 r13
  001ab	41 5c		 pop	 r12
  001ad	5f		 pop	 rdi
  001ae	c3		 ret	 0
$LN24@gpc_add_co:
gpc_add_contour ENDP
_TEXT	ENDS
PUBLIC	gpc_free_polygon
;	COMDAT pdata
pdata	SEGMENT
$pdata$gpc_free_polygon DD imagerel $LN11
	DD	imagerel $LN11+122
	DD	imagerel $unwind$gpc_free_polygon
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gpc_free_polygon DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT gpc_free_polygon
_TEXT	SEGMENT
p$ = 48
gpc_free_polygon PROC					; COMDAT

; 1042 : {

$LN11:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1043 :   int c;
; 1044 : 
; 1045 :   for (c= 0; c < p->num_contours; c++)

  0000f	33 f6		 xor	 esi, esi
  00011	48 8b d9	 mov	 rbx, rcx
  00014	39 31		 cmp	 DWORD PTR [rcx], esi
  00016	7e 29		 jle	 SHORT $LN4@gpc_free_p
  00018	33 ff		 xor	 edi, edi
$LL6@gpc_free_p:

; 1046 :     FREE(p->contour[c].vertex);

  0001a	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  0001e	48 8b 4c 38 08	 mov	 rcx, QWORD PTR [rax+rdi+8]
  00023	48 85 c9	 test	 rcx, rcx
  00026	74 0f		 je	 SHORT $LN5@gpc_free_p
  00028	e8 00 00 00 00	 call	 free
  0002d	4c 8b 5b 10	 mov	 r11, QWORD PTR [rbx+16]
  00031	49 83 64 3b 08
	00		 and	 QWORD PTR [r11+rdi+8], 0
$LN5@gpc_free_p:
  00037	ff c6		 inc	 esi
  00039	48 83 c7 10	 add	 rdi, 16
  0003d	3b 33		 cmp	 esi, DWORD PTR [rbx]
  0003f	7c d9		 jl	 SHORT $LL6@gpc_free_p
$LN4@gpc_free_p:

; 1047 :   FREE(p->hole);

  00041	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
  00045	48 85 c9	 test	 rcx, rcx
  00048	74 0a		 je	 SHORT $LN2@gpc_free_p
  0004a	e8 00 00 00 00	 call	 free
  0004f	48 83 63 08 00	 and	 QWORD PTR [rbx+8], 0
$LN2@gpc_free_p:

; 1048 :   FREE(p->contour);

  00054	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  00058	48 85 c9	 test	 rcx, rcx
  0005b	74 0a		 je	 SHORT $LN1@gpc_free_p
  0005d	e8 00 00 00 00	 call	 free
  00062	48 83 63 10 00	 and	 QWORD PTR [rbx+16], 0
$LN1@gpc_free_p:

; 1049 :   p->num_contours= 0;

  00067	83 23 00	 and	 DWORD PTR [rbx], 0

; 1050 : }

  0006a	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0006f	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00074	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00078	5f		 pop	 rdi
  00079	c3		 ret	 0
gpc_free_polygon ENDP
_TEXT	ENDS
PUBLIC	__real@ffefffffffffffff
PUBLIC	__real@7fefffffffffffff
;	COMDAT pdata
pdata	SEGMENT
$pdata$create_contour_bboxes DD imagerel create_contour_bboxes
	DD	imagerel create_contour_bboxes+264
	DD	imagerel $unwind$create_contour_bboxes
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$create_contour_bboxes DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT __real@ffefffffffffffff
CONST	SEGMENT
__real@ffefffffffffffff DQ 0ffefffffffffffffr	; -1.79769e+308
CONST	ENDS
;	COMDAT __real@7fefffffffffffff
CONST	SEGMENT
__real@7fefffffffffffff DQ 07fefffffffffffffr	; 1.79769e+308
; Function compile flags: /Ogspy
CONST	ENDS
;	COMDAT create_contour_bboxes
_TEXT	SEGMENT
p$ = 48
create_contour_bboxes PROC				; COMDAT

; 950  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 951  :   bbox *box;
; 952  :   int   c, v;
; 953  : 
; 954  :   MALLOC(box, p->num_contours * sizeof(bbox), "Bounding box creation", bbox);

  00009	48 63 09	 movsxd	 rcx, DWORD PTR [rcx]
  0000c	48 c1 e1 05	 shl	 rcx, 5
  00010	48 85 c9	 test	 rcx, rcx
  00013	74 2e		 je	 SHORT $LN13@create_con
  00015	e8 00 00 00 00	 call	 malloc
  0001a	48 85 c0	 test	 rax, rax
  0001d	75 26		 jne	 SHORT $LN11@create_con
  0001f	e8 00 00 00 00	 call	 __iob_func
  00024	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BG@CIAEENND@Bounding?5box?5creation?$AA@
  0002b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@GBJAADOD@gpc?5malloc?5failure?3?5?$CFs?6?$AA@
  00032	48 8d 48 60	 lea	 rcx, QWORD PTR [rax+96]
  00036	e8 00 00 00 00	 call	 fprintf
  0003b	33 c9		 xor	 ecx, ecx
  0003d	e8 00 00 00 00	 call	 exit
  00042	cc		 int	 3
$LN13@create_con:
  00043	33 c0		 xor	 eax, eax
$LN11@create_con:

; 955  : 
; 956  :   /* Construct contour bounding boxes */
; 957  :   for (c= 0; c < p->num_contours; c++)

  00045	83 3b 00	 cmp	 DWORD PTR [rbx], 0
  00048	0f 8e b4 00 00
	00		 jle	 $LN8@create_con
  0004e	48 8b 53 10	 mov	 rdx, QWORD PTR [rbx+16]
  00052	44 8b 03	 mov	 r8d, DWORD PTR [rbx]
  00055	48 8d 48 10	 lea	 rcx, QWORD PTR [rax+16]
  00059	48 bb ff ff ff
	ff ff ff ef ff	 mov	 rbx, -4503599627370497	; ffefffffffffffffH
  00063	49 bb ff ff ff
	ff ff ff ef 7f	 mov	 r11, 9218868437227405311 ; 7fefffffffffffffH
$LL10@create_con:

; 958  :   {
; 959  :     /* Initialise bounding box extent */
; 960  :     box[c].xmin= DBL_MAX;
; 961  :     box[c].ymin= DBL_MAX;
; 962  :     box[c].xmax= -DBL_MAX;
; 963  :     box[c].ymax= -DBL_MAX;
; 964  : 
; 965  :     for (v= 0; v < p->contour[c].num_vertices; v++)

  0006d	83 3a 00	 cmp	 DWORD PTR [rdx], 0
  00070	4c 89 59 f0	 mov	 QWORD PTR [rcx-16], r11
  00074	4c 89 59 f8	 mov	 QWORD PTR [rcx-8], r11
  00078	48 89 19	 mov	 QWORD PTR [rcx], rbx
  0007b	48 89 59 08	 mov	 QWORD PTR [rcx+8], rbx
  0007f	7e 6f		 jle	 SHORT $LN9@create_con
  00081	f2 0f 10 15 00
	00 00 00	 movsdx	 xmm2, QWORD PTR __real@7fefffffffffffff
  00089	f2 0f 10 2d 00
	00 00 00	 movsdx	 xmm5, QWORD PTR __real@ffefffffffffffff
  00091	4c 8b 4a 08	 mov	 r9, QWORD PTR [rdx+8]
  00095	44 8b 12	 mov	 r10d, DWORD PTR [rdx]
  00098	66 0f 28 e2	 movapd	 xmm4, xmm2
  0009c	66 0f 28 dd	 movapd	 xmm3, xmm5
$LL7@create_con:

; 966  :     {
; 967  :       /* Adjust bounding box */
; 968  :       if (p->contour[c].vertex[v].x < box[c].xmin)

  000a0	f2 41 0f 10 01	 movsdx	 xmm0, QWORD PTR [r9]
  000a5	66 0f 2f d0	 comisd	 xmm2, xmm0
  000a9	76 04		 jbe	 SHORT $LN4@create_con

; 969  :         box[c].xmin= p->contour[c].vertex[v].x;

  000ab	66 0f 28 d0	 movapd	 xmm2, xmm0
$LN4@create_con:

; 970  :       if (p->contour[c].vertex[v].y < box[c].ymin)

  000af	f2 41 0f 10 49
	08		 movsdx	 xmm1, QWORD PTR [r9+8]
  000b5	66 0f 2f e1	 comisd	 xmm4, xmm1
  000b9	76 04		 jbe	 SHORT $LN3@create_con

; 958  :   {
; 959  :     /* Initialise bounding box extent */
; 960  :     box[c].xmin= DBL_MAX;
; 961  :     box[c].ymin= DBL_MAX;
; 962  :     box[c].xmax= -DBL_MAX;
; 963  :     box[c].ymax= -DBL_MAX;
; 964  : 
; 965  :     for (v= 0; v < p->contour[c].num_vertices; v++)

  000bb	66 0f 28 e1	 movapd	 xmm4, xmm1
$LN3@create_con:

; 971  :         box[c].ymin= p->contour[c].vertex[v].y;
; 972  :       if (p->contour[c].vertex[v].x > box[c].xmax)

  000bf	66 0f 2f c5	 comisd	 xmm0, xmm5
  000c3	76 04		 jbe	 SHORT $LN2@create_con

; 973  :         box[c].xmax= p->contour[c].vertex[v].x;

  000c5	66 0f 28 e8	 movapd	 xmm5, xmm0
$LN2@create_con:

; 974  :       if (p->contour[c].vertex[v].y > box[c].ymax)

  000c9	66 0f 2f cb	 comisd	 xmm1, xmm3
  000cd	76 04		 jbe	 SHORT $LN6@create_con

; 958  :   {
; 959  :     /* Initialise bounding box extent */
; 960  :     box[c].xmin= DBL_MAX;
; 961  :     box[c].ymin= DBL_MAX;
; 962  :     box[c].xmax= -DBL_MAX;
; 963  :     box[c].ymax= -DBL_MAX;
; 964  : 
; 965  :     for (v= 0; v < p->contour[c].num_vertices; v++)

  000cf	66 0f 28 d9	 movapd	 xmm3, xmm1
$LN6@create_con:
  000d3	49 83 c1 10	 add	 r9, 16
  000d7	49 83 ea 01	 sub	 r10, 1
  000db	75 c3		 jne	 SHORT $LL7@create_con
  000dd	f2 0f 11 51 f0	 movsdx	 QWORD PTR [rcx-16], xmm2
  000e2	f2 0f 11 61 f8	 movsdx	 QWORD PTR [rcx-8], xmm4
  000e7	f2 0f 11 29	 movsdx	 QWORD PTR [rcx], xmm5
  000eb	f2 0f 11 59 08	 movsdx	 QWORD PTR [rcx+8], xmm3
$LN9@create_con:
  000f0	48 83 c2 10	 add	 rdx, 16
  000f4	48 83 c1 20	 add	 rcx, 32			; 00000020H
  000f8	49 83 e8 01	 sub	 r8, 1
  000fc	0f 85 6b ff ff
	ff		 jne	 $LL10@create_con
$LN8@create_con:

; 975  :           box[c].ymax= p->contour[c].vertex[v].y;
; 976  :     }
; 977  :   }
; 978  :   return box;  
; 979  : }

  00102	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00106	5b		 pop	 rbx
  00107	c3		 ret	 0
$LN20@create_con:
create_contour_bboxes ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$add_local_min DD imagerel add_local_min
	DD	imagerel add_local_min+224
	DD	imagerel $unwind$add_local_min
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$add_local_min DD 0c2201H
	DD	027822H
	DD	03681bH
	DD	0c6414H
	DD	0b5414H
	DD	0a3414H
	DD	070107214H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT add_local_min
_TEXT	SEGMENT
p$ = 80
edge$ = 88
x$ = 96
y$ = 104
add_local_min PROC					; COMDAT

; 876  : {

  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 68 10	 mov	 QWORD PTR [rax+16], rbp
  0000b	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 877  :   polygon_node *existing_min;
; 878  :   vertex_node  *nv;
; 879  : 
; 880  :   existing_min= *p;

  00014	48 8b 29	 mov	 rbp, QWORD PTR [rcx]
  00017	0f 29 70 e8	 movaps	 XMMWORD PTR [rax-24], xmm6
  0001b	48 8b d9	 mov	 rbx, rcx
  0001e	0f 29 78 d8	 movaps	 XMMWORD PTR [rax-40], xmm7

; 881  : 
; 882  :   MALLOC(*p, sizeof(polygon_node), "polygon node creation", polygon_node);

  00022	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  00027	66 0f 28 f3	 movapd	 xmm6, xmm3
  0002b	66 0f 28 fa	 movapd	 xmm7, xmm2
  0002f	48 8b f2	 mov	 rsi, rdx
  00032	e8 00 00 00 00	 call	 malloc
  00037	48 8b f8	 mov	 rdi, rax
  0003a	48 89 03	 mov	 QWORD PTR [rbx], rax
  0003d	48 85 c0	 test	 rax, rax
  00040	75 24		 jne	 SHORT $LN5@add_local_
  00042	e8 00 00 00 00	 call	 __iob_func
  00047	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BG@KDIMFLIB@polygon?5node?5creation?$AA@
  0004e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@GBJAADOD@gpc?5malloc?5failure?3?5?$CFs?6?$AA@
  00055	48 8d 48 60	 lea	 rcx, QWORD PTR [rax+96]
  00059	e8 00 00 00 00	 call	 fprintf
  0005e	33 c9		 xor	 ecx, ecx
  00060	e8 00 00 00 00	 call	 exit
  00065	cc		 int	 3
$LN5@add_local_:

; 883  : 
; 884  :   /* Create a new vertex node and set its fields */
; 885  :   MALLOC(nv, sizeof(vertex_node), "vertex node creation", vertex_node);

  00066	b9 18 00 00 00	 mov	 ecx, 24
  0006b	e8 00 00 00 00	 call	 malloc
  00070	48 85 c0	 test	 rax, rax
  00073	75 24		 jne	 SHORT $LN2@add_local_
  00075	e8 00 00 00 00	 call	 __iob_func
  0007a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BF@EBLPDDCK@vertex?5node?5creation?$AA@
  00081	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@GBJAADOD@gpc?5malloc?5failure?3?5?$CFs?6?$AA@
  00088	48 8d 48 60	 lea	 rcx, QWORD PTR [rax+96]
  0008c	e8 00 00 00 00	 call	 fprintf
  00091	33 c9		 xor	 ecx, ecx
  00093	e8 00 00 00 00	 call	 exit
  00098	cc		 int	 3
$LN2@add_local_:

; 886  :   nv->x= x;
; 887  :   nv->y= y;
; 888  :   nv->next= NULL;

  00099	48 83 60 10 00	 and	 QWORD PTR [rax+16], 0

; 889  : 
; 890  :   /* Initialise proxy to point to p itself */
; 891  :   (*p)->proxy= (*p);
; 892  :   (*p)->active= TRUE;
; 893  :   (*p)->next= existing_min;
; 894  : 
; 895  :   /* Make v[LEFT] and v[RIGHT] point to new vertex nv */
; 896  :   (*p)->v[LEFT]= nv;
; 897  :   (*p)->v[RIGHT]= nv;
; 898  : 
; 899  :   /* Assign polygon p to the edge */
; 900  :   edge->outp[ABOVE]= *p;
; 901  : }

  0009e	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  000a3	f2 0f 11 38	 movsdx	 QWORD PTR [rax], xmm7
  000a7	0f 28 7c 24 20	 movaps	 xmm7, XMMWORD PTR [rsp+32]
  000ac	f2 0f 11 70 08	 movsdx	 QWORD PTR [rax+8], xmm6
  000b1	48 89 7f 20	 mov	 QWORD PTR [rdi+32], rdi
  000b5	0f 28 74 24 30	 movaps	 xmm6, XMMWORD PTR [rsp+48]
  000ba	c7 07 01 00 00
	00		 mov	 DWORD PTR [rdi], 1
  000c0	48 89 6f 18	 mov	 QWORD PTR [rdi+24], rbp
  000c4	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  000c9	48 89 47 08	 mov	 QWORD PTR [rdi+8], rax
  000cd	48 89 47 10	 mov	 QWORD PTR [rdi+16], rax
  000d1	48 89 7e 70	 mov	 QWORD PTR [rsi+112], rdi
  000d5	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  000da	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000de	5f		 pop	 rdi
  000df	c3		 ret	 0
$LN9@add_local_:
add_local_min ENDP
; Function compile flags: /Ogspy
_TEXT	ENDS
;	COMDAT merge_right
_TEXT	SEGMENT
p$ = 8
q$ = 16
list$ = 24
merge_right PROC					; COMDAT

; 850  :   polygon_node *target;
; 851  : 
; 852  :   /* Label contour as external */
; 853  :   q->proxy->hole= FALSE;

  00000	48 8b 42 20	 mov	 rax, QWORD PTR [rdx+32]
  00004	4d 8b d0	 mov	 r10, r8
  00007	4c 8b d9	 mov	 r11, rcx
  0000a	83 60 04 00	 and	 DWORD PTR [rax+4], 0

; 854  : 
; 855  :   if (p->proxy != q->proxy)

  0000e	48 8b 42 20	 mov	 rax, QWORD PTR [rdx+32]
  00012	48 39 41 20	 cmp	 QWORD PTR [rcx+32], rax
  00016	74 41		 je	 SHORT $LN2@merge_righ

; 856  :   {
; 857  :     /* Assign p's vertex list to the right end of q's list */
; 858  :     q->proxy->v[RIGHT]->next= p->proxy->v[LEFT];

  00018	4c 8b 49 20	 mov	 r9, QWORD PTR [rcx+32]
  0001c	4c 8b 40 10	 mov	 r8, QWORD PTR [rax+16]
  00020	49 8b 41 08	 mov	 rax, QWORD PTR [r9+8]
  00024	49 89 40 10	 mov	 QWORD PTR [r8+16], rax

; 859  :     q->proxy->v[RIGHT]= p->proxy->v[RIGHT];

  00028	48 8b 41 20	 mov	 rax, QWORD PTR [rcx+32]
  0002c	48 8b 4a 20	 mov	 rcx, QWORD PTR [rdx+32]
  00030	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00034	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 860  : 
; 861  :     /* Redirect any p->proxy references to q->proxy */
; 862  :     for (target= p->proxy; list; list= list->next)

  00038	49 8b 4b 20	 mov	 rcx, QWORD PTR [r11+32]
  0003c	eb 16		 jmp	 SHORT $LN10@merge_righ
$LL4@merge_righ:

; 863  :     {
; 864  :       if (list->proxy == target)

  0003e	49 39 4a 20	 cmp	 QWORD PTR [r10+32], rcx
  00042	75 0c		 jne	 SHORT $LN3@merge_righ

; 865  :       {
; 866  :         list->active= FALSE;

  00044	41 83 22 00	 and	 DWORD PTR [r10], 0

; 867  :         list->proxy= q->proxy;

  00048	48 8b 42 20	 mov	 rax, QWORD PTR [rdx+32]
  0004c	49 89 42 20	 mov	 QWORD PTR [r10+32], rax
$LN3@merge_righ:

; 860  : 
; 861  :     /* Redirect any p->proxy references to q->proxy */
; 862  :     for (target= p->proxy; list; list= list->next)

  00050	4d 8b 52 18	 mov	 r10, QWORD PTR [r10+24]
$LN10@merge_righ:
  00054	4d 85 d2	 test	 r10, r10
  00057	75 e5		 jne	 SHORT $LL4@merge_righ
$LN2@merge_righ:

; 868  :       }
; 869  :     }
; 870  :   }
; 871  : }

  00059	f3 c3		 fatret	 0
merge_right ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$add_right DD imagerel add_right
	DD	imagerel add_right+131
	DD	imagerel $unwind$add_right
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$add_right DD 061801H
	DD	027818H
	DD	03680eH
	DD	030027206H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT add_right
_TEXT	SEGMENT
p$ = 80
x$ = 88
y$ = 96
add_right PROC						; COMDAT

; 831  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00006	48 8b d9	 mov	 rbx, rcx
  00009	0f 29 74 24 30	 movaps	 XMMWORD PTR [rsp+48], xmm6

; 832  :   vertex_node *nv;
; 833  : 
; 834  :   /* Create a new vertex node and set its fields */
; 835  :   MALLOC(nv, sizeof(vertex_node), "vertex node creation", vertex_node);

  0000e	b9 18 00 00 00	 mov	 ecx, 24
  00013	0f 29 7c 24 20	 movaps	 XMMWORD PTR [rsp+32], xmm7
  00018	66 0f 28 f2	 movapd	 xmm6, xmm2
  0001c	66 0f 28 f9	 movapd	 xmm7, xmm1
  00020	e8 00 00 00 00	 call	 malloc
  00025	4c 8b d8	 mov	 r11, rax
  00028	48 85 c0	 test	 rax, rax
  0002b	75 24		 jne	 SHORT $LN2@add_right
  0002d	e8 00 00 00 00	 call	 __iob_func
  00032	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BF@EBLPDDCK@vertex?5node?5creation?$AA@
  00039	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@GBJAADOD@gpc?5malloc?5failure?3?5?$CFs?6?$AA@
  00040	48 8d 48 60	 lea	 rcx, QWORD PTR [rax+96]
  00044	e8 00 00 00 00	 call	 fprintf
  00049	33 c9		 xor	 ecx, ecx
  0004b	e8 00 00 00 00	 call	 exit
  00050	cc		 int	 3
$LN2@add_right:

; 836  :   nv->x= x;
; 837  :   nv->y= y;
; 838  :   nv->next= NULL;

  00051	48 83 60 10 00	 and	 QWORD PTR [rax+16], 0
  00056	f2 0f 11 38	 movsdx	 QWORD PTR [rax], xmm7

; 839  : 
; 840  :   /* Add vertex nv to the right end of the polygon's vertex list */
; 841  :   p->proxy->v[RIGHT]->next= nv;
; 842  : 
; 843  :   /* Update proxy->v[RIGHT] to point to nv */
; 844  :   p->proxy->v[RIGHT]= nv;
; 845  : }

  0005a	0f 28 7c 24 20	 movaps	 xmm7, XMMWORD PTR [rsp+32]
  0005f	f2 0f 11 70 08	 movsdx	 QWORD PTR [rax+8], xmm6
  00064	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00068	0f 28 74 24 30	 movaps	 xmm6, XMMWORD PTR [rsp+48]
  0006d	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00071	4c 89 59 10	 mov	 QWORD PTR [rcx+16], r11
  00075	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00079	4c 89 58 10	 mov	 QWORD PTR [rax+16], r11
  0007d	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00081	5b		 pop	 rbx
  00082	c3		 ret	 0
$LN6@add_right:
add_right ENDP
; Function compile flags: /Ogspy
_TEXT	ENDS
;	COMDAT merge_left
_TEXT	SEGMENT
p$ = 8
q$ = 16
list$ = 24
merge_left PROC						; COMDAT

; 805  :   polygon_node *target;
; 806  : 
; 807  :   /* Label contour as a hole */
; 808  :   q->proxy->hole= TRUE;

  00000	48 8b 42 20	 mov	 rax, QWORD PTR [rdx+32]
  00004	4c 8b d9	 mov	 r11, rcx
  00007	c7 40 04 01 00
	00 00		 mov	 DWORD PTR [rax+4], 1

; 809  : 
; 810  :   if (p->proxy != q->proxy)

  0000e	48 8b 42 20	 mov	 rax, QWORD PTR [rdx+32]
  00012	48 39 41 20	 cmp	 QWORD PTR [rcx+32], rax
  00016	74 44		 je	 SHORT $LN2@merge_left

; 811  :   {
; 812  :     /* Assign p's vertex list to the left end of q's list */
; 813  :     p->proxy->v[RIGHT]->next= q->proxy->v[LEFT];

  00018	4c 8b d0	 mov	 r10, rax
  0001b	48 8b 41 20	 mov	 rax, QWORD PTR [rcx+32]
  0001f	4c 8b 48 10	 mov	 r9, QWORD PTR [rax+16]
  00023	49 8b 42 08	 mov	 rax, QWORD PTR [r10+8]
  00027	49 89 41 10	 mov	 QWORD PTR [r9+16], rax

; 814  :     q->proxy->v[LEFT]= p->proxy->v[LEFT];

  0002b	48 8b 41 20	 mov	 rax, QWORD PTR [rcx+32]
  0002f	48 8b 4a 20	 mov	 rcx, QWORD PTR [rdx+32]
  00033	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00037	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 815  : 
; 816  :     /* Redirect any p->proxy references to q->proxy */
; 817  :     
; 818  :     for (target= p->proxy; list; list= list->next)

  0003b	49 8b 4b 20	 mov	 rcx, QWORD PTR [r11+32]
  0003f	eb 16		 jmp	 SHORT $LN10@merge_left
$LL4@merge_left:

; 819  :     {
; 820  :       if (list->proxy == target)

  00041	49 39 48 20	 cmp	 QWORD PTR [r8+32], rcx
  00045	75 0c		 jne	 SHORT $LN3@merge_left

; 821  :       {
; 822  :         list->active= FALSE;

  00047	41 83 20 00	 and	 DWORD PTR [r8], 0

; 823  :         list->proxy= q->proxy;

  0004b	48 8b 42 20	 mov	 rax, QWORD PTR [rdx+32]
  0004f	49 89 40 20	 mov	 QWORD PTR [r8+32], rax
$LN3@merge_left:

; 815  : 
; 816  :     /* Redirect any p->proxy references to q->proxy */
; 817  :     
; 818  :     for (target= p->proxy; list; list= list->next)

  00053	4d 8b 40 18	 mov	 r8, QWORD PTR [r8+24]
$LN10@merge_left:
  00057	4d 85 c0	 test	 r8, r8
  0005a	75 e5		 jne	 SHORT $LL4@merge_left
$LN2@merge_left:

; 824  :       }
; 825  :     }
; 826  :   }
; 827  : }

  0005c	f3 c3		 fatret	 0
merge_left ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$add_left DD imagerel add_left
	DD	imagerel add_left+126
	DD	imagerel $unwind$add_left
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$add_left DD 061801H
	DD	027818H
	DD	03680eH
	DD	030027206H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT add_left
_TEXT	SEGMENT
p$ = 80
x$ = 88
y$ = 96
add_left PROC						; COMDAT

; 787  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00006	48 8b d9	 mov	 rbx, rcx
  00009	0f 29 74 24 30	 movaps	 XMMWORD PTR [rsp+48], xmm6

; 788  :   vertex_node *nv;
; 789  : 
; 790  :   /* Create a new vertex node and set its fields */
; 791  :   MALLOC(nv, sizeof(vertex_node), "vertex node creation", vertex_node);

  0000e	b9 18 00 00 00	 mov	 ecx, 24
  00013	0f 29 7c 24 20	 movaps	 XMMWORD PTR [rsp+32], xmm7
  00018	66 0f 28 f2	 movapd	 xmm6, xmm2
  0001c	66 0f 28 f9	 movapd	 xmm7, xmm1
  00020	e8 00 00 00 00	 call	 malloc
  00025	4c 8b d8	 mov	 r11, rax
  00028	48 85 c0	 test	 rax, rax
  0002b	75 24		 jne	 SHORT $LN2@add_left
  0002d	e8 00 00 00 00	 call	 __iob_func
  00032	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BF@EBLPDDCK@vertex?5node?5creation?$AA@
  00039	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@GBJAADOD@gpc?5malloc?5failure?3?5?$CFs?6?$AA@
  00040	48 8d 48 60	 lea	 rcx, QWORD PTR [rax+96]
  00044	e8 00 00 00 00	 call	 fprintf
  00049	33 c9		 xor	 ecx, ecx
  0004b	e8 00 00 00 00	 call	 exit
  00050	cc		 int	 3
$LN2@add_left:

; 792  :   nv->x= x;

  00051	f2 0f 11 38	 movsdx	 QWORD PTR [rax], xmm7

; 793  :   nv->y= y;
; 794  : 
; 795  :   /* Add vertex nv to the left end of the polygon's vertex list */
; 796  :   nv->next= p->proxy->v[LEFT];
; 797  : 
; 798  :   /* Update proxy->[LEFT] to point to nv */
; 799  :   p->proxy->v[LEFT]= nv;
; 800  : }

  00055	0f 28 7c 24 20	 movaps	 xmm7, XMMWORD PTR [rsp+32]
  0005a	f2 0f 11 70 08	 movsdx	 QWORD PTR [rax+8], xmm6
  0005f	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00063	0f 28 74 24 30	 movaps	 xmm6, XMMWORD PTR [rsp+48]
  00068	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0006c	49 89 4b 10	 mov	 QWORD PTR [r11+16], rcx
  00070	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00074	4c 89 58 08	 mov	 QWORD PTR [rax+8], r11
  00078	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0007c	5b		 pop	 rbx
  0007d	c3		 ret	 0
$LN6@add_left:
add_left ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$count_contours DD imagerel count_contours
	DD	imagerel count_contours+125
	DD	imagerel $unwind$count_contours
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$count_contours DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT count_contours
_TEXT	SEGMENT
polygon$ = 48
count_contours PROC					; COMDAT

; 753  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 754  :   int          nc, nv;
; 755  :   vertex_node *v, *nextv;
; 756  : 
; 757  :   for (nc= 0; polygon; polygon= polygon->next)

  0000f	33 f6		 xor	 esi, esi
  00011	48 8b f9	 mov	 rdi, rcx
  00014	48 85 c9	 test	 rcx, rcx
  00017	74 52		 je	 SHORT $LN11@count_cont
$LL13@count_cont:

; 758  :     if (polygon->active)

  00019	83 3f 00	 cmp	 DWORD PTR [rdi], 0
  0001c	74 44		 je	 SHORT $LN12@count_cont

; 759  :     {
; 760  :       /* Count the vertices in the current contour */
; 761  :       nv= 0;
; 762  :       for (v= polygon->proxy->v[LEFT]; v; v= v->next)

  0001e	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  00022	33 c9		 xor	 ecx, ecx
  00024	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00028	48 8b c2	 mov	 rax, rdx
  0002b	48 85 d2	 test	 rdx, rdx
  0002e	74 2f		 je	 SHORT $LN2@count_cont
$LL9@count_cont:
  00030	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]

; 763  :         nv++;

  00034	ff c1		 inc	 ecx
  00036	48 85 c0	 test	 rax, rax
  00039	75 f5		 jne	 SHORT $LL9@count_cont

; 764  : 
; 765  :       /* Record valid vertex counts in the active field */
; 766  :       if (nv > 2)

  0003b	83 f9 02	 cmp	 ecx, 2
  0003e	7e 06		 jle	 SHORT $LN6@count_cont

; 767  :       {
; 768  :         polygon->active= nv;

  00040	89 0f		 mov	 DWORD PTR [rdi], ecx

; 769  :         nc++;

  00042	ff c6		 inc	 esi

; 770  :       }
; 771  :       else

  00044	eb 1c		 jmp	 SHORT $LN12@count_cont
$LN6@count_cont:

; 772  :       {
; 773  :         /* Invalid contour: just free the heap */
; 774  :         for (v= polygon->proxy->v[LEFT]; v; v= nextv)

  00046	48 85 d2	 test	 rdx, rdx
  00049	74 14		 je	 SHORT $LN2@count_cont
$LL4@count_cont:

; 775  :         {
; 776  :           nextv= v->next;

  0004b	48 8b 5a 10	 mov	 rbx, QWORD PTR [rdx+16]

; 777  :           FREE(v);

  0004f	48 8b ca	 mov	 rcx, rdx
  00052	e8 00 00 00 00	 call	 free
  00057	48 8b d3	 mov	 rdx, rbx
  0005a	48 85 db	 test	 rbx, rbx
  0005d	75 ec		 jne	 SHORT $LL4@count_cont
$LN2@count_cont:

; 778  :         }
; 779  :         polygon->active= 0;

  0005f	83 27 00	 and	 DWORD PTR [rdi], 0
$LN12@count_cont:

; 754  :   int          nc, nv;
; 755  :   vertex_node *v, *nextv;
; 756  : 
; 757  :   for (nc= 0; polygon; polygon= polygon->next)

  00062	48 8b 7f 18	 mov	 rdi, QWORD PTR [rdi+24]
  00066	48 85 ff	 test	 rdi, rdi
  00069	75 ae		 jne	 SHORT $LL13@count_cont
$LN11@count_cont:

; 780  :       }
; 781  :     }
; 782  :   return nc;
; 783  : }

  0006b	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00070	8b c6		 mov	 eax, esi
  00072	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00077	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007b	5f		 pop	 rdi
  0007c	c3		 ret	 0
count_contours ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$add_intersection DD imagerel add_intersection
	DD	imagerel add_intersection+292
	DD	imagerel $unwind$add_intersection
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$add_intersection DD 0c2601H
	DD	027826H
	DD	03681cH
	DD	0c6414H
	DD	0b5414H
	DD	0a3414H
	DD	070107214H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT add_intersection
_TEXT	SEGMENT
it$ = 80
edge0$ = 88
edge1$ = 96
x$ = 104
y$ = 112
add_intersection PROC					; COMDAT

; 643  : {

  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 68 10	 mov	 QWORD PTR [rax+16], rbp
  0000b	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 644  :   it_node *existing_node;
; 645  : 
; 646  :   if (!*it)

  00014	48 83 39 00	 cmp	 QWORD PTR [rcx], 0
  00018	0f 29 70 e8	 movaps	 XMMWORD PTR [rax-24], xmm6
  0001c	f2 0f 10 74 24
	70		 movsdx	 xmm6, QWORD PTR y$[rsp]
  00022	0f 29 78 d8	 movaps	 XMMWORD PTR [rax-40], xmm7
  00026	49 8b f0	 mov	 rsi, r8
  00029	48 8b ea	 mov	 rbp, rdx
  0002c	66 0f 28 fb	 movapd	 xmm7, xmm3
  00030	48 8b d9	 mov	 rbx, rcx
  00033	74 18		 je	 SHORT $LN16@add_inters
$LL13@add_inters:

; 655  :   }
; 656  :   else
; 657  :   {
; 658  :     if ((*it)->point.y > y)

  00035	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00038	f2 0f 10 40 18	 movsdx	 xmm0, QWORD PTR [rax+24]
  0003d	66 0f 2f c6	 comisd	 xmm0, xmm6
  00041	77 44		 ja	 SHORT $LN17@add_inters

; 668  :     }
; 669  :     else
; 670  :       /* Head further down the list */
; 671  :       add_intersection(&((*it)->next), edge0, edge1, x, y);

  00043	48 8d 58 20	 lea	 rbx, QWORD PTR [rax+32]
  00047	48 83 3b 00	 cmp	 QWORD PTR [rbx], 0
  0004b	75 e8		 jne	 SHORT $LL13@add_inters
$LN16@add_inters:

; 647  :   {
; 648  :     /* Append a new node to the tail of the list */
; 649  :     MALLOC(*it, sizeof(it_node), "IT insertion", it_node);

  0004d	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  00052	e8 00 00 00 00	 call	 malloc
  00057	48 89 03	 mov	 QWORD PTR [rbx], rax
  0005a	48 85 c0	 test	 rax, rax
  0005d	0f 85 80 00 00
	00		 jne	 $LN8@add_inters
  00063	e8 00 00 00 00	 call	 __iob_func
  00068	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0N@IFBDNEFP@IT?5insertion?$AA@
  0006f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@GBJAADOD@gpc?5malloc?5failure?3?5?$CFs?6?$AA@
  00076	48 8d 48 60	 lea	 rcx, QWORD PTR [rax+96]
  0007a	e8 00 00 00 00	 call	 fprintf
  0007f	33 c9		 xor	 ecx, ecx
  00081	e8 00 00 00 00	 call	 exit
  00086	cc		 int	 3
$LN17@add_inters:

; 659  :     {
; 660  :       /* Insert a new node mid-list */
; 661  :       existing_node= *it;
; 662  :       MALLOC(*it, sizeof(it_node), "IT insertion", it_node);

  00087	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  0008c	48 8b f8	 mov	 rdi, rax
  0008f	e8 00 00 00 00	 call	 malloc
  00094	48 89 03	 mov	 QWORD PTR [rbx], rax
  00097	48 85 c0	 test	 rax, rax
  0009a	75 24		 jne	 SHORT $LN3@add_inters
  0009c	e8 00 00 00 00	 call	 __iob_func
  000a1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0N@IFBDNEFP@IT?5insertion?$AA@
  000a8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@GBJAADOD@gpc?5malloc?5failure?3?5?$CFs?6?$AA@
  000af	48 8d 48 60	 lea	 rcx, QWORD PTR [rax+96]
  000b3	e8 00 00 00 00	 call	 fprintf
  000b8	33 c9		 xor	 ecx, ecx
  000ba	e8 00 00 00 00	 call	 exit
  000bf	cc		 int	 3
$LN3@add_inters:

; 663  :       (*it)->ie[0]= edge0;

  000c0	48 89 28	 mov	 QWORD PTR [rax], rbp

; 664  :       (*it)->ie[1]= edge1;

  000c3	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  000c6	48 89 70 08	 mov	 QWORD PTR [rax+8], rsi

; 665  :       (*it)->point.x= x;

  000ca	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  000cd	f2 0f 11 78 10	 movsdx	 QWORD PTR [rax+16], xmm7

; 666  :       (*it)->point.y= y;

  000d2	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  000d5	f2 0f 11 70 18	 movsdx	 QWORD PTR [rax+24], xmm6

; 667  :       (*it)->next= existing_node;

  000da	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  000dd	48 89 78 20	 mov	 QWORD PTR [rax+32], rdi
  000e1	eb 22		 jmp	 SHORT $LN1@add_inters
$LN8@add_inters:

; 650  :     (*it)->ie[0]= edge0;

  000e3	48 89 28	 mov	 QWORD PTR [rax], rbp

; 651  :     (*it)->ie[1]= edge1;

  000e6	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  000e9	48 89 70 08	 mov	 QWORD PTR [rax+8], rsi

; 652  :     (*it)->point.x= x;

  000ed	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  000f0	f2 0f 11 78 10	 movsdx	 QWORD PTR [rax+16], xmm7

; 653  :     (*it)->point.y= y;

  000f5	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  000f8	f2 0f 11 70 18	 movsdx	 QWORD PTR [rax+24], xmm6

; 654  :     (*it)->next= NULL;

  000fd	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00100	48 83 60 20 00	 and	 QWORD PTR [rax+32], 0
$LN1@add_inters:

; 672  :   }
; 673  : }

  00105	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  0010a	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  0010f	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  00114	0f 28 74 24 30	 movaps	 xmm6, XMMWORD PTR [rsp+48]
  00119	0f 28 7c 24 20	 movaps	 xmm7, XMMWORD PTR [rsp+32]
  0011e	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00122	5f		 pop	 rdi
  00123	c3		 ret	 0
$LN19@add_inters:
add_intersection ENDP
; Function compile flags: /Ogspy
_TEXT	ENDS
;	COMDAT add_edge_to_aet
_TEXT	SEGMENT
aet$ = 8
edge$ = 16
prev$ = 24
add_edge_to_aet PROC					; COMDAT

; 594  :   if (!*aet)
; 595  :   {
; 596  :     /* Append edge onto the tail end of the AET */
; 597  :     *aet= edge;
; 598  :     edge->prev= prev;
; 599  :     edge->next= NULL;
; 600  :   }
; 601  :   else
; 602  :   {
; 603  :     /* Do primary sort on the xb field */
; 604  :     if (edge->xb < (*aet)->xb)

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00003	f2 0f 10 4a 30	 movsdx	 xmm1, QWORD PTR [rdx+48]
  00008	f2 0f 10 40 30	 movsdx	 xmm0, QWORD PTR [rax+48]
  0000d	66 0f 2f c1	 comisd	 xmm0, xmm1
  00011	77 38		 ja	 SHORT $LN43@add_edge_t
  00013	45 33 c9	 xor	 r9d, r9d
$LL40@add_edge_t:

; 611  :     }
; 612  :     else
; 613  :     {
; 614  :       if (edge->xb == (*aet)->xb)

  00016	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00019	66 0f 2e 48 30	 ucomisd xmm1, QWORD PTR [rax+48]
  0001e	7a 0e		 jp	 SHORT $LN4@add_edge_t
  00020	75 0c		 jne	 SHORT $LN4@add_edge_t

; 615  :       {
; 616  :         /* Do secondary sort on the dx field */
; 617  :         if (edge->dx < (*aet)->dx)

  00022	f2 0f 10 40 40	 movsdx	 xmm0, QWORD PTR [rax+64]
  00027	66 0f 2f 42 40	 comisd	 xmm0, QWORD PTR [rdx+64]
  0002c	77 1d		 ja	 SHORT $LN43@add_edge_t
$LN4@add_edge_t:

; 618  :         {
; 619  :           /* Insert edge here (before the AET edge) */
; 620  :           edge->prev= prev;
; 621  :           edge->next= *aet;
; 622  :           (*aet)->prev= edge;
; 623  :           *aet= edge;
; 624  :         }
; 625  :         else
; 626  :         {
; 627  :           /* Head further into the AET */
; 628  :           add_edge_to_aet(&((*aet)->next), edge, *aet);
; 629  :         }
; 630  :       }
; 631  :       else
; 632  :       {
; 633  :         /* Head further into the AET */
; 634  :         add_edge_to_aet(&((*aet)->next), edge, *aet);

  0002e	48 8d 88 88 00
	00 00		 lea	 rcx, QWORD PTR [rax+136]
  00035	4c 8b c0	 mov	 r8, rax
  00038	4c 39 09	 cmp	 QWORD PTR [rcx], r9
  0003b	74 2d		 je	 SHORT $LN46@add_edge_t
  0003d	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00040	f2 0f 10 40 30	 movsdx	 xmm0, QWORD PTR [rax+48]
  00045	66 0f 2f c1	 comisd	 xmm0, xmm1
  00049	76 cb		 jbe	 SHORT $LL40@add_edge_t
$LN43@add_edge_t:

; 605  :     {
; 606  :       /* Insert edge here (before the AET edge) */
; 607  :       edge->prev= prev;

  0004b	4c 89 82 80 00
	00 00		 mov	 QWORD PTR [rdx+128], r8

; 608  :       edge->next= *aet;

  00052	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00055	48 89 82 88 00
	00 00		 mov	 QWORD PTR [rdx+136], rax

; 609  :       (*aet)->prev= edge;

  0005c	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  0005f	48 89 90 80 00
	00 00		 mov	 QWORD PTR [rax+128], rdx

; 610  :       *aet= edge;

  00066	48 89 11	 mov	 QWORD PTR [rcx], rdx

; 635  :       }
; 636  :     }
; 637  :   }
; 638  : }

  00069	c3		 ret	 0
$LN46@add_edge_t:

; 618  :         {
; 619  :           /* Insert edge here (before the AET edge) */
; 620  :           edge->prev= prev;
; 621  :           edge->next= *aet;
; 622  :           (*aet)->prev= edge;
; 623  :           *aet= edge;
; 624  :         }
; 625  :         else
; 626  :         {
; 627  :           /* Head further into the AET */
; 628  :           add_edge_to_aet(&((*aet)->next), edge, *aet);
; 629  :         }
; 630  :       }
; 631  :       else
; 632  :       {
; 633  :         /* Head further into the AET */
; 634  :         add_edge_to_aet(&((*aet)->next), edge, *aet);

  0006a	48 89 11	 mov	 QWORD PTR [rcx], rdx
  0006d	4c 89 8a 88 00
	00 00		 mov	 QWORD PTR [rdx+136], r9
  00074	48 89 82 80 00
	00 00		 mov	 QWORD PTR [rdx+128], rax

; 635  :       }
; 636  :     }
; 637  :   }
; 638  : }

  0007b	c3		 ret	 0
add_edge_to_aet ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$count_optimal_vertices DD imagerel count_optimal_vertices
	DD	imagerel count_optimal_vertices+113
	DD	imagerel $unwind$count_optimal_vertices
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$count_optimal_vertices DD 020501H
	DD	013405H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT count_optimal_vertices
_TEXT	SEGMENT
c$ = 8
count_optimal_vertices PROC				; COMDAT

; 433  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx

; 434  :   int result= 0, i;
; 435  : 
; 436  :   /* Ignore non-contributing contours */
; 437  :   if (c.num_vertices > 0)

  00005	44 8b 09	 mov	 r9d, DWORD PTR [rcx]
  00008	45 33 c0	 xor	 r8d, r8d
  0000b	45 3b c8	 cmp	 r9d, r8d
  0000e	7e 58		 jle	 SHORT $LN3@count_opti
  00010	48 8b 59 08	 mov	 rbx, QWORD PTR [rcx+8]

; 438  :   {
; 439  :     for (i= 0; i < c.num_vertices; i++)

  00014	45 8b d0	 mov	 r10d, r8d
  00017	41 8d 49 ff	 lea	 ecx, DWORD PTR [r9-1]
  0001b	4c 8d 5b 08	 lea	 r11, QWORD PTR [rbx+8]
$LL5@count_opti:

; 440  :       /* Ignore superfluous vertices embedded in horizontal edges */
; 441  :       if (OPTIMAL(c.vertex, i, c.num_vertices))

  0001f	8b c1		 mov	 eax, ecx
  00021	99		 cdq
  00022	41 f7 f9	 idiv	 r9d
  00025	48 63 c2	 movsxd	 rax, edx
  00028	48 03 c0	 add	 rax, rax
  0002b	f2 0f 10 44 c3
	08		 movsdx	 xmm0, QWORD PTR [rbx+rax*8+8]
  00031	66 41 0f 2e 03	 ucomisd xmm0, QWORD PTR [r11]
  00036	7a 1f		 jp	 SHORT $LN11@count_opti
  00038	75 1d		 jne	 SHORT $LN11@count_opti
  0003a	41 8d 42 01	 lea	 eax, DWORD PTR [r10+1]
  0003e	99		 cdq
  0003f	41 f7 f9	 idiv	 r9d
  00042	48 63 c2	 movsxd	 rax, edx
  00045	48 03 c0	 add	 rax, rax
  00048	f2 0f 10 44 c3
	08		 movsdx	 xmm0, QWORD PTR [rbx+rax*8+8]
  0004e	66 41 0f 2e 03	 ucomisd xmm0, QWORD PTR [r11]
  00053	7a 02		 jp	 SHORT $LN11@count_opti
  00055	74 03		 je	 SHORT $LN4@count_opti
$LN11@count_opti:

; 442  :         result++;

  00057	41 ff c0	 inc	 r8d
$LN4@count_opti:

; 438  :   {
; 439  :     for (i= 0; i < c.num_vertices; i++)

  0005a	41 ff c2	 inc	 r10d
  0005d	ff c1		 inc	 ecx
  0005f	49 83 c3 10	 add	 r11, 16
  00063	45 3b d1	 cmp	 r10d, r9d
  00066	7c b7		 jl	 SHORT $LL5@count_opti
$LN3@count_opti:

; 443  :   }
; 444  :   return result;
; 445  : }

  00068	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  0006d	41 8b c0	 mov	 eax, r8d
  00070	c3		 ret	 0
count_optimal_vertices ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$free_sbtree DD imagerel free_sbtree
	DD	imagerel free_sbtree+61
	DD	imagerel $unwind$free_sbtree
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$free_sbtree DD 020601H
	DD	030023206H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT free_sbtree
_TEXT	SEGMENT
sbtree$ = 48
free_sbtree PROC					; COMDAT

; 422  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 423  :   if (*sbtree)

  00009	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0000c	48 85 c9	 test	 rcx, rcx
  0000f	74 26		 je	 SHORT $LN1@free_sbtre

; 424  :   {
; 425  :     free_sbtree(&((*sbtree)->less));

  00011	48 83 c1 08	 add	 rcx, 8
  00015	e8 00 00 00 00	 call	 free_sbtree

; 426  :     free_sbtree(&((*sbtree)->more));

  0001a	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  0001d	48 83 c1 10	 add	 rcx, 16
  00021	e8 00 00 00 00	 call	 free_sbtree

; 427  :     FREE(*sbtree);

  00026	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00029	48 85 c9	 test	 rcx, rcx
  0002c	74 09		 je	 SHORT $LN1@free_sbtre
  0002e	e8 00 00 00 00	 call	 free
  00033	48 83 23 00	 and	 QWORD PTR [rbx], 0
$LN1@free_sbtre:

; 428  :   }
; 429  : }

  00037	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003b	5b		 pop	 rbx
  0003c	c3		 ret	 0
free_sbtree ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$build_sbt DD imagerel build_sbt
	DD	imagerel build_sbt+81
	DD	imagerel $unwind$build_sbt
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$build_sbt DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT build_sbt
_TEXT	SEGMENT
entries$ = 48
sbt$ = 56
sbtree$ = 64
build_sbt PROC						; COMDAT

; 411  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	49 8b d8	 mov	 rbx, r8
  00012	48 8b f2	 mov	 rsi, rdx
  00015	48 8b f9	 mov	 rdi, rcx
$LL5@build_sbt:

; 412  :   if (sbtree->less)

  00018	4c 8b 43 08	 mov	 r8, QWORD PTR [rbx+8]
  0001c	4d 85 c0	 test	 r8, r8
  0001f	74 0b		 je	 SHORT $LN2@build_sbt

; 413  :     build_sbt(entries, sbt, sbtree->less);

  00021	48 8b d6	 mov	 rdx, rsi
  00024	48 8b cf	 mov	 rcx, rdi
  00027	e8 00 00 00 00	 call	 build_sbt
$LN2@build_sbt:

; 414  :   sbt[*entries]= sbtree->y;

  0002c	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0002f	48 63 0f	 movsxd	 rcx, DWORD PTR [rdi]
  00032	48 89 04 ce	 mov	 QWORD PTR [rsi+rcx*8], rax

; 415  :   (*entries)++;

  00036	ff 07		 inc	 DWORD PTR [rdi]

; 416  :   if (sbtree->more)

  00038	48 8b 5b 10	 mov	 rbx, QWORD PTR [rbx+16]
  0003c	48 85 db	 test	 rbx, rbx

; 417  :     build_sbt(entries, sbt, sbtree->more);

  0003f	75 d7		 jne	 SHORT $LL5@build_sbt

; 418  : }

  00041	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00046	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0004b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004f	5f		 pop	 rdi
  00050	c3		 ret	 0
build_sbt ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$add_to_sbtree DD imagerel add_to_sbtree
	DD	imagerel add_to_sbtree+158
	DD	imagerel $unwind$add_to_sbtree
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$add_to_sbtree DD 061301H
	DD	026813H
	DD	08340aH
	DD	07006520aH
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT add_to_sbtree
_TEXT	SEGMENT
entries$ = 64
sbtree$ = 72
y$ = 80
add_to_sbtree PROC					; COMDAT

; 381  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 382  :   if (!*sbtree)

  0000a	48 83 3a 00	 cmp	 QWORD PTR [rdx], 0
  0000e	0f 29 74 24 20	 movaps	 XMMWORD PTR [rsp+32], xmm6
  00013	48 8b da	 mov	 rbx, rdx
  00016	66 0f 28 f2	 movapd	 xmm6, xmm2
  0001a	48 8b f9	 mov	 rdi, rcx
  0001d	74 23		 je	 SHORT $LN13@add_to_sbt
$LL11@add_to_sbt:

; 390  :   }
; 391  :   else
; 392  :   {
; 393  :     if ((*sbtree)->y > y)

  0001f	48 8b 1b	 mov	 rbx, QWORD PTR [rbx]
  00022	f2 0f 10 03	 movsdx	 xmm0, QWORD PTR [rbx]
  00026	66 0f 2f c2	 comisd	 xmm0, xmm2
  0002a	76 06		 jbe	 SHORT $LN3@add_to_sbt

; 394  :     {
; 395  :     /* Head into the 'less' sub-tree */
; 396  :       add_to_sbtree(entries, &((*sbtree)->less), y);

  0002c	48 83 c3 08	 add	 rbx, 8
  00030	eb 0a		 jmp	 SHORT $LN14@add_to_sbt
$LN3@add_to_sbt:

; 397  :     }
; 398  :     else
; 399  :     {
; 400  :       if ((*sbtree)->y < y)

  00032	66 0f 2f d0	 comisd	 xmm2, xmm0
  00036	76 56		 jbe	 SHORT $LN1@add_to_sbt

; 401  :       {
; 402  :         /* Head into the 'more' sub-tree */
; 403  :         add_to_sbtree(entries, &((*sbtree)->more), y);

  00038	48 83 c3 10	 add	 rbx, 16
$LN14@add_to_sbt:

; 382  :   if (!*sbtree)

  0003c	48 83 3b 00	 cmp	 QWORD PTR [rbx], 0
  00040	75 dd		 jne	 SHORT $LL11@add_to_sbt
$LN13@add_to_sbt:

; 383  :   {
; 384  :     /* Add a new tree node here */
; 385  :     MALLOC(*sbtree, sizeof(sb_tree), "scanbeam tree insertion", sb_tree);

  00042	b9 18 00 00 00	 mov	 ecx, 24
  00047	e8 00 00 00 00	 call	 malloc
  0004c	48 89 03	 mov	 QWORD PTR [rbx], rax
  0004f	48 85 c0	 test	 rax, rax
  00052	75 24		 jne	 SHORT $LN6@add_to_sbt
  00054	e8 00 00 00 00	 call	 __iob_func
  00059	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BI@KNFEDHGK@scanbeam?5tree?5insertion?$AA@
  00060	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@GBJAADOD@gpc?5malloc?5failure?3?5?$CFs?6?$AA@
  00067	48 8d 48 60	 lea	 rcx, QWORD PTR [rax+96]
  0006b	e8 00 00 00 00	 call	 fprintf
  00070	33 c9		 xor	 ecx, ecx
  00072	e8 00 00 00 00	 call	 exit
  00077	cc		 int	 3
$LN6@add_to_sbt:

; 386  :     (*sbtree)->y= y;

  00078	f2 0f 11 30	 movsdx	 QWORD PTR [rax], xmm6

; 387  :     (*sbtree)->less= NULL;

  0007c	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0007f	48 83 60 08 00	 and	 QWORD PTR [rax+8], 0

; 388  :     (*sbtree)->more= NULL;

  00084	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00087	48 83 60 10 00	 and	 QWORD PTR [rax+16], 0

; 389  :     (*entries)++;

  0008c	ff 07		 inc	 DWORD PTR [rdi]
$LN1@add_to_sbt:

; 404  :       }
; 405  :     }
; 406  :   }
; 407  : }

  0008e	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00093	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  00098	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0009c	5f		 pop	 rdi
  0009d	c3		 ret	 0
$LN15@add_to_sbt:
add_to_sbtree ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$bound_list DD imagerel bound_list
	DD	imagerel bound_list+236
	DD	imagerel $unwind$bound_list
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bound_list DD 061301H
	DD	026813H
	DD	08340aH
	DD	07006520aH
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT bound_list
_TEXT	SEGMENT
lmt$ = 64
y$ = 72
bound_list PROC						; COMDAT

; 347  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 348  :   lmt_node *existing_node;
; 349  : 
; 350  :   if (!*lmt)

  0000a	48 83 39 00	 cmp	 QWORD PTR [rcx], 0
  0000e	0f 29 74 24 20	 movaps	 XMMWORD PTR [rsp+32], xmm6
  00013	48 8b d9	 mov	 rbx, rcx
  00016	66 0f 28 f1	 movapd	 xmm6, xmm1
  0001a	74 21		 je	 SHORT $LN17@bound_list
$LL15@bound_list:

; 358  :   }
; 359  :   else
; 360  :     if (y < (*lmt)->y)

  0001c	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0001f	f2 0f 10 00	 movsdx	 xmm0, QWORD PTR [rax]
  00023	66 0f 2f c1	 comisd	 xmm0, xmm1
  00027	77 4a		 ja	 SHORT $LN18@bound_list

; 369  :     }
; 370  :     else
; 371  :       if (y > (*lmt)->y)

  00029	66 0f 2f c8	 comisd	 xmm1, xmm0
  0002d	0f 86 a5 00 00
	00		 jbe	 $LN2@bound_list

; 372  :         /* Head further up the LMT */
; 373  :         return bound_list(&((*lmt)->next), y);

  00033	48 8d 58 10	 lea	 rbx, QWORD PTR [rax+16]
  00037	48 83 3b 00	 cmp	 QWORD PTR [rbx], 0
  0003b	75 df		 jne	 SHORT $LL15@bound_list
$LN17@bound_list:

; 351  :   {
; 352  :     /* Add node onto the tail end of the LMT */
; 353  :     MALLOC(*lmt, sizeof(lmt_node), "LMT insertion", lmt_node);

  0003d	b9 18 00 00 00	 mov	 ecx, 24
  00042	e8 00 00 00 00	 call	 malloc
  00047	48 89 03	 mov	 QWORD PTR [rbx], rax
  0004a	48 85 c0	 test	 rax, rax
  0004d	75 72		 jne	 SHORT $LN10@bound_list
  0004f	e8 00 00 00 00	 call	 __iob_func
  00054	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0O@PACJOHFA@LMT?5insertion?$AA@
  0005b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@GBJAADOD@gpc?5malloc?5failure?3?5?$CFs?6?$AA@
  00062	48 8d 48 60	 lea	 rcx, QWORD PTR [rax+96]
  00066	e8 00 00 00 00	 call	 fprintf
  0006b	33 c9		 xor	 ecx, ecx
  0006d	e8 00 00 00 00	 call	 exit
  00072	cc		 int	 3
$LN18@bound_list:

; 361  :     {
; 362  :       /* Insert a new LMT node before the current node */
; 363  :       existing_node= *lmt;
; 364  :       MALLOC(*lmt, sizeof(lmt_node), "LMT insertion", lmt_node);

  00073	b9 18 00 00 00	 mov	 ecx, 24
  00078	48 8b f8	 mov	 rdi, rax
  0007b	e8 00 00 00 00	 call	 malloc
  00080	48 89 03	 mov	 QWORD PTR [rbx], rax
  00083	48 85 c0	 test	 rax, rax
  00086	75 24		 jne	 SHORT $LN5@bound_list
  00088	e8 00 00 00 00	 call	 __iob_func
  0008d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0O@PACJOHFA@LMT?5insertion?$AA@
  00094	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@GBJAADOD@gpc?5malloc?5failure?3?5?$CFs?6?$AA@
  0009b	48 8d 48 60	 lea	 rcx, QWORD PTR [rax+96]
  0009f	e8 00 00 00 00	 call	 fprintf
  000a4	33 c9		 xor	 ecx, ecx
  000a6	e8 00 00 00 00	 call	 exit
  000ab	cc		 int	 3
$LN5@bound_list:

; 365  :       (*lmt)->y= y;

  000ac	f2 0f 11 30	 movsdx	 QWORD PTR [rax], xmm6

; 366  :       (*lmt)->first_bound= NULL;

  000b0	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  000b3	48 83 60 08 00	 and	 QWORD PTR [rax+8], 0

; 367  :       (*lmt)->next= existing_node;

  000b8	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  000bb	48 89 78 10	 mov	 QWORD PTR [rax+16], rdi

; 368  :       return &((*lmt)->first_bound);

  000bf	eb 14		 jmp	 SHORT $LN21@bound_list
$LN10@bound_list:

; 354  :     (*lmt)->y= y;

  000c1	f2 0f 11 30	 movsdx	 QWORD PTR [rax], xmm6

; 355  :     (*lmt)->first_bound= NULL;

  000c5	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  000c8	48 83 60 08 00	 and	 QWORD PTR [rax+8], 0

; 356  :     (*lmt)->next= NULL;

  000cd	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  000d0	48 83 60 10 00	 and	 QWORD PTR [rax+16], 0
$LN21@bound_list:

; 357  :     return &((*lmt)->first_bound);

  000d5	48 8b 03	 mov	 rax, QWORD PTR [rbx]
$LN2@bound_list:

; 374  :       else
; 375  :         /* Use this existing LMT node */
; 376  :         return &((*lmt)->first_bound);
; 377  : }

  000d8	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000dd	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  000e2	48 83 c0 08	 add	 rax, 8
  000e6	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000ea	5f		 pop	 rdi
  000eb	c3		 ret	 0
$LN20@bound_list:
bound_list ENDP
; Function compile flags: /Ogspy
_TEXT	ENDS
;	COMDAT insert_bound
_TEXT	SEGMENT
b$ = 8
e$ = 16
insert_bound PROC					; COMDAT

; 301  :   edge_node *existing_bound;
; 302  : 
; 303  :   if (!*b)

  00000	48 83 39 00	 cmp	 QWORD PTR [rcx], 0
  00004	74 34		 je	 SHORT $LN14@insert_bou
  00006	f2 0f 10 4a 10	 movsdx	 xmm1, QWORD PTR [rdx+16]
$LL11@insert_bou:

; 307  :   }
; 308  :   else
; 309  :   {
; 310  :     /* Do primary sort on the x field */
; 311  :     if (e[0].bot.x < (*b)[0].bot.x)

  0000b	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  0000e	f2 0f 10 40 10	 movsdx	 xmm0, QWORD PTR [rax+16]
  00013	66 0f 2f c1	 comisd	 xmm0, xmm1
  00017	77 25		 ja	 SHORT $LN15@insert_bou

; 317  :     }
; 318  :     else
; 319  :     {
; 320  :       if (e[0].bot.x == (*b)[0].bot.x)

  00019	66 0f 2e c8	 ucomisd xmm1, xmm0
  0001d	7a 0e		 jp	 SHORT $LN4@insert_bou
  0001f	75 0c		 jne	 SHORT $LN4@insert_bou

; 321  :       {
; 322  :         /* Do secondary sort on the dx field */
; 323  :         if (e[0].dx < (*b)[0].dx)

  00021	f2 0f 10 40 40	 movsdx	 xmm0, QWORD PTR [rax+64]
  00026	66 0f 2f 42 40	 comisd	 xmm0, QWORD PTR [rdx+64]
  0002b	77 11		 ja	 SHORT $LN15@insert_bou
$LN4@insert_bou:

; 324  :         {
; 325  :           /* Insert a new node mid-list */
; 326  :           existing_bound= *b;
; 327  :           *b= e;
; 328  :           (*b)->next_bound= existing_bound;
; 329  :         }
; 330  :         else
; 331  :         {
; 332  :           /* Head further down the list */
; 333  :           insert_bound(&((*b)->next_bound), e);
; 334  :         }
; 335  :       }
; 336  :       else
; 337  :       {
; 338  :         /* Head further down the list */
; 339  :         insert_bound(&((*b)->next_bound), e);

  0002d	48 8d 88 a0 00
	00 00		 lea	 rcx, QWORD PTR [rax+160]
  00034	48 83 39 00	 cmp	 QWORD PTR [rcx], 0
  00038	75 d1		 jne	 SHORT $LL11@insert_bou
$LN14@insert_bou:

; 304  :   {
; 305  :     /* Link node e to the tail of the list */
; 306  :     *b= e;

  0003a	48 89 11	 mov	 QWORD PTR [rcx], rdx

; 340  :       }
; 341  :     }
; 342  :   }
; 343  : }

  0003d	c3		 ret	 0
$LN15@insert_bou:

; 312  :     {
; 313  :       /* Insert a new node mid-list */
; 314  :       existing_bound= *b;
; 315  :       *b= e;

  0003e	48 89 11	 mov	 QWORD PTR [rcx], rdx

; 316  :       (*b)->next_bound= existing_bound;

  00041	48 89 82 a0 00
	00 00		 mov	 QWORD PTR [rdx+160], rax

; 340  :       }
; 341  :     }
; 342  :   }
; 343  : }

  00048	c3		 ret	 0
insert_bound ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$reset_lmt DD imagerel reset_lmt
	DD	imagerel reset_lmt+60
	DD	imagerel $unwind$reset_lmt
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$reset_lmt DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT reset_lmt
_TEXT	SEGMENT
lmt$ = 48
reset_lmt PROC						; COMDAT

; 287  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 288  :   lmt_node *lmtn;
; 289  : 
; 290  :   while (*lmt)

  0000a	48 83 39 00	 cmp	 QWORD PTR [rcx], 0
  0000e	48 8b d9	 mov	 rbx, rcx
  00011	74 1e		 je	 SHORT $LN2@reset_lmt
$LL3@reset_lmt:

; 291  :   {
; 292  :     lmtn= (*lmt)->next;

  00013	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00016	48 8b 79 10	 mov	 rdi, QWORD PTR [rcx+16]

; 293  :     FREE(*lmt);

  0001a	48 85 c9	 test	 rcx, rcx
  0001d	74 09		 je	 SHORT $LN1@reset_lmt
  0001f	e8 00 00 00 00	 call	 free
  00024	48 83 23 00	 and	 QWORD PTR [rbx], 0
$LN1@reset_lmt:

; 294  :     *lmt= lmtn;

  00028	48 89 3b	 mov	 QWORD PTR [rbx], rdi
  0002b	48 83 ff 00	 cmp	 rdi, 0
  0002f	75 e2		 jne	 SHORT $LL3@reset_lmt
$LN2@reset_lmt:

; 295  :   }
; 296  : }

  00031	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00036	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003a	5f		 pop	 rdi
  0003b	c3		 ret	 0
reset_lmt ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$reset_it DD imagerel reset_it
	DD	imagerel reset_it+60
	DD	imagerel $unwind$reset_it
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$reset_it DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT reset_it
_TEXT	SEGMENT
it$ = 48
reset_it PROC						; COMDAT

; 274  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 275  :   it_node *itn;
; 276  : 
; 277  :   while (*it)

  0000a	48 83 39 00	 cmp	 QWORD PTR [rcx], 0
  0000e	48 8b d9	 mov	 rbx, rcx
  00011	74 1e		 je	 SHORT $LN2@reset_it
$LL3@reset_it:

; 278  :   {
; 279  :     itn= (*it)->next;

  00013	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00016	48 8b 79 20	 mov	 rdi, QWORD PTR [rcx+32]

; 280  :     FREE(*it);

  0001a	48 85 c9	 test	 rcx, rcx
  0001d	74 09		 je	 SHORT $LN1@reset_it
  0001f	e8 00 00 00 00	 call	 free
  00024	48 83 23 00	 and	 QWORD PTR [rbx], 0
$LN1@reset_it:

; 281  :     *it= itn;

  00028	48 89 3b	 mov	 QWORD PTR [rbx], rdi
  0002b	48 83 ff 00	 cmp	 rdi, 0
  0002f	75 e2		 jne	 SHORT $LL3@reset_it
$LN2@reset_it:

; 282  :   }
; 283  : }

  00031	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00036	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003a	5f		 pop	 rdi
  0003b	c3		 ret	 0
reset_it ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$minimax_test DD imagerel minimax_test
	DD	imagerel minimax_test+483
	DD	imagerel $unwind$minimax_test
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$minimax_test DD 0c1d01H
	DD	0b741dH
	DD	0a641dH
	DD	09541dH
	DD	08341dH
	DD	0e019321dH
	DD	0c015d017H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT minimax_test
_TEXT	SEGMENT
subj$ = 64
clip$ = 72
op$ = 80
minimax_test PROC					; COMDAT

; 983  : {

  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 68 10	 mov	 QWORD PTR [rax+16], rbp
  0000b	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  0000f	48 89 78 20	 mov	 QWORD PTR [rax+32], rdi
  00013	41 54		 push	 r12
  00015	41 55		 push	 r13
  00017	41 56		 push	 r14
  00019	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0001d	45 8b f0	 mov	 r14d, r8d
  00020	48 8b f2	 mov	 rsi, rdx
  00023	48 8b f9	 mov	 rdi, rcx

; 984  :   bbox *s_bbox, *c_bbox;
; 985  :   int   s, c, *o_table, overlap;
; 986  : 
; 987  :   s_bbox= create_contour_bboxes(subj);

  00026	e8 00 00 00 00	 call	 create_contour_bboxes

; 988  :   c_bbox= create_contour_bboxes(clip);

  0002b	48 8b ce	 mov	 rcx, rsi
  0002e	4c 8b e0	 mov	 r12, rax
  00031	e8 00 00 00 00	 call	 create_contour_bboxes

; 989  : 
; 990  :   MALLOC(o_table, subj->num_contours * clip->num_contours * sizeof(int),
; 991  :          "overlap table creation", int);

  00036	44 8b 0f	 mov	 r9d, DWORD PTR [rdi]
  00039	4c 8b e8	 mov	 r13, rax
  0003c	44 0f af 0e	 imul	 r9d, DWORD PTR [rsi]
  00040	49 63 c9	 movsxd	 rcx, r9d
  00043	48 c1 e1 02	 shl	 rcx, 2
  00047	48 85 c9	 test	 rcx, rcx
  0004a	74 31		 je	 SHORT $LN27@minimax_te
  0004c	e8 00 00 00 00	 call	 malloc
  00051	48 8b d8	 mov	 rbx, rax
  00054	48 85 c0	 test	 rax, rax
  00057	75 26		 jne	 SHORT $LN25@minimax_te
  00059	e8 00 00 00 00	 call	 __iob_func
  0005e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BH@KNBJDBCH@overlap?5table?5creation?$AA@
  00065	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@GBJAADOD@gpc?5malloc?5failure?3?5?$CFs?6?$AA@
  0006c	48 8d 48 60	 lea	 rcx, QWORD PTR [rax+96]
  00070	e8 00 00 00 00	 call	 fprintf
  00075	33 c9		 xor	 ecx, ecx
  00077	e8 00 00 00 00	 call	 exit
  0007c	cc		 int	 3
$LN27@minimax_te:
  0007d	33 db		 xor	 ebx, ebx
$LN25@minimax_te:

; 992  : 
; 993  :   /* Check all subject contour bounding boxes against clip boxes */
; 994  :   for (s= 0; s < subj->num_contours; s++)

  0007f	83 3f 00	 cmp	 DWORD PTR [rdi], 0
  00082	7e 73		 jle	 SHORT $LN22@minimax_te
  00084	44 8b 0f	 mov	 r9d, DWORD PTR [rdi]
  00087	4c 8b c3	 mov	 r8, rbx
  0008a	49 8b c4	 mov	 rax, r12
$LL24@minimax_te:

; 995  :     for (c= 0; c < clip->num_contours; c++)

  0008d	83 3e 00	 cmp	 DWORD PTR [rsi], 0
  00090	7e 57		 jle	 SHORT $LN23@minimax_te
  00092	4c 63 17	 movsxd	 r10, DWORD PTR [rdi]
  00095	8b 2e		 mov	 ebp, DWORD PTR [rsi]
  00097	49 8d 55 08	 lea	 rdx, QWORD PTR [r13+8]
  0009b	49 c1 e2 02	 shl	 r10, 2
  0009f	4d 8b d8	 mov	 r11, r8
$LL21@minimax_te:

; 996  :       o_table[c * subj->num_contours + s]=
; 997  :              (!((s_bbox[s].xmax < c_bbox[c].xmin) ||
; 998  :                 (s_bbox[s].xmin > c_bbox[c].xmax))) &&
; 999  :              (!((s_bbox[s].ymax < c_bbox[c].ymin) ||
; 1000 :                 (s_bbox[s].ymin > c_bbox[c].ymax)));

  000a2	f2 0f 10 42 f8	 movsdx	 xmm0, QWORD PTR [rdx-8]
  000a7	66 0f 2f 40 10	 comisd	 xmm0, QWORD PTR [rax+16]
  000ac	77 29		 ja	 SHORT $LN30@minimax_te
  000ae	f2 0f 10 00	 movsdx	 xmm0, QWORD PTR [rax]
  000b2	66 0f 2f 42 08	 comisd	 xmm0, QWORD PTR [rdx+8]
  000b7	77 1e		 ja	 SHORT $LN30@minimax_te
  000b9	f2 0f 10 02	 movsdx	 xmm0, QWORD PTR [rdx]
  000bd	66 0f 2f 40 18	 comisd	 xmm0, QWORD PTR [rax+24]
  000c2	77 13		 ja	 SHORT $LN30@minimax_te
  000c4	f2 0f 10 40 08	 movsdx	 xmm0, QWORD PTR [rax+8]
  000c9	66 0f 2f 42 10	 comisd	 xmm0, QWORD PTR [rdx+16]
  000ce	77 07		 ja	 SHORT $LN30@minimax_te
  000d0	b9 01 00 00 00	 mov	 ecx, 1
  000d5	eb 02		 jmp	 SHORT $LN32@minimax_te
$LN30@minimax_te:
  000d7	33 c9		 xor	 ecx, ecx
$LN32@minimax_te:
  000d9	41 89 0b	 mov	 DWORD PTR [r11], ecx
  000dc	48 83 c2 20	 add	 rdx, 32			; 00000020H
  000e0	4d 03 da	 add	 r11, r10
  000e3	48 83 ed 01	 sub	 rbp, 1
  000e7	75 b9		 jne	 SHORT $LL21@minimax_te
$LN23@minimax_te:

; 992  : 
; 993  :   /* Check all subject contour bounding boxes against clip boxes */
; 994  :   for (s= 0; s < subj->num_contours; s++)

  000e9	48 83 c0 20	 add	 rax, 32			; 00000020H
  000ed	49 83 c0 04	 add	 r8, 4
  000f1	49 83 e9 01	 sub	 r9, 1
  000f5	75 96		 jne	 SHORT $LL24@minimax_te
$LN22@minimax_te:

; 1001 : 
; 1002 :   /* For each clip contour, search for any subject contour overlaps */
; 1003 :   for (c= 0; c < clip->num_contours; c++)

  000f7	45 33 c0	 xor	 r8d, r8d
  000fa	45 33 c9	 xor	 r9d, r9d
  000fd	44 39 06	 cmp	 DWORD PTR [rsi], r8d
  00100	7e 42		 jle	 SHORT $LN16@minimax_te
  00102	33 d2		 xor	 edx, edx
$LL18@minimax_te:

; 1004 :   {
; 1005 :     overlap= 0;

  00104	33 c0		 xor	 eax, eax

; 1006 :     for (s= 0; (!overlap) && (s < subj->num_contours); s++)

  00106	33 c9		 xor	 ecx, ecx
  00108	45 33 d2	 xor	 r10d, r10d
$LL15@minimax_te:
  0010b	3b 0f		 cmp	 ecx, DWORD PTR [rdi]
  0010d	7d 16		 jge	 SHORT $LN13@minimax_te

; 1007 :       overlap= o_table[c * subj->num_contours + s];

  0010f	48 63 07	 movsxd	 rax, DWORD PTR [rdi]
  00112	ff c1		 inc	 ecx
  00114	49 0f af c1	 imul	 rax, r9
  00118	49 03 c2	 add	 rax, r10
  0011b	49 ff c2	 inc	 r10
  0011e	8b 04 83	 mov	 eax, DWORD PTR [rbx+rax*4]
  00121	85 c0		 test	 eax, eax
  00123	74 e6		 je	 SHORT $LL15@minimax_te
$LN13@minimax_te:

; 1008 : 
; 1009 :     if (!overlap)

  00125	85 c0		 test	 eax, eax
  00127	75 0c		 jne	 SHORT $LN17@minimax_te

; 1010 :       /* Flag non contributing status by negating vertex count */
; 1011 :       clip->contour[c].num_vertices = -clip->contour[c].num_vertices;

  00129	48 8b 4e 10	 mov	 rcx, QWORD PTR [rsi+16]
  0012d	8b 04 11	 mov	 eax, DWORD PTR [rcx+rdx]
  00130	f7 d8		 neg	 eax
  00132	89 04 11	 mov	 DWORD PTR [rcx+rdx], eax
$LN17@minimax_te:
  00135	41 ff c0	 inc	 r8d
  00138	49 ff c1	 inc	 r9
  0013b	48 83 c2 10	 add	 rdx, 16
  0013f	44 3b 06	 cmp	 r8d, DWORD PTR [rsi]
  00142	7c c0		 jl	 SHORT $LL18@minimax_te
$LN16@minimax_te:

; 1012 :   }  
; 1013 : 
; 1014 :   if (op == GPC_INT)

  00144	41 83 fe 01	 cmp	 r14d, 1
  00148	75 53		 jne	 SHORT $LN8@minimax_te

; 1015 :   {  
; 1016 :     /* For each subject contour, search for any clip contour overlaps */
; 1017 :     for (s= 0; s < subj->num_contours; s++)

  0014a	8b 0f		 mov	 ecx, DWORD PTR [rdi]
  0014c	45 33 c0	 xor	 r8d, r8d
  0014f	45 33 c9	 xor	 r9d, r9d
  00152	85 c9		 test	 ecx, ecx
  00154	7e 47		 jle	 SHORT $LN8@minimax_te
  00156	33 d2		 xor	 edx, edx
$LL10@minimax_te:

; 1018 :     {
; 1019 :       overlap= 0;

  00158	33 c0		 xor	 eax, eax

; 1020 :       for (c= 0; (!overlap) && (c < clip->num_contours); c++)

  0015a	45 33 d2	 xor	 r10d, r10d
  0015d	45 33 db	 xor	 r11d, r11d
$LL7@minimax_te:
  00160	44 3b 16	 cmp	 r10d, DWORD PTR [rsi]
  00163	7d 17		 jge	 SHORT $LN5@minimax_te

; 1021 :         overlap= o_table[c * subj->num_contours + s];

  00165	48 63 c1	 movsxd	 rax, ecx
  00168	41 ff c2	 inc	 r10d
  0016b	49 0f af c3	 imul	 rax, r11
  0016f	49 ff c3	 inc	 r11
  00172	49 03 c1	 add	 rax, r9
  00175	8b 04 83	 mov	 eax, DWORD PTR [rbx+rax*4]
  00178	85 c0		 test	 eax, eax
  0017a	74 e4		 je	 SHORT $LL7@minimax_te
$LN5@minimax_te:

; 1022 : 
; 1023 :       if (!overlap)

  0017c	85 c0		 test	 eax, eax
  0017e	75 0c		 jne	 SHORT $LN9@minimax_te

; 1024 :         /* Flag non contributing status by negating vertex count */
; 1025 :         subj->contour[s].num_vertices = -subj->contour[s].num_vertices;

  00180	48 8b 4f 10	 mov	 rcx, QWORD PTR [rdi+16]
  00184	8b 04 11	 mov	 eax, DWORD PTR [rcx+rdx]
  00187	f7 d8		 neg	 eax
  00189	89 04 11	 mov	 DWORD PTR [rcx+rdx], eax
$LN9@minimax_te:
  0018c	8b 0f		 mov	 ecx, DWORD PTR [rdi]
  0018e	41 ff c0	 inc	 r8d
  00191	49 ff c1	 inc	 r9
  00194	48 83 c2 10	 add	 rdx, 16
  00198	44 3b c1	 cmp	 r8d, ecx
  0019b	7c bb		 jl	 SHORT $LL10@minimax_te
$LN8@minimax_te:

; 1026 :     }  
; 1027 :   }
; 1028 : 
; 1029 :   FREE(s_bbox);

  0019d	4d 85 e4	 test	 r12, r12
  001a0	74 08		 je	 SHORT $LN3@minimax_te
  001a2	49 8b cc	 mov	 rcx, r12
  001a5	e8 00 00 00 00	 call	 free
$LN3@minimax_te:

; 1030 :   FREE(c_bbox);

  001aa	4d 85 ed	 test	 r13, r13
  001ad	74 08		 je	 SHORT $LN2@minimax_te
  001af	49 8b cd	 mov	 rcx, r13
  001b2	e8 00 00 00 00	 call	 free
$LN2@minimax_te:

; 1031 :   FREE(o_table);

  001b7	48 85 db	 test	 rbx, rbx
  001ba	74 08		 je	 SHORT $LN1@minimax_te
  001bc	48 8b cb	 mov	 rcx, rbx
  001bf	e8 00 00 00 00	 call	 free
$LN1@minimax_te:

; 1032 : }

  001c4	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  001c9	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  001ce	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  001d3	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  001d8	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001dc	41 5e		 pop	 r14
  001de	41 5d		 pop	 r13
  001e0	41 5c		 pop	 r12
  001e2	c3		 ret	 0
$LN45@minimax_te:
minimax_test ENDP
_TEXT	ENDS
PUBLIC	__real@3cb0000000000000
PUBLIC	__mask@@AbsDouble@
;	COMDAT pdata
pdata	SEGMENT
$pdata$add_st_edge DD imagerel add_st_edge
	DD	imagerel add_st_edge+461
	DD	imagerel $unwind$add_st_edge
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$add_st_edge DD 0c2a01H
	DD	03882aH
	DD	04781cH
	DD	056818H
	DD	0f6410H
	DD	0e3410H
	DD	0700cb210H
xdata	ENDS
;	COMDAT __real@3cb0000000000000
CONST	SEGMENT
__real@3cb0000000000000 DQ 03cb0000000000000r	; 2.22045e-016
CONST	ENDS
;	COMDAT __mask@@AbsDouble@
CONST	SEGMENT
__mask@@AbsDouble@ DB 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 07fH, 0ffH
	DB	0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 07fH
; Function compile flags: /Ogspy
CONST	ENDS
;	COMDAT add_st_edge
_TEXT	SEGMENT
st$ = 112
it$ = 120
edge$ = 128
dy$ = 136
add_st_edge PROC					; COMDAT

; 678  : {

  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 70 10	 mov	 QWORD PTR [rax+16], rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 60	 sub	 rsp, 96			; 00000060H

; 679  :   st_node *existing_node;
; 680  :   double   den, r, x, y;
; 681  : 
; 682  :   if (!*st)

  00010	48 83 39 00	 cmp	 QWORD PTR [rcx], 0
  00014	0f 29 70 e8	 movaps	 XMMWORD PTR [rax-24], xmm6
  00018	0f 29 78 d8	 movaps	 XMMWORD PTR [rax-40], xmm7
  0001c	49 8b f8	 mov	 rdi, r8
  0001f	48 8b f2	 mov	 rsi, rdx
  00022	48 8b d9	 mov	 rbx, rcx
  00025	44 0f 29 40 c8	 movaps	 XMMWORD PTR [rax-56], xmm8
  0002a	66 44 0f 28 c3	 movapd	 xmm8, xmm3
  0002f	0f 84 ac 00 00
	00		 je	 $LN16@add_st_edg
  00035	f2 0f 10 35 00
	00 00 00	 movsdx	 xmm6, QWORD PTR __mask@@AbsDouble@
  0003d	f2 0f 10 3d 00
	00 00 00	 movsdx	 xmm7, QWORD PTR __real@3cb0000000000000
$LL14@add_st_edg:

; 691  :   }
; 692  :   else
; 693  :   {
; 694  :     den= ((*st)->xt - (*st)->xb) - (edge->xt - edge->xb);

  00045	48 8b 13	 mov	 rdx, QWORD PTR [rbx]
  00048	f2 0f 10 4f 38	 movsdx	 xmm1, QWORD PTR [rdi+56]
  0004d	f2 0f 10 67 30	 movsdx	 xmm4, QWORD PTR [rdi+48]

; 695  : 
; 696  :     /* If new edge and ST edge don't cross */
; 697  :     if ((edge->xt >= (*st)->xt) || (edge->dx == (*st)->dx) || 
; 698  :         (fabs(den) <= DBL_EPSILON))

  00052	66 0f 2f 4a 10	 comisd	 xmm1, QWORD PTR [rdx+16]
  00057	f2 0f 10 52 10	 movsdx	 xmm2, QWORD PTR [rdx+16]
  0005c	66 0f 28 c1	 movapd	 xmm0, xmm1
  00060	f2 0f 5c 52 08	 subsd	 xmm2, QWORD PTR [rdx+8]
  00065	f2 0f 5c c4	 subsd	 xmm0, xmm4
  00069	f2 0f 5c d0	 subsd	 xmm2, xmm0
  0006d	0f 83 a8 00 00
	00		 jae	 $LN17@add_st_edg
  00073	f2 0f 10 47 40	 movsdx	 xmm0, QWORD PTR [rdi+64]
  00078	66 0f 2e 42 18	 ucomisd xmm0, QWORD PTR [rdx+24]
  0007d	7a 06		 jp	 SHORT $LN19@add_st_edg
  0007f	0f 84 96 00 00
	00		 je	 $LN17@add_st_edg
$LN19@add_st_edg:
  00085	66 0f 28 c2	 movapd	 xmm0, xmm2
  00089	66 0f 54 c6	 andpd	 xmm0, xmm6
  0008d	66 0f 2f f8	 comisd	 xmm7, xmm0
  00091	0f 83 84 00 00
	00		 jae	 $LN17@add_st_edg

; 708  :     }
; 709  :     else
; 710  :     {
; 711  :       /* Compute intersection between new edge and ST edge */
; 712  :       r= (edge->xb - (*st)->xb) / den;

  00097	f2 0f 5c 62 08	 subsd	 xmm4, QWORD PTR [rdx+8]

; 713  :       x= (*st)->xb + r * ((*st)->xt - (*st)->xb);

  0009c	f2 0f 10 5a 10	 movsdx	 xmm3, QWORD PTR [rdx+16]

; 714  :       y= r * dy;
; 715  : 
; 716  :       /* Insert the edge pointers and the intersection point in the IT */
; 717  :       add_intersection(it, (*st)->edge, edge, x, y);

  000a1	4c 8b c7	 mov	 r8, rdi
  000a4	48 8b ce	 mov	 rcx, rsi
  000a7	f2 0f 5c 5a 08	 subsd	 xmm3, QWORD PTR [rdx+8]
  000ac	f2 0f 5e e2	 divsd	 xmm4, xmm2
  000b0	f2 0f 59 dc	 mulsd	 xmm3, xmm4
  000b4	66 0f 28 c4	 movapd	 xmm0, xmm4
  000b8	f2 41 0f 59 c0	 mulsd	 xmm0, xmm8
  000bd	f2 0f 58 5a 08	 addsd	 xmm3, QWORD PTR [rdx+8]
  000c2	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  000c5	f2 0f 11 44 24
	20		 movsdx	 QWORD PTR [rsp+32], xmm0
  000cb	e8 00 00 00 00	 call	 add_intersection

; 718  : 
; 719  :       /* Head further into the ST */
; 720  :       add_st_edge(&((*st)->prev), it, edge, dy);

  000d0	48 8b 1b	 mov	 rbx, QWORD PTR [rbx]
  000d3	48 83 c3 20	 add	 rbx, 32			; 00000020H
  000d7	48 83 3b 00	 cmp	 QWORD PTR [rbx], 0
  000db	0f 85 64 ff ff
	ff		 jne	 $LL14@add_st_edg
$LN16@add_st_edg:

; 683  :   {
; 684  :     /* Append edge onto the tail end of the ST */
; 685  :     MALLOC(*st, sizeof(st_node), "ST insertion", st_node);

  000e1	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  000e6	e8 00 00 00 00	 call	 malloc
  000eb	48 89 03	 mov	 QWORD PTR [rbx], rax
  000ee	48 85 c0	 test	 rax, rax
  000f1	0f 85 8a 00 00
	00		 jne	 $LN9@add_st_edg
  000f7	e8 00 00 00 00	 call	 __iob_func
  000fc	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0N@LELBEKD@ST?5insertion?$AA@
  00103	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@GBJAADOD@gpc?5malloc?5failure?3?5?$CFs?6?$AA@
  0010a	48 8d 48 60	 lea	 rcx, QWORD PTR [rax+96]
  0010e	e8 00 00 00 00	 call	 fprintf
  00113	33 c9		 xor	 ecx, ecx
  00115	e8 00 00 00 00	 call	 exit
  0011a	cc		 int	 3
$LN17@add_st_edg:

; 699  :     {
; 700  :       /* No intersection - insert edge here (before the ST edge) */
; 701  :       existing_node= *st;
; 702  :       MALLOC(*st, sizeof(st_node), "ST insertion", st_node);

  0011b	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  00120	48 8b f2	 mov	 rsi, rdx
  00123	e8 00 00 00 00	 call	 malloc
  00128	48 89 03	 mov	 QWORD PTR [rbx], rax
  0012b	48 85 c0	 test	 rax, rax
  0012e	75 24		 jne	 SHORT $LN3@add_st_edg
  00130	e8 00 00 00 00	 call	 __iob_func
  00135	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0N@LELBEKD@ST?5insertion?$AA@
  0013c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@GBJAADOD@gpc?5malloc?5failure?3?5?$CFs?6?$AA@
  00143	48 8d 48 60	 lea	 rcx, QWORD PTR [rax+96]
  00147	e8 00 00 00 00	 call	 fprintf
  0014c	33 c9		 xor	 ecx, ecx
  0014e	e8 00 00 00 00	 call	 exit
  00153	cc		 int	 3
$LN3@add_st_edg:

; 703  :       (*st)->edge= edge;

  00154	48 89 38	 mov	 QWORD PTR [rax], rdi

; 704  :       (*st)->xb= edge->xb;

  00157	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  0015a	48 8b 47 30	 mov	 rax, QWORD PTR [rdi+48]
  0015e	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 705  :       (*st)->xt= edge->xt;

  00162	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00165	48 8b 47 38	 mov	 rax, QWORD PTR [rdi+56]
  00169	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 706  :       (*st)->dx= edge->dx;

  0016d	48 8b 47 40	 mov	 rax, QWORD PTR [rdi+64]
  00171	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00174	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 707  :       (*st)->prev= existing_node;

  00178	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0017b	48 89 70 20	 mov	 QWORD PTR [rax+32], rsi
  0017f	eb 2c		 jmp	 SHORT $LN1@add_st_edg
$LN9@add_st_edg:

; 686  :     (*st)->edge= edge;

  00181	48 89 38	 mov	 QWORD PTR [rax], rdi

; 687  :     (*st)->xb= edge->xb;

  00184	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00187	48 8b 47 30	 mov	 rax, QWORD PTR [rdi+48]
  0018b	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 688  :     (*st)->xt= edge->xt;

  0018f	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00192	48 8b 47 38	 mov	 rax, QWORD PTR [rdi+56]
  00196	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 689  :     (*st)->dx= edge->dx;

  0019a	48 8b 47 40	 mov	 rax, QWORD PTR [rdi+64]
  0019e	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  001a1	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 690  :     (*st)->prev= NULL;

  001a5	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  001a8	48 83 60 20 00	 and	 QWORD PTR [rax+32], 0
$LN1@add_st_edg:

; 721  :     }
; 722  :   }
; 723  : }

  001ad	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  001b2	48 8b 74 24 78	 mov	 rsi, QWORD PTR [rsp+120]
  001b7	0f 28 74 24 50	 movaps	 xmm6, XMMWORD PTR [rsp+80]
  001bc	0f 28 7c 24 40	 movaps	 xmm7, XMMWORD PTR [rsp+64]
  001c1	44 0f 28 44 24
	30		 movaps	 xmm8, XMMWORD PTR [rsp+48]
  001c7	48 83 c4 60	 add	 rsp, 96			; 00000060H
  001cb	5f		 pop	 rdi
  001cc	c3		 ret	 0
$LN20@add_st_edg:
add_st_edge ENDP
_TEXT	ENDS
PUBLIC	$T112824
;	COMDAT pdata
pdata	SEGMENT
$pdata$build_lmt DD imagerel build_lmt
	DD	imagerel build_lmt+1892
	DD	imagerel $unwind$build_lmt
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$build_lmt DD 092301H
	DD	0f01fe223H
	DD	0d01be01dH
	DD	07017c019H
	DD	050156016H
	DD	03014H
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT build_lmt
_TEXT	SEGMENT
tv2807 = 32
tv2795 = 32
e_index$1$ = 36
c$1$ = 40
num_edges$1$ = 44
tv2786 = 44
v$1$ = 48
tv2823 = 48
v$2$ = 52
tv2824 = 52
$T112893 = 56
tv2787 = 56
tv2804 = 64
tv2790 = 64
tv2803 = 72
tv2793 = 72
tv2783 = 80
edge_table$1$ = 88
$T112894 = 96
$T112824 = 96
lmt$ = 192
sbtree$ = 200
sbt_entries$ = 208
p$ = 216
type$ = 224
op$ = 232
build_lmt PROC						; COMDAT

; 451  : {

  00000	48 8b c4	 mov	 rax, rsp
  00003	4c 89 48 20	 mov	 QWORD PTR [rax+32], r9
  00007	4c 89 40 18	 mov	 QWORD PTR [rax+24], r8
  0000b	48 89 50 10	 mov	 QWORD PTR [rax+16], rdx
  0000f	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  00013	53		 push	 rbx
  00014	55		 push	 rbp
  00015	56		 push	 rsi
  00016	57		 push	 rdi
  00017	41 54		 push	 r12
  00019	41 55		 push	 r13
  0001b	41 56		 push	 r14
  0001d	41 57		 push	 r15
  0001f	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 452  :   int          c, i, min, max, num_edges, v, num_vertices;
; 453  :   int          total_vertices= 0, e_index=0;

  00023	45 33 d2	 xor	 r10d, r10d
  00026	4d 8b e9	 mov	 r13, r9
  00029	44 21 54 24 24	 and	 DWORD PTR e_index$1$[rsp], r10d

; 454  :   edge_node   *e, *edge_table;
; 455  : 
; 456  :   for (c= 0; c < p->num_contours; c++)

  0002e	45 39 11	 cmp	 DWORD PTR [r9], r10d
  00031	0f 8e 81 00 00
	00		 jle	 $LN32@build_lmt
  00037	4d 8b 49 10	 mov	 r9, QWORD PTR [r9+16]
  0003b	41 8b 75 00	 mov	 esi, DWORD PTR [r13]
$LL34@build_lmt:

; 457  :     total_vertices+= count_optimal_vertices(p->contour[c]);

  0003f	f3 41 0f 6f 01	 movdqu	 xmm0, XMMWORD PTR [r9]
  00044	45 33 db	 xor	 r11d, r11d
  00047	f3 0f 7f 44 24
	60		 movdqu	 XMMWORD PTR $T112824[rsp], xmm0
  0004d	8b 4c 24 60	 mov	 ecx, DWORD PTR $T112824[rsp]
  00051	85 c9		 test	 ecx, ecx
  00053	7e 56		 jle	 SHORT $LN47@build_lmt
  00055	48 8b 7c 24 68	 mov	 rdi, QWORD PTR $T112824[rsp+8]
  0005a	45 8d 43 01	 lea	 r8d, QWORD PTR [r11+1]
  0005e	48 8b e9	 mov	 rbp, rcx
  00061	48 8d 5f 08	 lea	 rbx, QWORD PTR [rdi+8]
$LL49@build_lmt:
  00065	42 8d 44 01 fe	 lea	 eax, DWORD PTR [rcx+r8-2]
  0006a	99		 cdq
  0006b	f7 f9		 idiv	 ecx
  0006d	48 63 c2	 movsxd	 rax, edx
  00070	48 03 c0	 add	 rax, rax
  00073	f2 0f 10 44 c7
	08		 movsdx	 xmm0, QWORD PTR [rdi+rax*8+8]
  00079	66 0f 2e 03	 ucomisd xmm0, QWORD PTR [rbx]
  0007d	7a 1c		 jp	 SHORT $LN74@build_lmt
  0007f	75 1a		 jne	 SHORT $LN74@build_lmt
  00081	41 8b c0	 mov	 eax, r8d
  00084	99		 cdq
  00085	f7 f9		 idiv	 ecx
  00087	48 63 c2	 movsxd	 rax, edx
  0008a	48 03 c0	 add	 rax, rax
  0008d	f2 0f 10 44 c7
	08		 movsdx	 xmm0, QWORD PTR [rdi+rax*8+8]
  00093	66 0f 2e 03	 ucomisd xmm0, QWORD PTR [rbx]
  00097	7a 02		 jp	 SHORT $LN74@build_lmt
  00099	74 03		 je	 SHORT $LN48@build_lmt
$LN74@build_lmt:
  0009b	41 ff c3	 inc	 r11d
$LN48@build_lmt:
  0009e	41 ff c0	 inc	 r8d
  000a1	48 83 c3 10	 add	 rbx, 16
  000a5	48 83 ed 01	 sub	 rbp, 1
  000a9	75 ba		 jne	 SHORT $LL49@build_lmt
$LN47@build_lmt:
  000ab	45 03 d3	 add	 r10d, r11d
  000ae	49 83 c1 10	 add	 r9, 16
  000b2	48 83 ee 01	 sub	 rsi, 1
  000b6	75 87		 jne	 SHORT $LL34@build_lmt
$LN32@build_lmt:

; 458  : 
; 459  :   /* Create the entire input polygon edge table in one go */
; 460  :   MALLOC(edge_table, total_vertices * sizeof(edge_node),
; 461  :          "edge table creation", edge_node);

  000b8	49 63 ca	 movsxd	 rcx, r10d
  000bb	48 69 c9 a8 00
	00 00		 imul	 rcx, 168		; 000000a8H
  000c2	48 85 c9	 test	 rcx, rcx
  000c5	74 36		 je	 SHORT $LN31@build_lmt
  000c7	e8 00 00 00 00	 call	 malloc
  000cc	48 8b d8	 mov	 rbx, rax
  000cf	48 89 44 24 58	 mov	 QWORD PTR edge_table$1$[rsp], rax
  000d4	48 85 c0	 test	 rax, rax
  000d7	75 2b		 jne	 SHORT $LN29@build_lmt
  000d9	e8 00 00 00 00	 call	 __iob_func
  000de	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BE@DDDONHEA@edge?5table?5creation?$AA@
  000e5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@GBJAADOD@gpc?5malloc?5failure?3?5?$CFs?6?$AA@
  000ec	48 8d 48 60	 lea	 rcx, QWORD PTR [rax+96]
  000f0	e8 00 00 00 00	 call	 fprintf
  000f5	33 c9		 xor	 ecx, ecx
  000f7	e8 00 00 00 00	 call	 exit
  000fc	cc		 int	 3
$LN31@build_lmt:
  000fd	33 db		 xor	 ebx, ebx
  000ff	48 89 5c 24 58	 mov	 QWORD PTR edge_table$1$[rsp], rbx
$LN29@build_lmt:

; 462  : 
; 463  :   for (c= 0; c < p->num_contours; c++)

  00104	45 33 ff	 xor	 r15d, r15d
  00107	45 39 7d 00	 cmp	 DWORD PTR [r13], r15d
  0010b	44 89 7c 24 28	 mov	 DWORD PTR c$1$[rsp], r15d
  00110	0f 8e 3a 06 00
	00		 jle	 $LN26@build_lmt
  00116	33 ed		 xor	 ebp, ebp
  00118	48 89 6c 24 50	 mov	 QWORD PTR tv2783[rsp], rbp
$LL28@build_lmt:

; 464  :   {
; 465  :     if (p->contour[c].num_vertices < 0)

  0011d	49 8b 45 10	 mov	 rax, QWORD PTR [r13+16]
  00121	8b 0c 28	 mov	 ecx, DWORD PTR [rax+rbp]
  00124	85 c9		 test	 ecx, ecx
  00126	79 10		 jns	 SHORT $LN25@build_lmt

; 466  :     {
; 467  :       /* Ignore the non-contributing contour and repair the vertex count */
; 468  :       p->contour[c].num_vertices= -p->contour[c].num_vertices;

  00128	48 8b c8	 mov	 rcx, rax
  0012b	8b 04 28	 mov	 eax, DWORD PTR [rax+rbp]
  0012e	f7 d8		 neg	 eax
  00130	89 04 29	 mov	 DWORD PTR [rcx+rbp], eax

; 469  :     }
; 470  :     else

  00133	e9 fd 05 00 00	 jmp	 $LN27@build_lmt
$LN25@build_lmt:

; 471  :     {
; 472  :       /* Perform contour optimisation */
; 473  :       num_vertices= 0;

  00138	33 ff		 xor	 edi, edi

; 474  :       for (i= 0; i < p->contour[c].num_vertices; i++)

  0013a	45 33 e4	 xor	 r12d, r12d
  0013d	85 c9		 test	 ecx, ecx
  0013f	0f 8e c3 00 00
	00		 jle	 $LN21@build_lmt
  00145	4c 8b bc 24 d0
	00 00 00	 mov	 r15, QWORD PTR sbt_entries$[rsp]
  0014d	4c 8b f3	 mov	 r14, rbx
  00150	48 8b 9c 24 c8
	00 00 00	 mov	 rbx, QWORD PTR sbtree$[rsp]
  00158	33 f6		 xor	 esi, esi
$LL23@build_lmt:

; 475  :         if (OPTIMAL(p->contour[c].vertex, i, p->contour[c].num_vertices))

  0015a	49 8b 45 10	 mov	 rax, QWORD PTR [r13+16]
  0015e	4c 8b 44 28 08	 mov	 r8, QWORD PTR [rax+rbp+8]
  00163	8b 0c 28	 mov	 ecx, DWORD PTR [rax+rbp]
  00166	42 8d 44 21 ff	 lea	 eax, DWORD PTR [rcx+r12-1]
  0016b	99		 cdq
  0016c	f7 f9		 idiv	 ecx
  0016e	48 63 c2	 movsxd	 rax, edx
  00171	48 03 c0	 add	 rax, rax
  00174	f2 41 0f 10 44
	c0 08		 movsdx	 xmm0, QWORD PTR [r8+rax*8+8]
  0017b	66 41 0f 2e 44
	30 08		 ucomisd xmm0, QWORD PTR [r8+rsi+8]
  00182	7a 2c		 jp	 SHORT $LN73@build_lmt
  00184	75 2a		 jne	 SHORT $LN73@build_lmt
  00186	49 8b 4d 10	 mov	 rcx, QWORD PTR [r13+16]
  0018a	41 8d 44 24 01	 lea	 eax, DWORD PTR [r12+1]
  0018f	4c 8b 44 29 08	 mov	 r8, QWORD PTR [rcx+rbp+8]
  00194	99		 cdq
  00195	f7 3c 29	 idiv	 DWORD PTR [rcx+rbp]
  00198	48 63 c2	 movsxd	 rax, edx
  0019b	48 03 c0	 add	 rax, rax
  0019e	f2 41 0f 10 44
	c0 08		 movsdx	 xmm0, QWORD PTR [r8+rax*8+8]
  001a5	66 41 0f 2e 44
	30 08		 ucomisd xmm0, QWORD PTR [r8+rsi+8]
  001ac	7a 02		 jp	 SHORT $LN73@build_lmt
  001ae	74 39		 je	 SHORT $LN22@build_lmt
$LN73@build_lmt:

; 476  :         {
; 477  :           edge_table[num_vertices].vertex.x= p->contour[c].vertex[i].x;

  001b0	49 8b 45 10	 mov	 rax, QWORD PTR [r13+16]

; 478  :           edge_table[num_vertices].vertex.y= p->contour[c].vertex[i].y;
; 479  : 
; 480  :           /* Record vertex in the scanbeam table */
; 481  :           add_to_sbtree(sbt_entries, sbtree,
; 482  :                         edge_table[num_vertices].vertex.y);

  001b4	48 8b d3	 mov	 rdx, rbx
  001b7	48 8b 4c 28 08	 mov	 rcx, QWORD PTR [rax+rbp+8]
  001bc	48 8b 04 0e	 mov	 rax, QWORD PTR [rsi+rcx]
  001c0	49 89 06	 mov	 QWORD PTR [r14], rax
  001c3	49 8b 45 10	 mov	 rax, QWORD PTR [r13+16]
  001c7	48 8b 4c 28 08	 mov	 rcx, QWORD PTR [rax+rbp+8]
  001cc	f2 0f 10 54 31
	08		 movsdx	 xmm2, QWORD PTR [rcx+rsi+8]
  001d2	49 8b cf	 mov	 rcx, r15
  001d5	f2 41 0f 11 56
	08		 movsdx	 QWORD PTR [r14+8], xmm2
  001db	e8 00 00 00 00	 call	 add_to_sbtree

; 483  : 
; 484  :           num_vertices++;

  001e0	ff c7		 inc	 edi
  001e2	49 81 c6 a8 00
	00 00		 add	 r14, 168		; 000000a8H
$LN22@build_lmt:
  001e9	49 8b 45 10	 mov	 rax, QWORD PTR [r13+16]
  001ed	41 ff c4	 inc	 r12d
  001f0	48 83 c6 10	 add	 rsi, 16
  001f4	44 3b 24 28	 cmp	 r12d, DWORD PTR [rax+rbp]
  001f8	0f 8c 5c ff ff
	ff		 jl	 $LL23@build_lmt
  001fe	48 8b 5c 24 58	 mov	 rbx, QWORD PTR edge_table$1$[rsp]
  00203	44 8b 7c 24 28	 mov	 r15d, DWORD PTR c$1$[rsp]
$LN21@build_lmt:

; 485  :         }
; 486  : 
; 487  :       /* Do the contour forward pass */
; 488  :       for (min= 0; min < num_vertices; min++)

  00208	4c 63 5c 24 24	 movsxd	 r11, DWORD PTR e_index$1$[rsp]
  0020d	85 ff		 test	 edi, edi
  0020f	0f 8e 9d 02 00
	00		 jle	 $LN16@build_lmt
  00215	4c 8d 73 08	 lea	 r14, QWORD PTR [rbx+8]
  00219	41 bc 01 00 00
	00		 mov	 r12d, 1
  0021f	4c 8b fb	 mov	 r15, rbx
  00222	48 89 5c 24 48	 mov	 QWORD PTR tv2803[rsp], rbx
  00227	8d 47 fe	 lea	 eax, DWORD PTR [rdi-2]
  0022a	49 8b eb	 mov	 rbp, r11
  0022d	4c 89 74 24 40	 mov	 QWORD PTR tv2804[rsp], r14
  00232	44 89 64 24 20	 mov	 DWORD PTR tv2807[rsp], r12d
$LL18@build_lmt:

; 489  :       {
; 490  :         /* If a forward local minimum... */
; 491  :         if (FWD_MIN(edge_table, min, num_vertices))

  00237	41 03 c4	 add	 eax, r12d
  0023a	99		 cdq
  0023b	f7 ff		 idiv	 edi
  0023d	48 63 c2	 movsxd	 rax, edx
  00240	48 69 c0 a8 00
	00 00		 imul	 rax, 168		; 000000a8H
  00247	f2 0f 10 44 18
	08		 movsdx	 xmm0, QWORD PTR [rax+rbx+8]
  0024d	66 41 0f 2f 06	 comisd	 xmm0, QWORD PTR [r14]
  00252	0f 82 1b 02 00
	00		 jb	 $LN17@build_lmt
  00258	41 8b c4	 mov	 eax, r12d
  0025b	99		 cdq
  0025c	f7 ff		 idiv	 edi
  0025e	4c 63 c2	 movsxd	 r8, edx
  00261	49 8b c0	 mov	 rax, r8
  00264	48 69 c0 a8 00
	00 00		 imul	 rax, 168		; 000000a8H
  0026b	f2 0f 10 44 18
	08		 movsdx	 xmm0, QWORD PTR [rax+rbx+8]
  00271	66 41 0f 2f 06	 comisd	 xmm0, QWORD PTR [r14]
  00276	0f 86 f7 01 00
	00		 jbe	 $LN17@build_lmt

; 492  :         {
; 493  :           /* Search for the next local maximum... */
; 494  :           num_edges= 1;
; 495  :           max= NEXT_INDEX(min, num_vertices);
; 496  :           while (NOT_FMAX(edge_table, max, num_vertices))

  0027c	41 8d 40 01	 lea	 eax, DWORD PTR [r8+1]
  00280	41 ba 01 00 00
	00		 mov	 r10d, 1
  00286	99		 cdq
  00287	44 89 54 24 2c	 mov	 DWORD PTR num_edges$1$[rsp], r10d
  0028c	4d 8b ca	 mov	 r9, r10
  0028f	f7 ff		 idiv	 edi
  00291	49 8b c0	 mov	 rax, r8
  00294	48 69 c0 a8 00
	00 00		 imul	 rax, 168		; 000000a8H
  0029b	48 63 ca	 movsxd	 rcx, edx
  0029e	48 69 c9 a8 00
	00 00		 imul	 rcx, 168		; 000000a8H
  002a5	f2 0f 10 44 19
	08		 movsdx	 xmm0, QWORD PTR [rcx+rbx+8]
  002ab	66 0f 2f 44 18
	08		 comisd	 xmm0, QWORD PTR [rax+rbx+8]
  002b1	76 37		 jbe	 SHORT $LN13@build_lmt
$LL14@build_lmt:

; 497  :           {
; 498  :             num_edges++;
; 499  :             max= NEXT_INDEX(max, num_vertices);

  002b3	4c 63 c2	 movsxd	 r8, edx
  002b6	41 ff c2	 inc	 r10d
  002b9	49 ff c1	 inc	 r9
  002bc	41 8d 40 01	 lea	 eax, DWORD PTR [r8+1]
  002c0	99		 cdq
  002c1	f7 ff		 idiv	 edi
  002c3	49 8b c0	 mov	 rax, r8
  002c6	48 69 c0 a8 00
	00 00		 imul	 rax, 168		; 000000a8H
  002cd	48 63 ca	 movsxd	 rcx, edx
  002d0	48 69 c9 a8 00
	00 00		 imul	 rcx, 168		; 000000a8H
  002d7	f2 0f 10 44 19
	08		 movsdx	 xmm0, QWORD PTR [rcx+rbx+8]
  002dd	66 0f 2f 44 18
	08		 comisd	 xmm0, QWORD PTR [rax+rbx+8]
  002e3	77 ce		 ja	 SHORT $LL14@build_lmt
  002e5	44 89 54 24 2c	 mov	 DWORD PTR num_edges$1$[rsp], r10d
$LN13@build_lmt:

; 500  :           }
; 501  : 
; 502  :           /* Build the next edge list */
; 503  :           e= &edge_table[e_index];
; 504  :           e_index+= num_edges;
; 505  :           v= min;
; 506  :           e[0].bstate[BELOW]= UNBUNDLED;

  002ea	33 c9		 xor	 ecx, ecx
  002ec	45 03 da	 add	 r11d, r10d
  002ef	48 8b f5	 mov	 rsi, rbp
  002f2	49 03 e9	 add	 rbp, r9
  002f5	41 8d 44 24 ff	 lea	 eax, DWORD PTR [r12-1]
  002fa	44 89 5c 24 24	 mov	 DWORD PTR e_index$1$[rsp], r11d
  002ff	48 69 f6 a8 00
	00 00		 imul	 rsi, 168		; 000000a8H
  00306	48 03 f3	 add	 rsi, rbx

; 507  :           e[0].bundle[BELOW][CLIP]= FALSE;
; 508  :           e[0].bundle[BELOW][SUBJ]= FALSE;
; 509  :           for (i= 0; i < num_edges; i++)

  00309	4c 3b c9	 cmp	 r9, rcx
  0030c	48 89 6c 24 38	 mov	 QWORD PTR $T112893[rsp], rbp
  00311	89 44 24 30	 mov	 DWORD PTR v$1$[rsp], eax
  00315	4c 8b d9	 mov	 r11, rcx
  00318	89 4e 68	 mov	 DWORD PTR [rsi+104], ecx
  0031b	89 4e 54	 mov	 DWORD PTR [rsi+84], ecx
  0031e	89 4e 58	 mov	 DWORD PTR [rsi+88], ecx
  00321	0f 8e 2a 01 00
	00		 jle	 $LN10@build_lmt

; 530  :             e[i].bside[CLIP]= (op == GPC_DIFF) ? RIGHT : LEFT;

  00327	39 8c 24 e8 00
	00 00		 cmp	 DWORD PTR op$[rsp], ecx
  0032e	44 8b 6c 24 2c	 mov	 r13d, DWORD PTR num_edges$1$[rsp]
  00333	44 8b 64 24 30	 mov	 r12d, DWORD PTR v$1$[rsp]
  00338	8b c1		 mov	 eax, ecx
  0033a	0f 94 c0	 sete	 al
  0033d	49 8b d7	 mov	 rdx, r15
  00340	4d 8d 77 08	 lea	 r14, QWORD PTR [r15+8]
  00344	44 8b bc 24 e0
	00 00 00	 mov	 r15d, DWORD PTR type$[rsp]
  0034c	4c 8d 46 20	 lea	 r8, QWORD PTR [rsi+32]
  00350	89 44 24 34	 mov	 DWORD PTR tv2824[rsp], eax
  00354	8b e8		 mov	 ebp, eax
  00356	41 83 ca ff	 or	 r10d, -1
$LL12@build_lmt:
  0035a	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  0035d	49 89 40 10	 mov	 QWORD PTR [r8+16], rax
  00361	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00364	49 89 40 f0	 mov	 QWORD PTR [r8-16], rax
  00368	49 8b 06	 mov	 rax, QWORD PTR [r14]
  0036b	49 89 40 f8	 mov	 QWORD PTR [r8-8], rax
  0036f	41 8d 44 24 01	 lea	 eax, DWORD PTR [r12+1]
  00374	99		 cdq
  00375	f7 ff		 idiv	 edi
  00377	4c 63 e2	 movsxd	 r12, edx
  0037a	49 8b d4	 mov	 rdx, r12
  0037d	48 69 d2 a8 00
	00 00		 imul	 rdx, 168		; 000000a8H
  00384	48 03 d3	 add	 rdx, rbx
  00387	49 83 f9 01	 cmp	 r9, 1
  0038b	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  0038e	4c 8d 72 08	 lea	 r14, QWORD PTR [rdx+8]
  00392	49 89 00	 mov	 QWORD PTR [r8], rax
  00395	f2 41 0f 10 0e	 movsdx	 xmm1, QWORD PTR [r14]
  0039a	f2 41 0f 11 48
	08		 movsdx	 QWORD PTR [r8+8], xmm1
  003a0	f2 0f 10 02	 movsdx	 xmm0, QWORD PTR [rdx]
  003a4	f2 41 0f 5c 48
	f8		 subsd	 xmm1, QWORD PTR [r8-8]
  003aa	45 89 78 28	 mov	 DWORD PTR [r8+40], r15d
  003ae	49 89 48 50	 mov	 QWORD PTR [r8+80], rcx
  003b2	49 89 48 58	 mov	 QWORD PTR [r8+88], rcx
  003b6	49 89 48 68	 mov	 QWORD PTR [r8+104], rcx
  003ba	49 89 48 60	 mov	 QWORD PTR [r8+96], rcx
  003be	f2 41 0f 5c 40
	f0		 subsd	 xmm0, QWORD PTR [r8-16]
  003c4	f2 0f 5e c1	 divsd	 xmm0, xmm1
  003c8	f2 41 0f 11 40
	20		 movsdx	 QWORD PTR [r8+32], xmm0
  003ce	7e 21		 jle	 SHORT $LN37@build_lmt
  003d0	41 8d 4a 01	 lea	 ecx, DWORD PTR [r10+1]
  003d4	41 8d 45 ff	 lea	 eax, DWORD PTR [r13-1]
  003d8	3b c8		 cmp	 ecx, eax
  003da	7d 13		 jge	 SHORT $LN76@build_lmt
  003dc	41 8d 42 02	 lea	 eax, DWORD PTR [r10+2]
  003e0	48 63 c8	 movsxd	 rcx, eax
  003e3	48 69 c9 a8 00
	00 00		 imul	 rcx, 168		; 000000a8H
  003ea	48 03 ce	 add	 rcx, rsi
  003ed	eb 02		 jmp	 SHORT $LN37@build_lmt
$LN76@build_lmt:

; 462  : 
; 463  :   for (c= 0; c < p->num_contours; c++)

  003ef	33 c9		 xor	 ecx, ecx
$LN37@build_lmt:

; 510  :           {
; 511  :             e[i].xb= edge_table[v].vertex.x;
; 512  :             e[i].bot.x= edge_table[v].vertex.x;
; 513  :             e[i].bot.y= edge_table[v].vertex.y;
; 514  : 
; 515  :             v= NEXT_INDEX(v, num_vertices);
; 516  : 
; 517  :             e[i].top.x= edge_table[v].vertex.x;
; 518  :             e[i].top.y= edge_table[v].vertex.y;
; 519  :             e[i].dx= (edge_table[v].vertex.x - e[i].bot.x) /
; 520  :                        (e[i].top.y - e[i].bot.y);
; 521  :             e[i].type= type;
; 522  :             e[i].outp[ABOVE]= NULL;
; 523  :             e[i].outp[BELOW]= NULL;
; 524  :             e[i].next= NULL;
; 525  :             e[i].prev= NULL;
; 526  :             e[i].succ= ((num_edges > 1) && (i < (num_edges - 1))) ?
; 527  :                        &(e[i + 1]) : NULL;

  003f1	49 89 48 78	 mov	 QWORD PTR [r8+120], rcx

; 528  :             e[i].pred= ((num_edges > 1) && (i > 0)) ? &(e[i - 1]) : NULL;

  003f5	33 c9		 xor	 ecx, ecx
  003f7	49 83 f9 01	 cmp	 r9, 1
  003fb	7e 14		 jle	 SHORT $LN39@build_lmt
  003fd	4c 3b d9	 cmp	 r11, rcx
  00400	7e 0f		 jle	 SHORT $LN39@build_lmt
  00402	49 63 c2	 movsxd	 rax, r10d
  00405	48 69 c0 a8 00
	00 00		 imul	 rax, 168		; 000000a8H
  0040c	48 03 c6	 add	 rax, rsi
  0040f	eb 03		 jmp	 SHORT $LN40@build_lmt
$LN39@build_lmt:
  00411	48 8b c1	 mov	 rax, rcx
$LN40@build_lmt:

; 507  :           e[0].bundle[BELOW][CLIP]= FALSE;
; 508  :           e[0].bundle[BELOW][SUBJ]= FALSE;
; 509  :           for (i= 0; i < num_edges; i++)

  00414	49 ff c3	 inc	 r11

; 528  :             e[i].pred= ((num_edges > 1) && (i > 0)) ? &(e[i - 1]) : NULL;

  00417	49 89 40 70	 mov	 QWORD PTR [r8+112], rax

; 529  :             e[i].next_bound= NULL;

  0041b	49 89 88 80 00
	00 00		 mov	 QWORD PTR [r8+128], rcx

; 530  :             e[i].bside[CLIP]= (op == GPC_DIFF) ? RIGHT : LEFT;

  00422	41 89 68 3c	 mov	 DWORD PTR [r8+60], ebp

; 531  :             e[i].bside[SUBJ]= LEFT;

  00426	41 89 48 40	 mov	 DWORD PTR [r8+64], ecx
  0042a	41 ff c2	 inc	 r10d
  0042d	49 81 c0 a8 00
	00 00		 add	 r8, 168			; 000000a8H
  00434	4d 3b d9	 cmp	 r11, r9
  00437	0f 8c 1d ff ff
	ff		 jl	 $LL12@build_lmt
  0043d	44 8b 64 24 20	 mov	 r12d, DWORD PTR tv2807[rsp]
  00442	4c 8b 74 24 40	 mov	 r14, QWORD PTR tv2804[rsp]
  00447	4c 8b 7c 24 48	 mov	 r15, QWORD PTR tv2803[rsp]
  0044c	48 8b 6c 24 38	 mov	 rbp, QWORD PTR $T112893[rsp]
$LN10@build_lmt:

; 532  :           }
; 533  :           insert_bound(bound_list(lmt, edge_table[min].vertex.y), e);

  00451	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR lmt$[rsp]
  00459	f2 41 0f 10 0e	 movsdx	 xmm1, QWORD PTR [r14]
  0045e	e8 00 00 00 00	 call	 bound_list
  00463	48 8b d6	 mov	 rdx, rsi
  00466	48 8b c8	 mov	 rcx, rax
  00469	e8 00 00 00 00	 call	 insert_bound
  0046e	44 8b 5c 24 24	 mov	 r11d, DWORD PTR e_index$1$[rsp]
$LN17@build_lmt:
  00473	41 ff c4	 inc	 r12d
  00476	ba a8 00 00 00	 mov	 edx, 168		; 000000a8H
  0047b	41 8d 44 24 ff	 lea	 eax, DWORD PTR [r12-1]
  00480	4c 03 fa	 add	 r15, rdx
  00483	4c 03 f2	 add	 r14, rdx
  00486	3b c7		 cmp	 eax, edi
  00488	8d 47 fe	 lea	 eax, DWORD PTR [rdi-2]
  0048b	44 89 64 24 20	 mov	 DWORD PTR tv2807[rsp], r12d
  00490	4c 89 7c 24 48	 mov	 QWORD PTR tv2803[rsp], r15
  00495	4c 89 74 24 40	 mov	 QWORD PTR tv2804[rsp], r14
  0049a	0f 8c 97 fd ff
	ff		 jl	 $LL18@build_lmt
  004a0	48 8b 6c 24 50	 mov	 rbp, QWORD PTR tv2783[rsp]
  004a5	4c 8b ac 24 d8
	00 00 00	 mov	 r13, QWORD PTR p$[rsp]
  004ad	44 8b 7c 24 28	 mov	 r15d, DWORD PTR c$1$[rsp]
$LN16@build_lmt:

; 534  :         }
; 535  :       }
; 536  : 
; 537  :       /* Do the contour reverse pass */
; 538  :       for (min= 0; min < num_vertices; min++)

  004b2	4d 63 d3	 movsxd	 r10, r11d
  004b5	85 ff		 test	 edi, edi
  004b7	0f 8e 78 02 00
	00		 jle	 $LN27@build_lmt
  004bd	8b c7		 mov	 eax, edi
  004bf	44 8d 67 ff	 lea	 r12d, DWORD PTR [rdi-1]
  004c3	4c 8d 73 08	 lea	 r14, QWORD PTR [rbx+8]
  004c7	f7 d8		 neg	 eax
  004c9	4c 8b eb	 mov	 r13, rbx
  004cc	48 89 5c 24 40	 mov	 QWORD PTR tv2790[rsp], rbx
  004d1	8d 48 02	 lea	 ecx, DWORD PTR [rax+2]
  004d4	8d 68 01	 lea	 ebp, DWORD PTR [rax+1]
  004d7	44 89 64 24 20	 mov	 DWORD PTR tv2795[rsp], r12d
  004dc	89 4c 24 38	 mov	 DWORD PTR tv2787[rsp], ecx
  004e0	89 6c 24 2c	 mov	 DWORD PTR tv2786[rsp], ebp
  004e4	4c 89 74 24 48	 mov	 QWORD PTR tv2793[rsp], r14
$LL9@build_lmt:

; 539  :       {
; 540  :       /* If a reverse local minimum... */
; 541  :         if (REV_MIN(edge_table, min, num_vertices))

  004e9	41 8b c4	 mov	 eax, r12d
  004ec	99		 cdq
  004ed	f7 ff		 idiv	 edi
  004ef	4c 63 c2	 movsxd	 r8, edx
  004f2	49 8b c0	 mov	 rax, r8
  004f5	48 69 c0 a8 00
	00 00		 imul	 rax, 168		; 000000a8H
  004fc	f2 0f 10 44 18
	08		 movsdx	 xmm0, QWORD PTR [rax+rbx+8]
  00502	66 41 0f 2f 06	 comisd	 xmm0, QWORD PTR [r14]
  00507	0f 86 ec 01 00
	00		 jbe	 $LN8@build_lmt
  0050d	42 8d 04 21	 lea	 eax, DWORD PTR [rcx+r12]
  00511	99		 cdq
  00512	f7 ff		 idiv	 edi
  00514	48 63 c2	 movsxd	 rax, edx
  00517	48 69 c0 a8 00
	00 00		 imul	 rax, 168		; 000000a8H
  0051e	f2 0f 10 44 18
	08		 movsdx	 xmm0, QWORD PTR [rax+rbx+8]
  00524	66 41 0f 2f 06	 comisd	 xmm0, QWORD PTR [r14]
  00529	0f 82 ca 01 00
	00		 jb	 $LN8@build_lmt

; 542  :         {
; 543  :           /* Search for the previous local maximum... */
; 544  :           num_edges= 1;

  0052f	41 bf 01 00 00
	00		 mov	 r15d, 1
  00535	4d 8b cf	 mov	 r9, r15

; 545  :           max= PREV_INDEX(min, num_vertices);
; 546  :           while (NOT_RMAX(edge_table, max, num_vertices))

  00538	eb 09		 jmp	 SHORT $LN81@build_lmt
$LL5@build_lmt:

; 547  :           {
; 548  :             num_edges++;

  0053a	41 ff c7	 inc	 r15d

; 549  :             max= PREV_INDEX(max, num_vertices);

  0053d	4c 63 c2	 movsxd	 r8, edx
  00540	49 ff c1	 inc	 r9
$LN81@build_lmt:
  00543	41 8d 44 38 ff	 lea	 eax, DWORD PTR [r8+rdi-1]
  00548	99		 cdq
  00549	f7 ff		 idiv	 edi
  0054b	49 8b c0	 mov	 rax, r8
  0054e	48 69 c0 a8 00
	00 00		 imul	 rax, 168		; 000000a8H
  00555	48 63 ca	 movsxd	 rcx, edx
  00558	48 69 c9 a8 00
	00 00		 imul	 rcx, 168		; 000000a8H
  0055f	f2 0f 10 44 19
	08		 movsdx	 xmm0, QWORD PTR [rcx+rbx+8]
  00565	66 0f 2f 44 18
	08		 comisd	 xmm0, QWORD PTR [rax+rbx+8]
  0056b	77 cd		 ja	 SHORT $LL5@build_lmt

; 550  :           }
; 551  : 
; 552  :           /* Build the previous edge list */
; 553  :           e= &edge_table[e_index];
; 554  :           e_index+= num_edges;
; 555  :           v= min;
; 556  :           e[0].bstate[BELOW]= UNBUNDLED;

  0056d	33 c9		 xor	 ecx, ecx
  0056f	45 03 df	 add	 r11d, r15d
  00572	49 8b f2	 mov	 rsi, r10
  00575	4d 03 d1	 add	 r10, r9
  00578	42 8d 44 25 00	 lea	 eax, DWORD PTR [rbp+r12]
  0057d	44 89 5c 24 24	 mov	 DWORD PTR e_index$1$[rsp], r11d
  00582	48 69 f6 a8 00
	00 00		 imul	 rsi, 168		; 000000a8H
  00589	48 03 f3	 add	 rsi, rbx

; 557  :           e[0].bundle[BELOW][CLIP]= FALSE;
; 558  :           e[0].bundle[BELOW][SUBJ]= FALSE;
; 559  :           for (i= 0; i < num_edges; i++)

  0058c	4c 3b c9	 cmp	 r9, rcx
  0058f	4c 89 54 24 60	 mov	 QWORD PTR $T112894[rsp], r10
  00594	89 44 24 34	 mov	 DWORD PTR v$2$[rsp], eax
  00598	4c 8b d9	 mov	 r11, rcx
  0059b	89 4e 68	 mov	 DWORD PTR [rsi+104], ecx
  0059e	89 4e 54	 mov	 DWORD PTR [rsi+84], ecx
  005a1	89 4e 58	 mov	 DWORD PTR [rsi+88], ecx
  005a4	0f 8e 24 01 00
	00		 jle	 $LN1@build_lmt

; 580  :             e[i].bside[CLIP]= (op == GPC_DIFF) ? RIGHT : LEFT;

  005aa	39 8c 24 e8 00
	00 00		 cmp	 DWORD PTR op$[rsp], ecx
  005b1	44 8b 64 24 34	 mov	 r12d, DWORD PTR v$2$[rsp]
  005b6	8b c1		 mov	 eax, ecx
  005b8	0f 94 c0	 sete	 al
  005bb	49 8b d5	 mov	 rdx, r13
  005be	4d 8d 75 08	 lea	 r14, QWORD PTR [r13+8]
  005c2	44 8b ac 24 e0
	00 00 00	 mov	 r13d, DWORD PTR type$[rsp]
  005ca	89 44 24 30	 mov	 DWORD PTR tv2823[rsp], eax
  005ce	8b e8		 mov	 ebp, eax
  005d0	41 83 ca ff	 or	 r10d, -1
  005d4	4c 8d 46 20	 lea	 r8, QWORD PTR [rsi+32]
$LL3@build_lmt:
  005d8	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  005db	49 89 40 10	 mov	 QWORD PTR [r8+16], rax
  005df	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  005e2	49 89 40 f0	 mov	 QWORD PTR [r8-16], rax
  005e6	49 8b 06	 mov	 rax, QWORD PTR [r14]
  005e9	49 89 40 f8	 mov	 QWORD PTR [r8-8], rax
  005ed	41 8d 44 3c ff	 lea	 eax, DWORD PTR [r12+rdi-1]
  005f2	99		 cdq
  005f3	f7 ff		 idiv	 edi
  005f5	4c 63 e2	 movsxd	 r12, edx
  005f8	49 8b d4	 mov	 rdx, r12
  005fb	48 69 d2 a8 00
	00 00		 imul	 rdx, 168		; 000000a8H
  00602	48 03 d3	 add	 rdx, rbx
  00605	49 83 f9 01	 cmp	 r9, 1
  00609	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  0060c	4c 8d 72 08	 lea	 r14, QWORD PTR [rdx+8]
  00610	49 89 00	 mov	 QWORD PTR [r8], rax
  00613	f2 41 0f 10 0e	 movsdx	 xmm1, QWORD PTR [r14]
  00618	f2 41 0f 11 48
	08		 movsdx	 QWORD PTR [r8+8], xmm1
  0061e	f2 0f 10 02	 movsdx	 xmm0, QWORD PTR [rdx]
  00622	f2 41 0f 5c 48
	f8		 subsd	 xmm1, QWORD PTR [r8-8]
  00628	45 89 68 28	 mov	 DWORD PTR [r8+40], r13d
  0062c	49 89 48 50	 mov	 QWORD PTR [r8+80], rcx
  00630	49 89 48 58	 mov	 QWORD PTR [r8+88], rcx
  00634	49 89 48 68	 mov	 QWORD PTR [r8+104], rcx
  00638	49 89 48 60	 mov	 QWORD PTR [r8+96], rcx
  0063c	f2 41 0f 5c 40
	f0		 subsd	 xmm0, QWORD PTR [r8-16]
  00642	f2 0f 5e c1	 divsd	 xmm0, xmm1
  00646	f2 41 0f 11 40
	20		 movsdx	 QWORD PTR [r8+32], xmm0
  0064c	7e 21		 jle	 SHORT $LN41@build_lmt
  0064e	41 8d 4a 01	 lea	 ecx, DWORD PTR [r10+1]
  00652	41 8d 47 ff	 lea	 eax, DWORD PTR [r15-1]
  00656	3b c8		 cmp	 ecx, eax
  00658	7d 13		 jge	 SHORT $LN78@build_lmt
  0065a	41 8d 42 02	 lea	 eax, DWORD PTR [r10+2]
  0065e	48 63 c8	 movsxd	 rcx, eax
  00661	48 69 c9 a8 00
	00 00		 imul	 rcx, 168		; 000000a8H
  00668	48 03 ce	 add	 rcx, rsi
  0066b	eb 02		 jmp	 SHORT $LN41@build_lmt
$LN78@build_lmt:

; 462  : 
; 463  :   for (c= 0; c < p->num_contours; c++)

  0066d	33 c9		 xor	 ecx, ecx
$LN41@build_lmt:

; 560  :           {
; 561  :             e[i].xb= edge_table[v].vertex.x;
; 562  :             e[i].bot.x= edge_table[v].vertex.x;
; 563  :             e[i].bot.y= edge_table[v].vertex.y;
; 564  : 
; 565  :             v= PREV_INDEX(v, num_vertices);
; 566  : 
; 567  :             e[i].top.x= edge_table[v].vertex.x;
; 568  :             e[i].top.y= edge_table[v].vertex.y;
; 569  :             e[i].dx= (edge_table[v].vertex.x - e[i].bot.x) /
; 570  :                        (e[i].top.y - e[i].bot.y);
; 571  :             e[i].type= type;
; 572  :             e[i].outp[ABOVE]= NULL;
; 573  :             e[i].outp[BELOW]= NULL;
; 574  :             e[i].next= NULL;
; 575  :             e[i].prev= NULL;
; 576  :             e[i].succ= ((num_edges > 1) && (i < (num_edges - 1))) ?
; 577  :                        &(e[i + 1]) : NULL;

  0066f	49 89 48 78	 mov	 QWORD PTR [r8+120], rcx

; 578  :             e[i].pred= ((num_edges > 1) && (i > 0)) ? &(e[i - 1]) : NULL;

  00673	33 c9		 xor	 ecx, ecx
  00675	49 83 f9 01	 cmp	 r9, 1
  00679	7e 14		 jle	 SHORT $LN43@build_lmt
  0067b	4c 3b d9	 cmp	 r11, rcx
  0067e	7e 0f		 jle	 SHORT $LN43@build_lmt
  00680	49 63 c2	 movsxd	 rax, r10d
  00683	48 69 c0 a8 00
	00 00		 imul	 rax, 168		; 000000a8H
  0068a	48 03 c6	 add	 rax, rsi
  0068d	eb 03		 jmp	 SHORT $LN44@build_lmt
$LN43@build_lmt:
  0068f	48 8b c1	 mov	 rax, rcx
$LN44@build_lmt:

; 557  :           e[0].bundle[BELOW][CLIP]= FALSE;
; 558  :           e[0].bundle[BELOW][SUBJ]= FALSE;
; 559  :           for (i= 0; i < num_edges; i++)

  00692	49 ff c3	 inc	 r11

; 578  :             e[i].pred= ((num_edges > 1) && (i > 0)) ? &(e[i - 1]) : NULL;

  00695	49 89 40 70	 mov	 QWORD PTR [r8+112], rax

; 579  :             e[i].next_bound= NULL;

  00699	49 89 88 80 00
	00 00		 mov	 QWORD PTR [r8+128], rcx

; 580  :             e[i].bside[CLIP]= (op == GPC_DIFF) ? RIGHT : LEFT;

  006a0	41 89 68 3c	 mov	 DWORD PTR [r8+60], ebp

; 581  :             e[i].bside[SUBJ]= LEFT;

  006a4	41 89 48 40	 mov	 DWORD PTR [r8+64], ecx
  006a8	41 ff c2	 inc	 r10d
  006ab	49 81 c0 a8 00
	00 00		 add	 r8, 168			; 000000a8H
  006b2	4d 3b d9	 cmp	 r11, r9
  006b5	0f 8c 1d ff ff
	ff		 jl	 $LL3@build_lmt
  006bb	44 8b 64 24 20	 mov	 r12d, DWORD PTR tv2795[rsp]
  006c0	4c 8b 74 24 48	 mov	 r14, QWORD PTR tv2793[rsp]
  006c5	4c 8b 6c 24 40	 mov	 r13, QWORD PTR tv2790[rsp]
  006ca	8b 6c 24 2c	 mov	 ebp, DWORD PTR tv2786[rsp]
$LN1@build_lmt:

; 582  :           }
; 583  :           insert_bound(bound_list(lmt, edge_table[min].vertex.y), e);

  006ce	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR lmt$[rsp]
  006d6	f2 41 0f 10 0e	 movsdx	 xmm1, QWORD PTR [r14]
  006db	e8 00 00 00 00	 call	 bound_list
  006e0	48 8b d6	 mov	 rdx, rsi
  006e3	48 8b c8	 mov	 rcx, rax
  006e6	e8 00 00 00 00	 call	 insert_bound
  006eb	4c 8b 54 24 60	 mov	 r10, QWORD PTR $T112894[rsp]
  006f0	8b 4c 24 38	 mov	 ecx, DWORD PTR tv2787[rsp]
  006f4	44 8b 5c 24 24	 mov	 r11d, DWORD PTR e_index$1$[rsp]
$LN8@build_lmt:
  006f9	41 ff c4	 inc	 r12d
  006fc	ba a8 00 00 00	 mov	 edx, 168		; 000000a8H
  00701	4c 03 ea	 add	 r13, rdx
  00704	4c 03 f2	 add	 r14, rdx
  00707	42 8d 44 25 00	 lea	 eax, DWORD PTR [rbp+r12]
  0070c	3b c7		 cmp	 eax, edi
  0070e	44 89 64 24 20	 mov	 DWORD PTR tv2795[rsp], r12d
  00713	4c 89 6c 24 40	 mov	 QWORD PTR tv2790[rsp], r13
  00718	4c 89 74 24 48	 mov	 QWORD PTR tv2793[rsp], r14
  0071d	0f 8c c6 fd ff
	ff		 jl	 $LL9@build_lmt
  00723	48 8b 6c 24 50	 mov	 rbp, QWORD PTR tv2783[rsp]
  00728	4c 8b ac 24 d8
	00 00 00	 mov	 r13, QWORD PTR p$[rsp]
  00730	44 8b 7c 24 28	 mov	 r15d, DWORD PTR c$1$[rsp]
$LN27@build_lmt:
  00735	41 ff c7	 inc	 r15d
  00738	48 83 c5 10	 add	 rbp, 16
  0073c	45 3b 7d 00	 cmp	 r15d, DWORD PTR [r13]
  00740	44 89 7c 24 28	 mov	 DWORD PTR c$1$[rsp], r15d
  00745	48 89 6c 24 50	 mov	 QWORD PTR tv2783[rsp], rbp
  0074a	0f 8c cd f9 ff
	ff		 jl	 $LL28@build_lmt
$LN26@build_lmt:

; 584  :         }
; 585  :       }
; 586  :     }
; 587  :   }
; 588  :   return edge_table;

  00750	48 8b c3	 mov	 rax, rbx

; 589  : }

  00753	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00757	41 5f		 pop	 r15
  00759	41 5e		 pop	 r14
  0075b	41 5d		 pop	 r13
  0075d	41 5c		 pop	 r12
  0075f	5f		 pop	 rdi
  00760	5e		 pop	 rsi
  00761	5d		 pop	 rbp
  00762	5b		 pop	 rbx
  00763	c3		 ret	 0
$LN79@build_lmt:
build_lmt ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$build_intersection_table DD imagerel build_intersection_table
	DD	imagerel build_intersection_table+175
	DD	imagerel $unwind$build_intersection_table
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$build_intersection_table DD 081801H
	DD	026818H
	DD	0a640fH
	DD	09340fH
	DD	0700b520fH
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT build_intersection_table
_TEXT	SEGMENT
st$ = 64
it$ = 64
aet$ = 72
dy$ = 80
build_intersection_table PROC				; COMDAT

; 727  : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 728  :   st_node   *st, *stp;
; 729  :   edge_node *edge;
; 730  : 
; 731  :   /* Build intersection table for the current scanbeam */
; 732  :   reset_it(it);

  0000f	48 83 39 00	 cmp	 QWORD PTR [rcx], 0
  00013	0f 29 74 24 20	 movaps	 XMMWORD PTR [rsp+32], xmm6
  00018	48 8b da	 mov	 rbx, rdx
  0001b	66 0f 28 f2	 movapd	 xmm6, xmm2
  0001f	48 8b f9	 mov	 rdi, rcx
  00022	74 1e		 je	 SHORT $LN12@build_inte
$LL13@build_inte:
  00024	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
  00027	48 8b 71 20	 mov	 rsi, QWORD PTR [rcx+32]
  0002b	48 85 c9	 test	 rcx, rcx
  0002e	74 09		 je	 SHORT $LN11@build_inte
  00030	e8 00 00 00 00	 call	 free
  00035	48 83 27 00	 and	 QWORD PTR [rdi], 0
$LN11@build_inte:
  00039	48 89 37	 mov	 QWORD PTR [rdi], rsi
  0003c	48 83 fe 00	 cmp	 rsi, 0
  00040	75 e2		 jne	 SHORT $LL13@build_inte
$LN12@build_inte:

; 733  :   st= NULL;

  00042	48 83 64 24 40
	00		 and	 QWORD PTR st$[rsp], 0

; 734  : 
; 735  :   /* Process each AET edge */
; 736  :   for (edge= aet; edge; edge= edge->next)

  00048	48 85 db	 test	 rbx, rbx
  0004b	74 4d		 je	 SHORT $LN2@build_inte
$LL8@build_inte:

; 737  :   {
; 738  :     if ((edge->bstate[ABOVE] == BUNDLE_HEAD) ||
; 739  :          edge->bundle[ABOVE][CLIP] || edge->bundle[ABOVE][SUBJ])

  0004d	83 7b 64 01	 cmp	 DWORD PTR [rbx+100], 1
  00051	74 0c		 je	 SHORT $LN4@build_inte
  00053	83 7b 4c 00	 cmp	 DWORD PTR [rbx+76], 0
  00057	75 06		 jne	 SHORT $LN4@build_inte
  00059	83 7b 50 00	 cmp	 DWORD PTR [rbx+80], 0
  0005d	74 14		 je	 SHORT $LN7@build_inte
$LN4@build_inte:

; 740  :       add_st_edge(&st, it, edge, dy);

  0005f	48 8d 4c 24 40	 lea	 rcx, QWORD PTR st$[rsp]
  00064	66 0f 28 de	 movapd	 xmm3, xmm6
  00068	4c 8b c3	 mov	 r8, rbx
  0006b	48 8b d7	 mov	 rdx, rdi
  0006e	e8 00 00 00 00	 call	 add_st_edge
$LN7@build_inte:
  00073	48 8b 9b 88 00
	00 00		 mov	 rbx, QWORD PTR [rbx+136]
  0007a	48 85 db	 test	 rbx, rbx
  0007d	75 ce		 jne	 SHORT $LL8@build_inte

; 741  :   }
; 742  : 
; 743  :   /* Free the sorted edge table */
; 744  :   while (st)

  0007f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR st$[rsp]
  00084	48 85 c9	 test	 rcx, rcx
  00087	74 11		 je	 SHORT $LN2@build_inte
$LL3@build_inte:

; 745  :   {
; 746  :     stp= st->prev;

  00089	48 8b 59 20	 mov	 rbx, QWORD PTR [rcx+32]

; 747  :     FREE(st);

  0008d	e8 00 00 00 00	 call	 free

; 748  :     st= stp;

  00092	48 8b cb	 mov	 rcx, rbx
  00095	48 85 db	 test	 rbx, rbx
  00098	75 ef		 jne	 SHORT $LL3@build_inte
$LN2@build_inte:

; 749  :   }
; 750  : }

  0009a	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  0009f	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  000a4	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  000a9	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000ad	5f		 pop	 rdi
  000ae	c3		 ret	 0
build_intersection_table ENDP
PUBLIC	gpc_polygon_clip
;	COMDAT pdata
pdata	SEGMENT
$pdata$gpc_polygon_clip DD imagerel $LN377
	DD	imagerel $LN377+5042
	DD	imagerel $unwind$gpc_polygon_clip
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gpc_polygon_clip DD 0194a01H
	DD	0bc84aH
	DD	0cb842H
	DD	0da83aH
	DD	0e9832H
	DD	0f882dH
	DD	0107828H
	DD	0116824H
	DD	02e3420H
	DD	0240120H
	DD	0e017f019H
	DD	0c013d015H
	DD	060107011H
	DD	0500fH
; Function compile flags: /Ogspy
xdata	ENDS
;	COMDAT gpc_polygon_clip
_TEXT	SEGMENT
br$ = 48
tl$ = 52
tr$ = 56
bl$ = 60
cf$1$ = 64
scanbeam$ = 72
sbt_entries$ = 76
parity$2$ = 80
sbtree$ = 80
out_poly$ = 88
contributing$ = 96
lmt$ = 96
it$ = 104
aet$ = 112
s_heap$1$ = 120
sbt$1$ = 128
lmt$1$ = 136
st$113967 = 144
local_min$1$ = 152
c_heap$1$ = 160
op$ = 352
parity$3$ = 360
dy$ = 360
yt$ = 360
subj$ = 360
clip$ = 368
result$ = 376
gpc_polygon_clip PROC					; COMDAT

; 1144 : {

$LN377:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 18	 mov	 QWORD PTR [rax+24], rbx
  00007	4c 89 48 20	 mov	 QWORD PTR [rax+32], r9
  0000b	89 48 08	 mov	 DWORD PTR [rax+8], ecx
  0000e	55		 push	 rbp
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	41 54		 push	 r12
  00013	41 55		 push	 r13
  00015	41 56		 push	 r14
  00017	41 57		 push	 r15
  00019	48 81 ec 20 01
	00 00		 sub	 rsp, 288		; 00000120H
  00020	0f 29 70 b8	 movaps	 XMMWORD PTR [rax-72], xmm6
  00024	0f 29 78 a8	 movaps	 XMMWORD PTR [rax-88], xmm7
  00028	44 0f 29 40 98	 movaps	 XMMWORD PTR [rax-104], xmm8

; 1147 :   edge_node     *edge, *prev_edge, *next_edge, *succ_edge, *e0, *e1;
; 1148 :   edge_node     *aet= NULL, *c_heap= NULL, *s_heap= NULL;

  0002d	44 0f 29 48 88	 movaps	 XMMWORD PTR [rax-120], xmm9
  00032	44 0f 29 90 78
	ff ff ff	 movaps	 XMMWORD PTR [rax-136], xmm10
  0003a	44 0f 29 98 68
	ff ff ff	 movaps	 XMMWORD PTR [rax-152], xmm11
  00042	44 0f 29 a0 58
	ff ff ff	 movaps	 XMMWORD PTR [rax-168], xmm12

; 1144 : {

  0004a	48 8b fa	 mov	 rdi, rdx

; 1145 :   sb_tree       *sbtree= NULL;

  0004d	33 d2		 xor	 edx, edx
  0004f	44 8b e1	 mov	 r12d, ecx
  00052	4d 8b e9	 mov	 r13, r9
  00055	49 8b d8	 mov	 rbx, r8
  00058	48 89 54 24 50	 mov	 QWORD PTR sbtree$[rsp], rdx

; 1146 :   it_node       *it= NULL, *intersect;

  0005d	48 89 54 24 68	 mov	 QWORD PTR it$[rsp], rdx

; 1147 :   edge_node     *edge, *prev_edge, *next_edge, *succ_edge, *e0, *e1;
; 1148 :   edge_node     *aet= NULL, *c_heap= NULL, *s_heap= NULL;

  00062	4c 8b fa	 mov	 r15, rdx
  00065	48 89 54 24 70	 mov	 QWORD PTR aet$[rsp], rdx
  0006a	48 8b ea	 mov	 rbp, rdx
  0006d	48 89 94 24 a0
	00 00 00	 mov	 QWORD PTR c_heap$1$[rsp], rdx
  00075	48 89 54 24 78	 mov	 QWORD PTR s_heap$1$[rsp], rdx
  0007a	48 8b c2	 mov	 rax, rdx

; 1149 :   lmt_node      *lmt= NULL, *local_min;

  0007d	48 8b f2	 mov	 rsi, rdx
  00080	48 89 94 24 88
	00 00 00	 mov	 QWORD PTR lmt$1$[rsp], rdx
  00088	48 89 54 24 60	 mov	 QWORD PTR lmt$[rsp], rdx

; 1150 :   polygon_node  *out_poly= NULL, *p, *q, *poly, *npoly, *cf= NULL;

  0008d	4c 8b f2	 mov	 r14, rdx
  00090	48 89 54 24 58	 mov	 QWORD PTR out_poly$[rsp], rdx
  00095	48 89 54 24 40	 mov	 QWORD PTR cf$1$[rsp], rdx

; 1151 :   vertex_node   *vtx, *nv;
; 1152 :   h_state        horiz[2];
; 1153 :   int            in[2], exists[2], parity[2]= {LEFT, LEFT};

  0009a	89 94 24 68 01
	00 00		 mov	 DWORD PTR parity$3$[rsp], edx

; 1154 :   int            c, v, contributing, search, scanbeam= 0, sbt_entries= 0;

  000a1	89 54 24 48	 mov	 DWORD PTR scanbeam$[rsp], edx
  000a5	89 54 24 4c	 mov	 DWORD PTR sbt_entries$[rsp], edx

; 1155 :   int            vclass, bl, br, tl, tr;
; 1156 :   double        *sbt= NULL, xb, px, yb, yt, dy, ix, iy;
; 1157 : 
; 1158 :   /* Test for trivial NULL result cases */
; 1159 :   if (((subj->num_contours == 0) && (clip->num_contours == 0))
; 1160 :    || ((subj->num_contours == 0) && ((op == GPC_INT) || (op == GPC_DIFF)))
; 1161 :    || ((clip->num_contours == 0) &&  (op == GPC_INT)))

  000a9	8d 4a 01	 lea	 ecx, QWORD PTR [rdx+1]
  000ac	39 17		 cmp	 DWORD PTR [rdi], edx
  000ae	75 0f		 jne	 SHORT $LN157@gpc_polygo
  000b0	41 39 10	 cmp	 DWORD PTR [r8], edx
  000b3	74 14		 je	 SHORT $LN159@gpc_polygo
  000b5	44 3b e1	 cmp	 r12d, ecx
  000b8	74 0f		 je	 SHORT $LN159@gpc_polygo
  000ba	44 3b e2	 cmp	 r12d, edx
  000bd	74 0a		 je	 SHORT $LN159@gpc_polygo
$LN157@gpc_polygo:
  000bf	41 39 10	 cmp	 DWORD PTR [r8], edx
  000c2	75 15		 jne	 SHORT $LN160@gpc_polygo
  000c4	44 3b e1	 cmp	 r12d, ecx
  000c7	75 15		 jne	 SHORT $LN323@gpc_polygo
$LN159@gpc_polygo:

; 1162 :   {
; 1163 :     result->num_contours= 0;

  000c9	41 89 11	 mov	 DWORD PTR [r9], edx

; 1164 :     result->hole= NULL;

  000cc	49 89 51 08	 mov	 QWORD PTR [r9+8], rdx

; 1165 :     result->contour= NULL;

  000d0	49 89 51 10	 mov	 QWORD PTR [r9+16], rdx

; 1166 :     return;

  000d4	e9 9b 12 00 00	 jmp	 $LN1@gpc_polygo
$LN160@gpc_polygo:

; 1167 :   }
; 1168 : 
; 1169 :   /* Identify potentialy contributing contours */
; 1170 :   if (((op == GPC_INT) || (op == GPC_DIFF))
; 1171 :    && (subj->num_contours > 0) && (clip->num_contours > 0))

  000d9	44 3b e1	 cmp	 r12d, ecx
  000dc	74 05		 je	 SHORT $LN155@gpc_polygo
$LN323@gpc_polygo:
  000de	44 3b e2	 cmp	 r12d, edx
  000e1	75 1f		 jne	 SHORT $LN156@gpc_polygo
$LN155@gpc_polygo:
  000e3	39 17		 cmp	 DWORD PTR [rdi], edx
  000e5	7e 53		 jle	 SHORT $LN154@gpc_polygo
  000e7	41 39 10	 cmp	 DWORD PTR [r8], edx
  000ea	7e 16		 jle	 SHORT $LN156@gpc_polygo

; 1172 :     minimax_test(subj, clip, op);

  000ec	45 8b c4	 mov	 r8d, r12d
  000ef	48 8b d3	 mov	 rdx, rbx
  000f2	48 8b cf	 mov	 rcx, rdi
  000f5	e8 00 00 00 00	 call	 minimax_test
  000fa	33 d2		 xor	 edx, edx
  000fc	48 8b c6	 mov	 rax, rsi
  000ff	8d 4a 01	 lea	 ecx, QWORD PTR [rdx+1]
$LN156@gpc_polygo:

; 1173 : 
; 1174 :   /* Build LMT */
; 1175 :   if (subj->num_contours > 0)

  00102	39 17		 cmp	 DWORD PTR [rdi], edx
  00104	7e 34		 jle	 SHORT $LN154@gpc_polygo

; 1176 :     s_heap= build_lmt(&lmt, &sbtree, &sbt_entries, subj, SUBJ, op);

  00106	44 89 64 24 28	 mov	 DWORD PTR [rsp+40], r12d
  0010b	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  0010f	4c 8d 44 24 4c	 lea	 r8, QWORD PTR sbt_entries$[rsp]
  00114	48 8d 4c 24 60	 lea	 rcx, QWORD PTR lmt$[rsp]
  00119	48 8d 54 24 50	 lea	 rdx, QWORD PTR sbtree$[rsp]
  0011e	4c 8b cf	 mov	 r9, rdi
  00121	e8 00 00 00 00	 call	 build_lmt
  00126	48 8b 74 24 60	 mov	 rsi, QWORD PTR lmt$[rsp]
  0012b	33 d2		 xor	 edx, edx
  0012d	48 89 b4 24 88
	00 00 00	 mov	 QWORD PTR lmt$1$[rsp], rsi
  00135	48 89 44 24 78	 mov	 QWORD PTR s_heap$1$[rsp], rax
$LN154@gpc_polygo:

; 1177 :   if (clip->num_contours > 0)

  0013a	39 13		 cmp	 DWORD PTR [rbx], edx
  0013c	7e 3f		 jle	 SHORT $LN153@gpc_polygo

; 1178 :     c_heap= build_lmt(&lmt, &sbtree, &sbt_entries, clip, CLIP, op);

  0013e	44 89 64 24 28	 mov	 DWORD PTR [rsp+40], r12d
  00143	89 54 24 20	 mov	 DWORD PTR [rsp+32], edx
  00147	4c 8d 44 24 4c	 lea	 r8, QWORD PTR sbt_entries$[rsp]
  0014c	48 8d 54 24 50	 lea	 rdx, QWORD PTR sbtree$[rsp]
  00151	48 8d 4c 24 60	 lea	 rcx, QWORD PTR lmt$[rsp]
  00156	4c 8b cb	 mov	 r9, rbx
  00159	e8 00 00 00 00	 call	 build_lmt
  0015e	48 8b 74 24 60	 mov	 rsi, QWORD PTR lmt$[rsp]
  00163	33 d2		 xor	 edx, edx
  00165	48 8b e8	 mov	 rbp, rax
  00168	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR c_heap$1$[rsp], rax
  00170	48 8b 44 24 78	 mov	 rax, QWORD PTR s_heap$1$[rsp]
  00175	48 89 b4 24 88
	00 00 00	 mov	 QWORD PTR lmt$1$[rsp], rsi
$LN153@gpc_polygo:

; 1179 : 
; 1180 :   /* Return a NULL result if no contours contribute */
; 1181 :   if (lmt == NULL)

  0017d	48 3b f2	 cmp	 rsi, rdx
  00180	75 2c		 jne	 SHORT $LN152@gpc_polygo

; 1182 :   {
; 1183 :     result->num_contours= 0;

  00182	41 89 55 00	 mov	 DWORD PTR [r13], edx

; 1184 :     result->hole= NULL;

  00186	49 89 55 08	 mov	 QWORD PTR [r13+8], rdx

; 1185 :     result->contour= NULL;

  0018a	49 89 55 10	 mov	 QWORD PTR [r13+16], rdx

; 1186 :     reset_lmt(&lmt);
; 1187 :     FREE(s_heap);

  0018e	48 3b c2	 cmp	 rax, rdx
  00191	74 0a		 je	 SHORT $LN151@gpc_polygo
  00193	48 8b c8	 mov	 rcx, rax
  00196	e8 00 00 00 00	 call	 free
  0019b	33 d2		 xor	 edx, edx
$LN151@gpc_polygo:

; 1188 :     FREE(c_heap);

  0019d	48 3b ea	 cmp	 rbp, rdx
  001a0	0f 84 ce 11 00
	00		 je	 $LN1@gpc_polygo
  001a6	48 8b cd	 mov	 rcx, rbp

; 1189 :     return;

  001a9	e9 c1 11 00 00	 jmp	 $LN359@gpc_polygo
$LN152@gpc_polygo:

; 1190 :   }
; 1191 : 
; 1192 :   /* Build scanbeam table from scanbeam tree */
; 1193 :   MALLOC(sbt, sbt_entries * sizeof(double), "sbt creation", double);

  001ae	48 63 4c 24 4c	 movsxd	 rcx, DWORD PTR sbt_entries$[rsp]
  001b3	48 c1 e1 03	 shl	 rcx, 3
  001b7	48 3b ca	 cmp	 rcx, rdx
  001ba	76 39		 jbe	 SHORT $LN149@gpc_polygo
  001bc	e8 00 00 00 00	 call	 malloc
  001c1	48 8b e8	 mov	 rbp, rax
  001c4	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR sbt$1$[rsp], rax
  001cc	48 85 c0	 test	 rax, rax
  001cf	75 2f		 jne	 SHORT $LN147@gpc_polygo
  001d1	e8 00 00 00 00	 call	 __iob_func
  001d6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0N@FBEONJIC@sbt?5creation?$AA@
  001dd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@GBJAADOD@gpc?5malloc?5failure?3?5?$CFs?6?$AA@
  001e4	48 8d 48 60	 lea	 rcx, QWORD PTR [rax+96]
  001e8	e8 00 00 00 00	 call	 fprintf
  001ed	33 c9		 xor	 ecx, ecx
  001ef	e8 00 00 00 00	 call	 exit
  001f4	cc		 int	 3
$LN149@gpc_polygo:
  001f5	48 8b ea	 mov	 rbp, rdx
  001f8	48 89 94 24 80
	00 00 00	 mov	 QWORD PTR sbt$1$[rsp], rdx
$LN147@gpc_polygo:

; 1194 :   build_sbt(&scanbeam, sbt, sbtree);

  00200	4c 8b 44 24 50	 mov	 r8, QWORD PTR sbtree$[rsp]
  00205	48 8d 4c 24 48	 lea	 rcx, QWORD PTR scanbeam$[rsp]
  0020a	48 8b d5	 mov	 rdx, rbp
  0020d	e8 00 00 00 00	 call	 build_sbt

; 1195 :   scanbeam= 0;

  00212	44 21 74 24 48	 and	 DWORD PTR scanbeam$[rsp], r14d

; 1196 :   free_sbtree(&sbtree);

  00217	48 8d 4c 24 50	 lea	 rcx, QWORD PTR sbtree$[rsp]
  0021c	e8 00 00 00 00	 call	 free_sbtree

; 1197 : 
; 1198 :   /* Allow pointer re-use without causing memory leak */
; 1199 :   if (subj == result)

  00221	49 3b fd	 cmp	 rdi, r13
  00224	75 08		 jne	 SHORT $LN146@gpc_polygo

; 1200 :     gpc_free_polygon(subj);

  00226	48 8b cf	 mov	 rcx, rdi
  00229	e8 00 00 00 00	 call	 gpc_free_polygon
$LN146@gpc_polygo:

; 1201 :   if (clip == result)

  0022e	49 3b dd	 cmp	 rbx, r13
  00231	75 08		 jne	 SHORT $LN145@gpc_polygo

; 1202 :     gpc_free_polygon(clip);

  00233	48 8b cb	 mov	 rcx, rbx
  00236	e8 00 00 00 00	 call	 gpc_free_polygon
$LN145@gpc_polygo:

; 1203 : 
; 1204 :   /* Invert clip polygon for difference operation */
; 1205 :   if (op == GPC_DIFF)
; 1206 :     parity[CLIP]= RIGHT;
; 1207 : 
; 1208 :   local_min= lmt;
; 1209 : 
; 1210 :   /* Process each scanbeam */
; 1211 :   while (scanbeam < sbt_entries)

  0023b	8b 54 24 48	 mov	 edx, DWORD PTR scanbeam$[rsp]
  0023f	33 c0		 xor	 eax, eax
  00241	45 85 e4	 test	 r12d, r12d
  00244	44 8d 58 01	 lea	 r11d, QWORD PTR [rax+1]
  00248	4c 8b d6	 mov	 r10, rsi
  0024b	48 89 b4 24 98
	00 00 00	 mov	 QWORD PTR local_min$1$[rsp], rsi
  00253	41 0f 44 c3	 cmove	 eax, r11d
  00257	3b 54 24 4c	 cmp	 edx, DWORD PTR sbt_entries$[rsp]
  0025b	89 44 24 50	 mov	 DWORD PTR parity$2$[rsp], eax
  0025f	0f 8d 8c 0e 00
	00		 jge	 $LN322@gpc_polygo
  00265	f2 44 0f 10 1d
	00 00 00 00	 movsdx	 xmm11, QWORD PTR __mask@@AbsDouble@
  0026e	f2 44 0f 10 25
	00 00 00 00	 movsdx	 xmm12, QWORD PTR __real@3cb0000000000000
  00277	f2 44 0f 10 8c
	24 68 01 00 00	 movsdx	 xmm9, QWORD PTR yt$[rsp]
  00281	f2 44 0f 10 94
	24 68 01 00 00	 movsdx	 xmm10, QWORD PTR dy$[rsp]
$LL143@gpc_polygo:

; 1212 :   {
; 1213 :     /* Set yb and yt to the bottom and top of the scanbeam */
; 1214 :     yb= sbt[scanbeam++];

  0028b	48 63 c2	 movsxd	 rax, edx
  0028e	41 03 d3	 add	 edx, r11d

; 1215 :     if (scanbeam < sbt_entries)

  00291	3b 54 24 4c	 cmp	 edx, DWORD PTR sbt_entries$[rsp]
  00295	f2 44 0f 10 44
	c5 00		 movsdx	 xmm8, QWORD PTR [rbp+rax*8]
  0029c	89 54 24 48	 mov	 DWORD PTR scanbeam$[rsp], edx
  002a0	7d 14		 jge	 SHORT $LN141@gpc_polygo

; 1216 :     {
; 1217 :       yt= sbt[scanbeam];

  002a2	48 63 c2	 movsxd	 rax, edx
  002a5	f2 44 0f 10 4c
	c5 00		 movsdx	 xmm9, QWORD PTR [rbp+rax*8]

; 1218 :       dy= yt - yb;

  002ac	66 45 0f 28 d1	 movapd	 xmm10, xmm9
  002b1	f2 45 0f 5c d0	 subsd	 xmm10, xmm8
$LN141@gpc_polygo:

; 1219 :     }
; 1220 : 
; 1221 :     /* === SCANBEAM BOUNDARY PROCESSING ================================ */
; 1222 : 
; 1223 :     /* If LMT node corresponding to yb exists */
; 1224 :     if (local_min)

  002b6	4d 85 d2	 test	 r10, r10
  002b9	74 5d		 je	 SHORT $LN139@gpc_polygo

; 1225 :     {
; 1226 :       if (local_min->y == yb)

  002bb	f2 41 0f 10 02	 movsdx	 xmm0, QWORD PTR [r10]
  002c0	66 41 0f 2e c0	 ucomisd xmm0, xmm8
  002c5	7a 51		 jp	 SHORT $LN139@gpc_polygo
  002c7	75 4f		 jne	 SHORT $LN139@gpc_polygo

; 1227 :       {
; 1228 :         /* Add edges starting at this local minimum to the AET */
; 1229 :         for (edge= local_min->first_bound; edge; edge= edge->next_bound)

  002c9	49 8b 52 08	 mov	 rdx, QWORD PTR [r10+8]
  002cd	eb 38		 jmp	 SHORT $LN360@gpc_polygo
$LL138@gpc_polygo:

; 1230 :           add_edge_to_aet(&aet, edge, NULL);

  002cf	4d 85 ff	 test	 r15, r15
  002d2	75 1a		 jne	 SHORT $LN242@gpc_polygo
  002d4	48 83 a2 80 00
	00 00 00	 and	 QWORD PTR [rdx+128], 0
  002dc	48 83 a2 88 00
	00 00 00	 and	 QWORD PTR [rdx+136], 0
  002e4	4c 8b fa	 mov	 r15, rdx
  002e7	48 89 54 24 70	 mov	 QWORD PTR aet$[rsp], rdx
  002ec	eb 12		 jmp	 SHORT $LN137@gpc_polygo
$LN242@gpc_polygo:
  002ee	48 8d 4c 24 70	 lea	 rcx, QWORD PTR aet$[rsp]
  002f3	45 33 c0	 xor	 r8d, r8d
  002f6	e8 00 00 00 00	 call	 add_edge_to_aet
  002fb	4c 8b 7c 24 70	 mov	 r15, QWORD PTR aet$[rsp]
$LN137@gpc_polygo:

; 1227 :       {
; 1228 :         /* Add edges starting at this local minimum to the AET */
; 1229 :         for (edge= local_min->first_bound; edge; edge= edge->next_bound)

  00300	48 8b 92 a0 00
	00 00		 mov	 rdx, QWORD PTR [rdx+160]
$LN360@gpc_polygo:
  00307	48 85 d2	 test	 rdx, rdx
  0030a	75 c3		 jne	 SHORT $LL138@gpc_polygo

; 1231 : 
; 1232 :         local_min= local_min->next;

  0030c	4d 8b 52 10	 mov	 r10, QWORD PTR [r10+16]
  00310	4c 89 94 24 98
	00 00 00	 mov	 QWORD PTR local_min$1$[rsp], r10
$LN139@gpc_polygo:

; 1233 :       }
; 1234 :     }
; 1235 : 
; 1236 :     /* Set dummy previous x value */
; 1237 :     px= -DBL_MAX;
; 1238 : 
; 1239 :     /* Create bundles within AET */
; 1240 :     e0= aet;
; 1241 :     e1= aet;
; 1242 : 
; 1243 :     /* Set up bundle fields of first edge */
; 1244 :     aet->bundle[ABOVE][ aet->type]= (aet->top.y != yb);

  00318	f2 41 0f 10 47
	28		 movsdx	 xmm0, QWORD PTR [r15+40]
  0031e	f2 0f 10 3d 00
	00 00 00	 movsdx	 xmm7, QWORD PTR __real@ffefffffffffffff
  00326	4d 8b c7	 mov	 r8, r15
  00329	66 41 0f 2e c0	 ucomisd xmm0, xmm8
  0032e	7a 06		 jp	 SHORT $LN334@gpc_polygo
  00330	75 04		 jne	 SHORT $LN334@gpc_polygo
  00332	33 c9		 xor	 ecx, ecx
  00334	eb 03		 jmp	 SHORT $LN164@gpc_polygo
$LN334@gpc_polygo:
  00336	41 8b cb	 mov	 ecx, r11d
$LN164@gpc_polygo:
  00339	49 63 47 48	 movsxd	 rax, DWORD PTR [r15+72]
  0033d	41 89 4c 87 4c	 mov	 DWORD PTR [r15+rax*4+76], ecx

; 1245 :     aet->bundle[ABOVE][!aet->type]= FALSE;

  00342	33 c0		 xor	 eax, eax
  00344	41 39 47 48	 cmp	 DWORD PTR [r15+72], eax
  00348	0f 94 c0	 sete	 al
  0034b	41 83 64 87 4c
	00		 and	 DWORD PTR [r15+rax*4+76], 0

; 1246 :     aet->bstate[ABOVE]= UNBUNDLED;

  00351	41 83 67 64 00	 and	 DWORD PTR [r15+100], 0

; 1247 : 
; 1248 :     for (next_edge= aet->next; next_edge; next_edge= next_edge->next)

  00356	49 8b 97 88 00
	00 00		 mov	 rdx, QWORD PTR [r15+136]
  0035d	e9 b0 00 00 00	 jmp	 $LN361@gpc_polygo
$LL135@gpc_polygo:

; 1249 :     {
; 1250 :       /* Set up bundle fields of next edge */
; 1251 :       next_edge->bundle[ABOVE][ next_edge->type]= (next_edge->top.y != yb);

  00362	f2 0f 10 42 28	 movsdx	 xmm0, QWORD PTR [rdx+40]
  00367	66 41 0f 2e c0	 ucomisd xmm0, xmm8
  0036c	7a 06		 jp	 SHORT $LN333@gpc_polygo
  0036e	75 04		 jne	 SHORT $LN333@gpc_polygo
  00370	33 c9		 xor	 ecx, ecx
  00372	eb 03		 jmp	 SHORT $LN166@gpc_polygo
$LN333@gpc_polygo:
  00374	41 8b cb	 mov	 ecx, r11d
$LN166@gpc_polygo:
  00377	48 63 42 48	 movsxd	 rax, DWORD PTR [rdx+72]
  0037b	89 4c 82 4c	 mov	 DWORD PTR [rdx+rax*4+76], ecx

; 1252 :       next_edge->bundle[ABOVE][!next_edge->type]= FALSE;

  0037f	33 c0		 xor	 eax, eax
  00381	39 42 48	 cmp	 DWORD PTR [rdx+72], eax
  00384	0f 94 c0	 sete	 al
  00387	83 64 82 4c 00	 and	 DWORD PTR [rdx+rax*4+76], 0

; 1253 :       next_edge->bstate[ABOVE]= UNBUNDLED;
; 1254 : 
; 1255 :       /* Bundle edges above the scanbeam boundary if they coincide */
; 1256 :       if (next_edge->bundle[ABOVE][next_edge->type])

  0038c	48 63 4a 48	 movsxd	 rcx, DWORD PTR [rdx+72]
  00390	83 62 64 00	 and	 DWORD PTR [rdx+100], 0
  00394	83 7c 8a 4c 00	 cmp	 DWORD PTR [rdx+rcx*4+76], 0
  00399	74 70		 je	 SHORT $LN134@gpc_polygo

; 1257 :       {
; 1258 :         if (EQ(e0->xb, next_edge->xb) && EQ(e0->dx, next_edge->dx)
; 1259 : 	 && (e0->top.y != yb))

  0039b	f2 41 0f 10 40
	30		 movsdx	 xmm0, QWORD PTR [r8+48]
  003a1	f2 0f 5c 42 30	 subsd	 xmm0, QWORD PTR [rdx+48]
  003a6	66 41 0f 54 c3	 andpd	 xmm0, xmm11
  003ab	66 44 0f 2f e0	 comisd	 xmm12, xmm0
  003b0	72 56		 jb	 SHORT $LN131@gpc_polygo
  003b2	f2 41 0f 10 40
	40		 movsdx	 xmm0, QWORD PTR [r8+64]
  003b8	f2 0f 5c 42 40	 subsd	 xmm0, QWORD PTR [rdx+64]
  003bd	66 41 0f 54 c3	 andpd	 xmm0, xmm11
  003c2	66 44 0f 2f e0	 comisd	 xmm12, xmm0
  003c7	72 3f		 jb	 SHORT $LN131@gpc_polygo
  003c9	f2 41 0f 10 40
	28		 movsdx	 xmm0, QWORD PTR [r8+40]
  003cf	66 41 0f 2e c0	 ucomisd xmm0, xmm8
  003d4	7a 02		 jp	 SHORT $LN332@gpc_polygo
  003d6	74 30		 je	 SHORT $LN131@gpc_polygo
$LN332@gpc_polygo:

; 1260 :         {
; 1261 :           next_edge->bundle[ABOVE][ next_edge->type]^= 
; 1262 :             e0->bundle[ABOVE][ next_edge->type];

  003d8	41 8b 44 88 4c	 mov	 eax, DWORD PTR [r8+rcx*4+76]
  003dd	31 44 8a 4c	 xor	 DWORD PTR [rdx+rcx*4+76], eax

; 1263 :           next_edge->bundle[ABOVE][!next_edge->type]= 
; 1264 :             e0->bundle[ABOVE][!next_edge->type];

  003e1	33 c9		 xor	 ecx, ecx
  003e3	39 4a 48	 cmp	 DWORD PTR [rdx+72], ecx
  003e6	0f 94 c1	 sete	 cl
  003e9	41 8b 44 88 4c	 mov	 eax, DWORD PTR [r8+rcx*4+76]
  003ee	89 44 8a 4c	 mov	 DWORD PTR [rdx+rcx*4+76], eax

; 1265 :           next_edge->bstate[ABOVE]= BUNDLE_HEAD;

  003f2	44 89 5a 64	 mov	 DWORD PTR [rdx+100], r11d

; 1266 :           e0->bundle[ABOVE][CLIP]= FALSE;

  003f6	41 83 60 4c 00	 and	 DWORD PTR [r8+76], 0

; 1267 :           e0->bundle[ABOVE][SUBJ]= FALSE;

  003fb	41 83 60 50 00	 and	 DWORD PTR [r8+80], 0

; 1268 :           e0->bstate[ABOVE]= BUNDLE_TAIL;

  00400	41 c7 40 64 02
	00 00 00	 mov	 DWORD PTR [r8+100], 2
$LN131@gpc_polygo:

; 1269 :         }
; 1270 :         e0= next_edge;

  00408	4c 8b c2	 mov	 r8, rdx
$LN134@gpc_polygo:

; 1247 : 
; 1248 :     for (next_edge= aet->next; next_edge; next_edge= next_edge->next)

  0040b	48 8b 92 88 00
	00 00		 mov	 rdx, QWORD PTR [rdx+136]
$LN361@gpc_polygo:
  00412	48 85 d2	 test	 rdx, rdx
  00415	0f 85 47 ff ff
	ff		 jne	 $LL135@gpc_polygo
  0041b	44 8b 6c 24 3c	 mov	 r13d, DWORD PTR bl$[rsp]

; 1271 :       }
; 1272 :     }
; 1273 :     
; 1274 :     horiz[CLIP]= NH;

  00420	33 ed		 xor	 ebp, ebp

; 1275 :     horiz[SUBJ]= NH;
; 1276 : 
; 1277 :     /* Process each edge at this scanbeam boundary */
; 1278 :     for (edge= aet; edge; edge= edge->next)

  00422	49 8b df	 mov	 rbx, r15
  00425	44 8b 7c 24 34	 mov	 r15d, DWORD PTR tl$[rsp]
  0042a	33 f6		 xor	 esi, esi
$LL130@gpc_polygo:

; 1279 :     {
; 1280 :       exists[CLIP]= edge->bundle[ABOVE][CLIP] + 
; 1281 :                    (edge->bundle[BELOW][CLIP] << 1);

  0042c	44 8b 4b 54	 mov	 r9d, DWORD PTR [rbx+84]
  00430	44 8b 53 4c	 mov	 r10d, DWORD PTR [rbx+76]

; 1282 :       exists[SUBJ]= edge->bundle[ABOVE][SUBJ] + 
; 1283 :                    (edge->bundle[BELOW][SUBJ] << 1);

  00434	8b 7b 58	 mov	 edi, DWORD PTR [rbx+88]
  00437	44 8b 5b 50	 mov	 r11d, DWORD PTR [rbx+80]
  0043b	43 8d 14 4a	 lea	 edx, DWORD PTR [r10+r9*2]
  0043f	45 8d 04 7b	 lea	 r8d, DWORD PTR [r11+rdi*2]

; 1284 : 
; 1285 :       if (exists[CLIP] || exists[SUBJ])

  00443	85 d2		 test	 edx, edx
  00445	75 09		 jne	 SHORT $LN126@gpc_polygo
  00447	45 85 c0	 test	 r8d, r8d
  0044a	0f 84 59 05 00
	00		 je	 $LN129@gpc_polygo
$LN126@gpc_polygo:

; 1286 :       {
; 1287 :         /* Set bundle side */
; 1288 :         edge->bside[CLIP]= parity[CLIP];

  00450	8b 4c 24 50	 mov	 ecx, DWORD PTR parity$2$[rsp]

; 1289 :         edge->bside[SUBJ]= parity[SUBJ];

  00454	8b 84 24 68 01
	00 00		 mov	 eax, DWORD PTR parity$3$[rsp]
  0045b	89 4b 5c	 mov	 DWORD PTR [rbx+92], ecx
  0045e	89 43 60	 mov	 DWORD PTR [rbx+96], eax

; 1290 : 
; 1291 :         /* Determine contributing status and quadrant occupancies */
; 1292 :         switch (op)

  00461	45 85 e4	 test	 r12d, r12d
  00464	0f 88 e6 00 00
	00		 js	 $LN351@gpc_polygo
  0046a	41 83 fc 01	 cmp	 r12d, 1
  0046e	0f 8e 8b 01 00
	00		 jle	 $LN123@gpc_polygo
  00474	41 83 fc 02	 cmp	 r12d, 2
  00478	0f 84 17 01 00
	00		 je	 $LN122@gpc_polygo
  0047e	41 83 fc 03	 cmp	 r12d, 3
  00482	0f 85 c8 00 00
	00		 jne	 $LN351@gpc_polygo

; 1320 :         case GPC_UNION:
; 1321 :           contributing= (exists[CLIP] && (!parity[SUBJ] || horiz[SUBJ]))
; 1322 :                      || (exists[SUBJ] && (!parity[CLIP] || horiz[CLIP]))
; 1323 :                      || (exists[CLIP] && exists[SUBJ]
; 1324 :                      && (parity[CLIP] == parity[SUBJ]));

  00488	85 d2		 test	 edx, edx
  0048a	74 08		 je	 SHORT $LN184@gpc_polygo
  0048c	85 c0		 test	 eax, eax
  0048e	74 1e		 je	 SHORT $LN183@gpc_polygo
  00490	85 f6		 test	 esi, esi
  00492	75 1a		 jne	 SHORT $LN183@gpc_polygo
$LN184@gpc_polygo:
  00494	45 85 c0	 test	 r8d, r8d
  00497	74 08		 je	 SHORT $LN186@gpc_polygo
  00499	85 c9		 test	 ecx, ecx
  0049b	74 11		 je	 SHORT $LN183@gpc_polygo
  0049d	85 ed		 test	 ebp, ebp
  0049f	75 0d		 jne	 SHORT $LN183@gpc_polygo
$LN186@gpc_polygo:
  004a1	85 d2		 test	 edx, edx
  004a3	74 13		 je	 SHORT $LN187@gpc_polygo
  004a5	45 85 c0	 test	 r8d, r8d
  004a8	74 0e		 je	 SHORT $LN187@gpc_polygo
  004aa	3b c8		 cmp	 ecx, eax
  004ac	75 0a		 jne	 SHORT $LN187@gpc_polygo
$LN183@gpc_polygo:
  004ae	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR contributing$[rsp], 1
  004b6	eb 05		 jmp	 SHORT $LN188@gpc_polygo
$LN187@gpc_polygo:
  004b8	83 64 24 60 00	 and	 DWORD PTR contributing$[rsp], 0
$LN188@gpc_polygo:

; 1325 :           br= (parity[CLIP])
; 1326 :            || (parity[SUBJ]);

  004bd	85 c9		 test	 ecx, ecx
  004bf	75 0a		 jne	 SHORT $LN189@gpc_polygo
  004c1	85 c0		 test	 eax, eax
  004c3	75 06		 jne	 SHORT $LN189@gpc_polygo
  004c5	21 44 24 30	 and	 DWORD PTR br$[rsp], eax
  004c9	eb 08		 jmp	 SHORT $LN190@gpc_polygo
$LN189@gpc_polygo:
  004cb	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR br$[rsp], 1
$LN190@gpc_polygo:

; 1327 :           bl= (parity[CLIP] ^ edge->bundle[ABOVE][CLIP])
; 1328 :            || (parity[SUBJ] ^ edge->bundle[ABOVE][SUBJ]);

  004d3	41 8b c2	 mov	 eax, r10d
  004d6	33 c1		 xor	 eax, ecx
  004d8	75 11		 jne	 SHORT $LN191@gpc_polygo
  004da	41 8b c3	 mov	 eax, r11d
  004dd	33 84 24 68 01
	00 00		 xor	 eax, DWORD PTR parity$3$[rsp]
  004e4	75 05		 jne	 SHORT $LN191@gpc_polygo
  004e6	45 33 ed	 xor	 r13d, r13d
  004e9	eb 06		 jmp	 SHORT $LN192@gpc_polygo
$LN191@gpc_polygo:
  004eb	41 bd 01 00 00
	00		 mov	 r13d, 1
$LN192@gpc_polygo:

; 1329 :           tr= (parity[CLIP] ^ (horiz[CLIP]!=NH))
; 1330 :            || (parity[SUBJ] ^ (horiz[SUBJ]!=NH));

  004f1	44 8b 7c 24 50	 mov	 r15d, DWORD PTR parity$2$[rsp]
  004f6	33 c9		 xor	 ecx, ecx
  004f8	85 ed		 test	 ebp, ebp
  004fa	0f 95 c1	 setne	 cl
  004fd	8b c1		 mov	 eax, ecx
  004ff	41 33 c7	 xor	 eax, r15d
  00502	75 14		 jne	 SHORT $LN193@gpc_polygo
  00504	85 f6		 test	 esi, esi
  00506	0f 95 c0	 setne	 al
  00509	33 84 24 68 01
	00 00		 xor	 eax, DWORD PTR parity$3$[rsp]
  00510	75 06		 jne	 SHORT $LN193@gpc_polygo
  00512	21 44 24 38	 and	 DWORD PTR tr$[rsp], eax
  00516	eb 08		 jmp	 SHORT $LN194@gpc_polygo
$LN193@gpc_polygo:
  00518	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tr$[rsp], 1
$LN194@gpc_polygo:

; 1331 :           tl= (parity[CLIP] ^ (horiz[CLIP]!=NH) ^ edge->bundle[BELOW][CLIP]) 
; 1332 :            || (parity[SUBJ] ^ (horiz[SUBJ]!=NH) ^ edge->bundle[BELOW][SUBJ]);

  00520	41 33 c9	 xor	 ecx, r9d
  00523	41 33 cf	 xor	 ecx, r15d
  00526	0f 85 80 01 00
	00		 jne	 $LN195@gpc_polygo
$LN374@gpc_polygo:
  0052c	33 c0		 xor	 eax, eax
  0052e	85 f6		 test	 esi, esi
  00530	0f 95 c0	 setne	 al
  00533	33 c7		 xor	 eax, edi
  00535	33 84 24 68 01
	00 00		 xor	 eax, DWORD PTR parity$3$[rsp]
  0053c	0f 85 6a 01 00
	00		 jne	 $LN195@gpc_polygo
$LN179@gpc_polygo:
  00542	8b 84 24 68 01
	00 00		 mov	 eax, DWORD PTR parity$3$[rsp]
  00549	8b 4c 24 50	 mov	 ecx, DWORD PTR parity$2$[rsp]

; 1306 :           tl= (parity[CLIP] ^ (horiz[CLIP]!=NH) ^ edge->bundle[BELOW][CLIP]) 
; 1307 :            && (parity[SUBJ] ^ (horiz[SUBJ]!=NH) ^ edge->bundle[BELOW][SUBJ]);

  0054d	45 33 ff	 xor	 r15d, r15d
$LN351@gpc_polygo:

; 1176 :     s_heap= build_lmt(&lmt, &sbtree, &sbt_entries, subj, SUBJ, op);

  00550	41 b9 01 00 00
	00		 mov	 r9d, 1
$LN180@gpc_polygo:

; 1333 :           break;
; 1334 :         }
; 1335 : 
; 1336 :         /* Update parity */
; 1337 :         parity[CLIP]^= edge->bundle[ABOVE][CLIP];

  00556	41 33 ca	 xor	 ecx, r10d

; 1338 :         parity[SUBJ]^= edge->bundle[ABOVE][SUBJ];

  00559	41 33 c3	 xor	 eax, r11d
  0055c	89 4c 24 50	 mov	 DWORD PTR parity$2$[rsp], ecx
  00560	89 84 24 68 01
	00 00		 mov	 DWORD PTR parity$3$[rsp], eax

; 1339 : 
; 1340 :         /* Update horizontal state */
; 1341 :         if (exists[CLIP])         

  00567	85 d2		 test	 edx, edx
  00569	0f 84 56 01 00
	00		 je	 $LN357@gpc_polygo

; 1342 :           horiz[CLIP]=
; 1343 :             next_h_state[horiz[CLIP]]
; 1344 :                         [((exists[CLIP] - 1) << 1) + parity[CLIP]];

  0056f	48 63 c5	 movsxd	 rax, ebp
  00572	48 8d 0c 40	 lea	 rcx, QWORD PTR [rax+rax*2]
  00576	48 63 c2	 movsxd	 rax, edx
  00579	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:next_h_state
  00580	48 03 c8	 add	 rcx, rax
  00583	48 63 44 24 50	 movsxd	 rax, DWORD PTR parity$2$[rsp]
  00588	48 8d 0c 48	 lea	 rcx, QWORD PTR [rax+rcx*2]
  0058c	8b 6c 8a f8	 mov	 ebp, DWORD PTR [rdx+rcx*4-8]
  00590	e9 37 01 00 00	 jmp	 $LN120@gpc_polygo
$LN122@gpc_polygo:

; 1308 :           break;
; 1309 :         case GPC_XOR:
; 1310 :           contributing= exists[CLIP] || exists[SUBJ];

  00595	85 d2		 test	 edx, edx
  00597	75 0c		 jne	 SHORT $LN181@gpc_polygo
  00599	45 85 c0	 test	 r8d, r8d
  0059c	75 07		 jne	 SHORT $LN181@gpc_polygo
  0059e	44 21 44 24 60	 and	 DWORD PTR contributing$[rsp], r8d
  005a3	eb 08		 jmp	 SHORT $LN182@gpc_polygo
$LN181@gpc_polygo:
  005a5	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR contributing$[rsp], 1
$LN182@gpc_polygo:

; 1311 :           br= (parity[CLIP])
; 1312 :             ^ (parity[SUBJ]);

  005ad	33 c1		 xor	 eax, ecx

; 1313 :           bl= (parity[CLIP] ^ edge->bundle[ABOVE][CLIP])
; 1314 :             ^ (parity[SUBJ] ^ edge->bundle[ABOVE][SUBJ]);
; 1315 :           tr= (parity[CLIP] ^ (horiz[CLIP]!=NH))
; 1316 :             ^ (parity[SUBJ] ^ (horiz[SUBJ]!=NH));

  005af	45 33 ff	 xor	 r15d, r15d
  005b2	45 8b eb	 mov	 r13d, r11d
  005b5	89 44 24 30	 mov	 DWORD PTR br$[rsp], eax
  005b9	45 33 ea	 xor	 r13d, r10d
  005bc	44 33 ac 24 68
	01 00 00	 xor	 r13d, DWORD PTR parity$3$[rsp]
  005c4	44 33 e9	 xor	 r13d, ecx
  005c7	85 f6		 test	 esi, esi
  005c9	41 0f 95 c7	 setne	 r15b
  005cd	33 c0		 xor	 eax, eax
  005cf	85 ed		 test	 ebp, ebp
  005d1	0f 95 c0	 setne	 al
  005d4	44 33 f8	 xor	 r15d, eax
  005d7	41 8b c7	 mov	 eax, r15d

; 1317 :           tl= (parity[CLIP] ^ (horiz[CLIP]!=NH) ^ edge->bundle[BELOW][CLIP]) 
; 1318 :             ^ (parity[SUBJ] ^ (horiz[SUBJ]!=NH) ^ edge->bundle[BELOW][SUBJ]);

  005da	44 33 ff	 xor	 r15d, edi
  005dd	33 84 24 68 01
	00 00		 xor	 eax, DWORD PTR parity$3$[rsp]
  005e4	45 33 f9	 xor	 r15d, r9d
  005e7	33 c1		 xor	 eax, ecx
  005e9	89 44 24 38	 mov	 DWORD PTR tr$[rsp], eax
  005ed	8b 84 24 68 01
	00 00		 mov	 eax, DWORD PTR parity$3$[rsp]
  005f4	44 33 f8	 xor	 r15d, eax
  005f7	44 33 f9	 xor	 r15d, ecx

; 1319 :           break;

  005fa	e9 51 ff ff ff	 jmp	 $LN351@gpc_polygo
$LN123@gpc_polygo:

; 1293 :         {
; 1294 :         case GPC_DIFF:
; 1295 :         case GPC_INT:
; 1296 :           contributing= (exists[CLIP] && (parity[SUBJ] || horiz[SUBJ]))
; 1297 :                      || (exists[SUBJ] && (parity[CLIP] || horiz[CLIP]))
; 1298 :                      || (exists[CLIP] && exists[SUBJ]
; 1299 :                      && (parity[CLIP] == parity[SUBJ]));

  005ff	85 d2		 test	 edx, edx
  00601	74 08		 je	 SHORT $LN168@gpc_polygo
  00603	85 c0		 test	 eax, eax
  00605	75 1e		 jne	 SHORT $LN167@gpc_polygo
  00607	85 f6		 test	 esi, esi
  00609	75 1a		 jne	 SHORT $LN167@gpc_polygo
$LN168@gpc_polygo:
  0060b	45 85 c0	 test	 r8d, r8d
  0060e	74 08		 je	 SHORT $LN170@gpc_polygo
  00610	85 c9		 test	 ecx, ecx
  00612	75 11		 jne	 SHORT $LN167@gpc_polygo
  00614	85 ed		 test	 ebp, ebp
  00616	75 0d		 jne	 SHORT $LN167@gpc_polygo
$LN170@gpc_polygo:
  00618	85 d2		 test	 edx, edx
  0061a	74 13		 je	 SHORT $LN171@gpc_polygo
  0061c	45 85 c0	 test	 r8d, r8d
  0061f	74 0e		 je	 SHORT $LN171@gpc_polygo
  00621	3b c8		 cmp	 ecx, eax
  00623	75 0a		 jne	 SHORT $LN171@gpc_polygo
$LN167@gpc_polygo:
  00625	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR contributing$[rsp], 1
  0062d	eb 05		 jmp	 SHORT $LN172@gpc_polygo
$LN171@gpc_polygo:
  0062f	83 64 24 60 00	 and	 DWORD PTR contributing$[rsp], 0
$LN172@gpc_polygo:

; 1300 :           br= (parity[CLIP])
; 1301 :            && (parity[SUBJ]);

  00634	85 c9		 test	 ecx, ecx
  00636	74 0e		 je	 SHORT $LN173@gpc_polygo
  00638	85 c0		 test	 eax, eax
  0063a	74 0a		 je	 SHORT $LN173@gpc_polygo
  0063c	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR br$[rsp], 1
  00644	eb 05		 jmp	 SHORT $LN174@gpc_polygo
$LN173@gpc_polygo:
  00646	83 64 24 30 00	 and	 DWORD PTR br$[rsp], 0
$LN174@gpc_polygo:

; 1302 :           bl= (parity[CLIP] ^ edge->bundle[ABOVE][CLIP])
; 1303 :            && (parity[SUBJ] ^ edge->bundle[ABOVE][SUBJ]);

  0064b	41 8b c2	 mov	 eax, r10d
  0064e	33 c1		 xor	 eax, ecx
  00650	74 14		 je	 SHORT $LN175@gpc_polygo
  00652	41 8b c3	 mov	 eax, r11d
  00655	33 84 24 68 01
	00 00		 xor	 eax, DWORD PTR parity$3$[rsp]
  0065c	74 08		 je	 SHORT $LN175@gpc_polygo
  0065e	41 bd 01 00 00
	00		 mov	 r13d, 1
  00664	eb 03		 jmp	 SHORT $LN176@gpc_polygo
$LN175@gpc_polygo:
  00666	45 33 ed	 xor	 r13d, r13d
$LN176@gpc_polygo:

; 1304 :           tr= (parity[CLIP] ^ (horiz[CLIP]!=NH))
; 1305 :            && (parity[SUBJ] ^ (horiz[SUBJ]!=NH));

  00669	44 8b 7c 24 50	 mov	 r15d, DWORD PTR parity$2$[rsp]
  0066e	33 c9		 xor	 ecx, ecx
  00670	85 ed		 test	 ebp, ebp
  00672	0f 95 c1	 setne	 cl
  00675	8b c1		 mov	 eax, ecx
  00677	41 33 c7	 xor	 eax, r15d
  0067a	74 1a		 je	 SHORT $LN177@gpc_polygo
  0067c	33 c0		 xor	 eax, eax
  0067e	85 f6		 test	 esi, esi
  00680	0f 95 c0	 setne	 al
  00683	33 84 24 68 01
	00 00		 xor	 eax, DWORD PTR parity$3$[rsp]
  0068a	74 0a		 je	 SHORT $LN177@gpc_polygo
  0068c	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tr$[rsp], 1
  00694	eb 05		 jmp	 SHORT $LN178@gpc_polygo
$LN177@gpc_polygo:
  00696	83 64 24 38 00	 and	 DWORD PTR tr$[rsp], 0
$LN178@gpc_polygo:

; 1306 :           tl= (parity[CLIP] ^ (horiz[CLIP]!=NH) ^ edge->bundle[BELOW][CLIP]) 
; 1307 :            && (parity[SUBJ] ^ (horiz[SUBJ]!=NH) ^ edge->bundle[BELOW][SUBJ]);

  0069b	41 33 c9	 xor	 ecx, r9d
  0069e	41 33 cf	 xor	 ecx, r15d
  006a1	0f 84 9b fe ff
	ff		 je	 $LN179@gpc_polygo
  006a7	e9 80 fe ff ff	 jmp	 $LN374@gpc_polygo
$LN195@gpc_polygo:
  006ac	8b 4c 24 50	 mov	 ecx, DWORD PTR parity$2$[rsp]
  006b0	8b 84 24 68 01
	00 00		 mov	 eax, DWORD PTR parity$3$[rsp]
  006b7	41 b9 01 00 00
	00		 mov	 r9d, 1
  006bd	45 8b f9	 mov	 r15d, r9d
  006c0	e9 91 fe ff ff	 jmp	 $LN180@gpc_polygo
$LN357@gpc_polygo:

; 1176 :     s_heap= build_lmt(&lmt, &sbtree, &sbt_entries, subj, SUBJ, op);

  006c5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:next_h_state
$LN120@gpc_polygo:

; 1345 :         if (exists[SUBJ])         

  006cc	45 85 c0	 test	 r8d, r8d
  006cf	74 1d		 je	 SHORT $LN119@gpc_polygo

; 1346 :           horiz[SUBJ]=
; 1347 :             next_h_state[horiz[SUBJ]]
; 1348 :                         [((exists[SUBJ] - 1) << 1) + parity[SUBJ]];

  006d1	48 63 c6	 movsxd	 rax, esi
  006d4	48 8d 0c 40	 lea	 rcx, QWORD PTR [rax+rax*2]
  006d8	49 63 c0	 movsxd	 rax, r8d
  006db	48 03 c8	 add	 rcx, rax
  006de	48 63 84 24 68
	01 00 00	 movsxd	 rax, DWORD PTR parity$3$[rsp]
  006e6	48 8d 0c 48	 lea	 rcx, QWORD PTR [rax+rcx*2]
  006ea	8b 74 8a f8	 mov	 esi, DWORD PTR [rdx+rcx*4-8]
$LN119@gpc_polygo:

; 1349 : 
; 1350 :         vclass= tr + (tl << 1) + (br << 2) + (bl << 3);
; 1351 : 
; 1352 :         if (contributing)

  006ee	83 7c 24 60 00	 cmp	 DWORD PTR contributing$[rsp], 0
  006f3	0f 84 b0 02 00
	00		 je	 $LN129@gpc_polygo

; 1353 :         {
; 1354 :           xb= edge->xb;
; 1355 : 
; 1356 :           switch (vclass)

  006f9	8b 44 24 30	 mov	 eax, DWORD PTR br$[rsp]
  006fd	f2 0f 10 73 30	 movsdx	 xmm6, QWORD PTR [rbx+48]
  00702	42 8d 04 68	 lea	 eax, DWORD PTR [rax+r13*2]
  00706	41 8d 0c 47	 lea	 ecx, DWORD PTR [r15+rax*2]
  0070a	8b 44 24 38	 mov	 eax, DWORD PTR tr$[rsp]
  0070e	8d 14 48	 lea	 edx, DWORD PTR [rax+rcx*2]
  00711	83 fa 08	 cmp	 edx, 8
  00714	0f 8f 48 01 00
	00		 jg	 $LN197@gpc_polygo
  0071a	83 fa 07	 cmp	 edx, 7
  0071d	0f 8d 20 01 00
	00		 jge	 $LN115@gpc_polygo
  00723	41 2b d1	 sub	 edx, r9d
  00726	0f 84 dd 00 00
	00		 je	 $LN111@gpc_polygo
  0072c	41 2b d1	 sub	 edx, r9d
  0072f	0f 84 b5 00 00
	00		 je	 $LN112@gpc_polygo
  00735	83 ea 02	 sub	 edx, 2
  00738	74 78		 je	 SHORT $LN114@gpc_polygo
  0073a	41 2b d1	 sub	 edx, r9d
  0073d	74 46		 je	 SHORT $LN98@gpc_polygo
  0073f	41 3b d1	 cmp	 edx, r9d
  00742	0f 85 61 02 00
	00		 jne	 $LN129@gpc_polygo

; 1412 :           case IMM:
; 1413 :             if (xb != px)

  00748	66 0f 2e f7	 ucomisd xmm6, xmm7
  0074c	7a 02		 jp	 SHORT $LN331@gpc_polygo
  0074e	74 1c		 je	 SHORT $LN349@gpc_polygo
$LN331@gpc_polygo:

; 1414 : 	    {
; 1415 :               add_right(cf, xb, yb);

  00750	48 8b 7c 24 40	 mov	 rdi, QWORD PTR cf$1$[rsp]
  00755	66 41 0f 28 d0	 movapd	 xmm2, xmm8
  0075a	66 0f 28 ce	 movapd	 xmm1, xmm6
  0075e	48 8b cf	 mov	 rcx, rdi
  00761	e8 00 00 00 00	 call	 add_right

; 1416 :               px= xb;

  00766	66 0f 28 fe	 movapd	 xmm7, xmm6
  0076a	eb 05		 jmp	 SHORT $LN103@gpc_polygo
$LN349@gpc_polygo:

; 1366 :             {
; 1367 :               add_right(cf, xb, yb);

  0076c	48 8b 7c 24 40	 mov	 rdi, QWORD PTR cf$1$[rsp]
$LN103@gpc_polygo:

; 1417 : 	    }
; 1418 :             merge_left(cf, edge->outp[BELOW], out_poly);

  00771	48 8b 53 78	 mov	 rdx, QWORD PTR [rbx+120]
  00775	4d 8b c6	 mov	 r8, r14
  00778	48 8b cf	 mov	 rcx, rdi
  0077b	e8 00 00 00 00	 call	 merge_left

; 1419 :             edge->outp[BELOW]= NULL;
; 1420 :             add_local_min(&out_poly, edge, xb, yb);
; 1421 :             cf= edge->outp[ABOVE];
; 1422 :             break;

  00780	e9 fb 01 00 00	 jmp	 $LN362@gpc_polygo
$LN98@gpc_polygo:

; 1440 :           case RED:
; 1441 :             if (edge->bot.y == yb)

  00785	f2 0f 10 43 18	 movsdx	 xmm0, QWORD PTR [rbx+24]
  0078a	66 41 0f 2e c0	 ucomisd xmm0, xmm8
  0078f	0f 8a a5 01 00
	00		 jp	 $LN99@gpc_polygo
  00795	0f 85 9f 01 00
	00		 jne	 $LN99@gpc_polygo

; 1442 :               add_right(edge->outp[BELOW], xb, yb);

  0079b	48 8b 4b 78	 mov	 rcx, QWORD PTR [rbx+120]
  0079f	66 41 0f 28 d0	 movapd	 xmm2, xmm8
  007a4	66 0f 28 ce	 movapd	 xmm1, xmm6
  007a8	e8 00 00 00 00	 call	 add_right

; 1443 :             edge->outp[ABOVE]= edge->outp[BELOW];
; 1444 :             px= xb;
; 1445 :             break;

  007ad	e9 88 01 00 00	 jmp	 $LN99@gpc_polygo
$LN114@gpc_polygo:

; 1364 :           case ERI:
; 1365 :             if (xb != px)

  007b2	66 0f 2e f7	 ucomisd xmm6, xmm7
  007b6	7a 02		 jp	 SHORT $LN330@gpc_polygo
  007b8	74 1c		 je	 SHORT $LN348@gpc_polygo
$LN330@gpc_polygo:

; 1366 :             {
; 1367 :               add_right(cf, xb, yb);

  007ba	48 8b 7c 24 40	 mov	 rdi, QWORD PTR cf$1$[rsp]
  007bf	66 41 0f 28 d0	 movapd	 xmm2, xmm8
  007c4	66 0f 28 ce	 movapd	 xmm1, xmm6
  007c8	48 8b cf	 mov	 rcx, rdi
  007cb	e8 00 00 00 00	 call	 add_right
$LN375@gpc_polygo:

; 1368 :               px= xb;

  007d0	66 0f 28 fe	 movapd	 xmm7, xmm6
  007d4	eb 05		 jmp	 SHORT $LN113@gpc_polygo
$LN348@gpc_polygo:

; 1380 :             {
; 1381 :               add_left(cf, xb, yb);

  007d6	48 8b 7c 24 40	 mov	 rdi, QWORD PTR cf$1$[rsp]
$LN113@gpc_polygo:

; 1369 :             }
; 1370 :             edge->outp[ABOVE]= cf;

  007db	48 89 7b 70	 mov	 QWORD PTR [rbx+112], rdi
$LN365@gpc_polygo:

; 1371 :             cf= NULL;

  007df	48 83 64 24 40
	00		 and	 QWORD PTR cf$1$[rsp], 0

; 1372 :             break;

  007e5	e9 bf 01 00 00	 jmp	 $LN129@gpc_polygo
$LN112@gpc_polygo:

; 1373 :           case ELI:
; 1374 :             add_left(edge->outp[BELOW], xb, yb);

  007ea	48 8b 4b 78	 mov	 rcx, QWORD PTR [rbx+120]
  007ee	66 41 0f 28 d0	 movapd	 xmm2, xmm8
  007f3	66 0f 28 ce	 movapd	 xmm1, xmm6
  007f7	e8 00 00 00 00	 call	 add_left

; 1375 :             px= xb;
; 1376 :             cf= edge->outp[BELOW];

  007fc	48 8b 43 78	 mov	 rax, QWORD PTR [rbx+120]
  00800	66 0f 28 fe	 movapd	 xmm7, xmm6

; 1377 :             break;

  00804	e9 9b 01 00 00	 jmp	 $LN363@gpc_polygo
$LN111@gpc_polygo:

; 1378 :           case EMX:
; 1379 :             if (xb != px)

  00809	66 0f 2e f7	 ucomisd xmm6, xmm7
  0080d	7a 02		 jp	 SHORT $LN329@gpc_polygo
  0080f	74 1c		 je	 SHORT $LN347@gpc_polygo
$LN329@gpc_polygo:

; 1380 :             {
; 1381 :               add_left(cf, xb, yb);

  00811	48 8b 7c 24 40	 mov	 rdi, QWORD PTR cf$1$[rsp]
  00816	66 41 0f 28 d0	 movapd	 xmm2, xmm8
  0081b	66 0f 28 ce	 movapd	 xmm1, xmm6
  0081f	48 8b cf	 mov	 rcx, rdi
  00822	e8 00 00 00 00	 call	 add_left

; 1382 :               px= xb;

  00827	66 0f 28 fe	 movapd	 xmm7, xmm6
  0082b	eb 05		 jmp	 SHORT $LN110@gpc_polygo
$LN347@gpc_polygo:

; 1404 :             {
; 1405 :               add_right(cf, xb, yb);

  0082d	48 8b 7c 24 40	 mov	 rdi, QWORD PTR cf$1$[rsp]
$LN110@gpc_polygo:

; 1383 :             }
; 1384 :             merge_right(cf, edge->outp[BELOW], out_poly);

  00832	48 8b 53 78	 mov	 rdx, QWORD PTR [rbx+120]
  00836	4d 8b c6	 mov	 r8, r14
  00839	48 8b cf	 mov	 rcx, rdi
  0083c	e8 00 00 00 00	 call	 merge_right

; 1385 :             cf= NULL;
; 1386 :             break;

  00841	eb 9c		 jmp	 SHORT $LN365@gpc_polygo
$LN115@gpc_polygo:

; 1357 :           {
; 1358 :           case EMN:
; 1359 :           case IMN:
; 1360 :             add_local_min(&out_poly, edge, xb, yb);

  00843	48 8d 4c 24 58	 lea	 rcx, QWORD PTR out_poly$[rsp]
  00848	66 41 0f 28 d8	 movapd	 xmm3, xmm8
  0084d	66 0f 28 d6	 movapd	 xmm2, xmm6
  00851	48 8b d3	 mov	 rdx, rbx
  00854	e8 00 00 00 00	 call	 add_local_min

; 1361 :             px= xb;

  00859	66 0f 28 fe	 movapd	 xmm7, xmm6

; 1362 :             cf= edge->outp[ABOVE];
; 1363 :             break;

  0085d	e9 39 01 00 00	 jmp	 $LN364@gpc_polygo
$LN197@gpc_polygo:

; 1353 :         {
; 1354 :           xb= edge->xb;
; 1355 : 
; 1356 :           switch (vclass)

  00862	83 ea 09	 sub	 edx, 9
  00865	0f 84 dd 00 00
	00		 je	 $LN102@gpc_polygo
  0086b	41 2b d1	 sub	 edx, r9d
  0086e	0f 84 a6 00 00
	00		 je	 $LN100@gpc_polygo
  00874	41 2b d1	 sub	 edx, r9d
  00877	74 7a		 je	 SHORT $LN109@gpc_polygo
  00879	83 ea 02	 sub	 edx, 2
  0087c	74 51		 je	 SHORT $LN107@gpc_polygo
  0087e	41 3b d1	 cmp	 edx, r9d
  00881	0f 85 22 01 00
	00		 jne	 $LN129@gpc_polygo

; 1402 :           case IMX:
; 1403 :             if (xb != px)

  00887	66 0f 2e f7	 ucomisd xmm6, xmm7
  0088b	7a 02		 jp	 SHORT $LN328@gpc_polygo
  0088d	74 1c		 je	 SHORT $LN346@gpc_polygo
$LN328@gpc_polygo:

; 1404 :             {
; 1405 :               add_right(cf, xb, yb);

  0088f	48 8b 7c 24 40	 mov	 rdi, QWORD PTR cf$1$[rsp]
  00894	66 41 0f 28 d0	 movapd	 xmm2, xmm8
  00899	66 0f 28 ce	 movapd	 xmm1, xmm6
  0089d	48 8b cf	 mov	 rcx, rdi
  008a0	e8 00 00 00 00	 call	 add_right

; 1406 :               px= xb;

  008a5	66 0f 28 fe	 movapd	 xmm7, xmm6
  008a9	eb 05		 jmp	 SHORT $LN105@gpc_polygo
$LN346@gpc_polygo:

; 1389 :             {
; 1390 :               add_left(cf, xb, yb);

  008ab	48 8b 7c 24 40	 mov	 rdi, QWORD PTR cf$1$[rsp]
$LN105@gpc_polygo:

; 1407 :             }
; 1408 :             merge_left(cf, edge->outp[BELOW], out_poly);

  008b0	48 8b 53 78	 mov	 rdx, QWORD PTR [rbx+120]
  008b4	4d 8b c6	 mov	 r8, r14
  008b7	48 8b cf	 mov	 rcx, rdi
  008ba	e8 00 00 00 00	 call	 merge_left

; 1409 :             cf= NULL;

  008bf	48 83 64 24 40
	00		 and	 QWORD PTR cf$1$[rsp], 0

; 1410 :             edge->outp[BELOW]= NULL;

  008c5	48 83 63 78 00	 and	 QWORD PTR [rbx+120], 0

; 1411 :             break;

  008ca	e9 da 00 00 00	 jmp	 $LN129@gpc_polygo
$LN107@gpc_polygo:

; 1392 :             }
; 1393 :             edge->outp[ABOVE]= cf;
; 1394 :             cf= NULL;
; 1395 :             break;
; 1396 :           case IRI:
; 1397 :             add_right(edge->outp[BELOW], xb, yb);

  008cf	48 8b 4b 78	 mov	 rcx, QWORD PTR [rbx+120]
  008d3	66 41 0f 28 d0	 movapd	 xmm2, xmm8
  008d8	66 0f 28 ce	 movapd	 xmm1, xmm6
  008dc	e8 00 00 00 00	 call	 add_right

; 1398 :             px= xb;
; 1399 :             cf= edge->outp[BELOW];

  008e1	48 8b 43 78	 mov	 rax, QWORD PTR [rbx+120]

; 1400 :             edge->outp[BELOW]= NULL;

  008e5	48 83 63 78 00	 and	 QWORD PTR [rbx+120], 0
  008ea	66 0f 28 fe	 movapd	 xmm7, xmm6

; 1401 :             break;

  008ee	e9 b1 00 00 00	 jmp	 $LN363@gpc_polygo
$LN109@gpc_polygo:

; 1387 :           case ILI:
; 1388 :             if (xb != px)

  008f3	66 0f 2e f7	 ucomisd xmm6, xmm7
  008f7	7a 06		 jp	 SHORT $LN327@gpc_polygo
  008f9	0f 84 d7 fe ff
	ff		 je	 $LN348@gpc_polygo
$LN327@gpc_polygo:

; 1389 :             {
; 1390 :               add_left(cf, xb, yb);

  008ff	48 8b 7c 24 40	 mov	 rdi, QWORD PTR cf$1$[rsp]
  00904	66 41 0f 28 d0	 movapd	 xmm2, xmm8
  00909	66 0f 28 ce	 movapd	 xmm1, xmm6
  0090d	48 8b cf	 mov	 rcx, rdi
  00910	e8 00 00 00 00	 call	 add_left

; 1391 :               px= xb;

  00915	e9 b6 fe ff ff	 jmp	 $LN375@gpc_polygo
$LN100@gpc_polygo:

; 1433 :             break;
; 1434 :           case LED:
; 1435 :             if (edge->bot.y == yb)

  0091a	f2 0f 10 43 18	 movsdx	 xmm0, QWORD PTR [rbx+24]
  0091f	66 41 0f 2e c0	 ucomisd xmm0, xmm8
  00924	7a 14		 jp	 SHORT $LN99@gpc_polygo
  00926	75 12		 jne	 SHORT $LN99@gpc_polygo

; 1436 :               add_left(edge->outp[BELOW], xb, yb);

  00928	48 8b 4b 78	 mov	 rcx, QWORD PTR [rbx+120]
  0092c	66 41 0f 28 d0	 movapd	 xmm2, xmm8
  00931	66 0f 28 ce	 movapd	 xmm1, xmm6
  00935	e8 00 00 00 00	 call	 add_left
$LN99@gpc_polygo:

; 1437 :             edge->outp[ABOVE]= edge->outp[BELOW];

  0093a	48 8b 43 78	 mov	 rax, QWORD PTR [rbx+120]

; 1438 :             px= xb;

  0093e	66 0f 28 fe	 movapd	 xmm7, xmm6
  00942	48 89 43 70	 mov	 QWORD PTR [rbx+112], rax

; 1439 :             break;

  00946	eb 61		 jmp	 SHORT $LN129@gpc_polygo
$LN102@gpc_polygo:

; 1423 :           case EMM:
; 1424 :             if (xb != px)

  00948	66 0f 2e f7	 ucomisd xmm6, xmm7
  0094c	7a 02		 jp	 SHORT $LN326@gpc_polygo
  0094e	74 1c		 je	 SHORT $LN344@gpc_polygo
$LN326@gpc_polygo:

; 1425 : 	    {
; 1426 :               add_left(cf, xb, yb);

  00950	48 8b 7c 24 40	 mov	 rdi, QWORD PTR cf$1$[rsp]
  00955	66 41 0f 28 d0	 movapd	 xmm2, xmm8
  0095a	66 0f 28 ce	 movapd	 xmm1, xmm6
  0095e	48 8b cf	 mov	 rcx, rdi
  00961	e8 00 00 00 00	 call	 add_left

; 1427 :               px= xb;

  00966	66 0f 28 fe	 movapd	 xmm7, xmm6
  0096a	eb 05		 jmp	 SHORT $LN101@gpc_polygo
$LN344@gpc_polygo:

; 1313 :           bl= (parity[CLIP] ^ edge->bundle[ABOVE][CLIP])
; 1314 :             ^ (parity[SUBJ] ^ edge->bundle[ABOVE][SUBJ]);
; 1315 :           tr= (parity[CLIP] ^ (horiz[CLIP]!=NH))
; 1316 :             ^ (parity[SUBJ] ^ (horiz[SUBJ]!=NH));

  0096c	48 8b 7c 24 40	 mov	 rdi, QWORD PTR cf$1$[rsp]
$LN101@gpc_polygo:

; 1428 : 	    }
; 1429 :             merge_right(cf, edge->outp[BELOW], out_poly);

  00971	48 8b 53 78	 mov	 rdx, QWORD PTR [rbx+120]
  00975	4d 8b c6	 mov	 r8, r14
  00978	48 8b cf	 mov	 rcx, rdi
  0097b	e8 00 00 00 00	 call	 merge_right
$LN362@gpc_polygo:

; 1430 :             edge->outp[BELOW]= NULL;

  00980	48 83 63 78 00	 and	 QWORD PTR [rbx+120], 0

; 1431 :             add_local_min(&out_poly, edge, xb, yb);

  00985	48 8d 4c 24 58	 lea	 rcx, QWORD PTR out_poly$[rsp]
  0098a	66 41 0f 28 d8	 movapd	 xmm3, xmm8
  0098f	66 0f 28 d6	 movapd	 xmm2, xmm6
  00993	48 8b d3	 mov	 rdx, rbx
  00996	e8 00 00 00 00	 call	 add_local_min
$LN364@gpc_polygo:

; 1432 :             cf= edge->outp[ABOVE];

  0099b	4c 8b 74 24 58	 mov	 r14, QWORD PTR out_poly$[rsp]
  009a0	48 8b 43 70	 mov	 rax, QWORD PTR [rbx+112]
$LN363@gpc_polygo:
  009a4	48 89 44 24 40	 mov	 QWORD PTR cf$1$[rsp], rax
$LN129@gpc_polygo:

; 1275 :     horiz[SUBJ]= NH;
; 1276 : 
; 1277 :     /* Process each edge at this scanbeam boundary */
; 1278 :     for (edge= aet; edge; edge= edge->next)

  009a9	48 8b 9b 88 00
	00 00		 mov	 rbx, QWORD PTR [rbx+136]
  009b0	48 85 db	 test	 rbx, rbx
  009b3	0f 85 73 fa ff
	ff		 jne	 $LL130@gpc_polygo
  009b9	44 89 7c 24 34	 mov	 DWORD PTR tl$[rsp], r15d
  009be	4c 8b 7c 24 70	 mov	 r15, QWORD PTR aet$[rsp]
  009c3	44 89 6c 24 3c	 mov	 DWORD PTR bl$[rsp], r13d
  009c8	4c 8b ac 24 78
	01 00 00	 mov	 r13, QWORD PTR result$[rsp]

; 1446 :           default:
; 1447 :             break;
; 1448 :           } /* End of switch */
; 1449 :         } /* End of contributing conditional */
; 1450 :       } /* End of edge exists conditional */
; 1451 :     } /* End of AET loop */
; 1452 : 
; 1453 :     /* Delete terminating edges from the AET, otherwise compute xt */
; 1454 :     for (edge= aet; edge; edge= edge->next)

  009d0	49 8b cf	 mov	 rcx, r15
$LL95@gpc_polygo:

; 1455 :     {
; 1456 :       if (edge->top.y == yb)

  009d3	f2 0f 10 41 28	 movsdx	 xmm0, QWORD PTR [rcx+40]
  009d8	66 41 0f 2e c0	 ucomisd xmm0, xmm8
  009dd	7a 68		 jp	 SHORT $LN92@gpc_polygo
  009df	75 66		 jne	 SHORT $LN92@gpc_polygo

; 1457 :       {
; 1458 :         prev_edge= edge->prev;

  009e1	48 8b 91 80 00
	00 00		 mov	 rdx, QWORD PTR [rcx+128]

; 1459 :         next_edge= edge->next;

  009e8	48 8b 81 88 00
	00 00		 mov	 rax, QWORD PTR [rcx+136]

; 1460 :         if (prev_edge)

  009ef	48 85 d2	 test	 rdx, rdx
  009f2	74 09		 je	 SHORT $LN91@gpc_polygo

; 1461 :           prev_edge->next= next_edge;

  009f4	48 89 82 88 00
	00 00		 mov	 QWORD PTR [rdx+136], rax

; 1462 :         else

  009fb	eb 03		 jmp	 SHORT $LN90@gpc_polygo
$LN91@gpc_polygo:

; 1463 :           aet= next_edge;

  009fd	4c 8b f8	 mov	 r15, rax
$LN90@gpc_polygo:

; 1464 :         if (next_edge)

  00a00	48 85 c0	 test	 rax, rax
  00a03	74 07		 je	 SHORT $LN89@gpc_polygo

; 1465 :           next_edge->prev= prev_edge;

  00a05	48 89 90 80 00
	00 00		 mov	 QWORD PTR [rax+128], rdx
$LN89@gpc_polygo:

; 1466 : 
; 1467 :         /* Copy bundle head state to the adjacent tail edge if required */
; 1468 :         if ((edge->bstate[BELOW] == BUNDLE_HEAD) && prev_edge)

  00a0c	41 bb 01 00 00
	00		 mov	 r11d, 1
  00a12	44 39 59 68	 cmp	 DWORD PTR [rcx+104], r11d
  00a16	75 61		 jne	 SHORT $LN94@gpc_polygo
  00a18	48 85 d2	 test	 rdx, rdx
  00a1b	74 5c		 je	 SHORT $LN94@gpc_polygo

; 1469 : 	{
; 1470 :           if (prev_edge->bstate[BELOW] == BUNDLE_TAIL)

  00a1d	83 7a 68 02	 cmp	 DWORD PTR [rdx+104], 2
  00a21	75 56		 jne	 SHORT $LN94@gpc_polygo

; 1471 :           {
; 1472 :             prev_edge->outp[BELOW]= edge->outp[BELOW];

  00a23	48 8b 41 78	 mov	 rax, QWORD PTR [rcx+120]

; 1473 :             prev_edge->bstate[BELOW]= UNBUNDLED;

  00a27	83 62 68 00	 and	 DWORD PTR [rdx+104], 0
  00a2b	48 89 42 78	 mov	 QWORD PTR [rdx+120], rax

; 1474 :             if (prev_edge->prev)

  00a2f	48 8b 82 80 00
	00 00		 mov	 rax, QWORD PTR [rdx+128]
  00a36	48 85 c0	 test	 rax, rax
  00a39	74 3e		 je	 SHORT $LN94@gpc_polygo

; 1475 :               if (prev_edge->prev->bstate[BELOW] == BUNDLE_TAIL)

  00a3b	83 78 68 02	 cmp	 DWORD PTR [rax+104], 2
  00a3f	75 38		 jne	 SHORT $LN94@gpc_polygo

; 1476 :                 prev_edge->bstate[BELOW]= BUNDLE_HEAD;

  00a41	44 89 5a 68	 mov	 DWORD PTR [rdx+104], r11d

; 1477 : 	  }
; 1478 : 	}
; 1479 :       }
; 1480 :       else

  00a45	eb 32		 jmp	 SHORT $LN94@gpc_polygo
$LN92@gpc_polygo:

; 1481 :       {
; 1482 :         if (edge->top.y == yt)

  00a47	66 41 0f 2e c1	 ucomisd xmm0, xmm9
  00a4c	7a 0c		 jp	 SHORT $LN83@gpc_polygo
  00a4e	75 0a		 jne	 SHORT $LN83@gpc_polygo

; 1483 :           edge->xt= edge->top.x;

  00a50	48 8b 41 20	 mov	 rax, QWORD PTR [rcx+32]
  00a54	48 89 41 38	 mov	 QWORD PTR [rcx+56], rax

; 1484 :         else

  00a58	eb 19		 jmp	 SHORT $LN366@gpc_polygo
$LN83@gpc_polygo:

; 1485 :           edge->xt= edge->bot.x + edge->dx * (yt - edge->bot.y);

  00a5a	66 41 0f 28 c1	 movapd	 xmm0, xmm9
  00a5f	f2 0f 5c 41 18	 subsd	 xmm0, QWORD PTR [rcx+24]
  00a64	f2 0f 59 41 40	 mulsd	 xmm0, QWORD PTR [rcx+64]
  00a69	f2 0f 58 41 10	 addsd	 xmm0, QWORD PTR [rcx+16]
  00a6e	f2 0f 11 41 38	 movsdx	 QWORD PTR [rcx+56], xmm0
$LN366@gpc_polygo:
  00a73	41 bb 01 00 00
	00		 mov	 r11d, 1
$LN94@gpc_polygo:

; 1446 :           default:
; 1447 :             break;
; 1448 :           } /* End of switch */
; 1449 :         } /* End of contributing conditional */
; 1450 :       } /* End of edge exists conditional */
; 1451 :     } /* End of AET loop */
; 1452 : 
; 1453 :     /* Delete terminating edges from the AET, otherwise compute xt */
; 1454 :     for (edge= aet; edge; edge= edge->next)

  00a79	48 8b 89 88 00
	00 00		 mov	 rcx, QWORD PTR [rcx+136]
  00a80	48 85 c9	 test	 rcx, rcx
  00a83	0f 85 4a ff ff
	ff		 jne	 $LL95@gpc_polygo

; 1486 :       }
; 1487 :     }
; 1488 : 
; 1489 :     if (scanbeam < sbt_entries)

  00a89	8b 54 24 48	 mov	 edx, DWORD PTR scanbeam$[rsp]
  00a8d	4c 89 7c 24 70	 mov	 QWORD PTR aet$[rsp], r15
  00a92	3b 54 24 4c	 cmp	 edx, DWORD PTR sbt_entries$[rsp]
  00a96	0f 8d 55 06 00
	00		 jge	 $LN322@gpc_polygo

; 1490 :     {
; 1491 :       /* === SCANBEAM INTERIOR PROCESSING ============================== */
; 1492 : 
; 1493 :       build_intersection_table(&it, aet, dy);

  00a9c	48 39 4c 24 68	 cmp	 QWORD PTR it$[rsp], rcx
  00aa1	74 20		 je	 SHORT $LN254@gpc_polygo
$LL255@gpc_polygo:
  00aa3	4c 8b 64 24 68	 mov	 r12, QWORD PTR it$[rsp]
  00aa8	49 8b cc	 mov	 rcx, r12
  00aab	49 8b 5c 24 20	 mov	 rbx, QWORD PTR [r12+32]
  00ab0	e8 00 00 00 00	 call	 free
  00ab5	48 89 5c 24 68	 mov	 QWORD PTR it$[rsp], rbx
  00aba	48 85 db	 test	 rbx, rbx
  00abd	75 e4		 jne	 SHORT $LL255@gpc_polygo
  00abf	8b 54 24 48	 mov	 edx, DWORD PTR scanbeam$[rsp]
$LN254@gpc_polygo:
  00ac3	48 83 a4 24 90
	00 00 00 00	 and	 QWORD PTR st$113967[rsp], 0
  00acc	49 8b df	 mov	 rbx, r15
  00acf	4d 85 ff	 test	 r15, r15
  00ad2	74 5a		 je	 SHORT $LN244@gpc_polygo
$LL250@gpc_polygo:
  00ad4	83 7b 64 01	 cmp	 DWORD PTR [rbx+100], 1
  00ad8	74 0c		 je	 SHORT $LN246@gpc_polygo
  00ada	83 7b 4c 00	 cmp	 DWORD PTR [rbx+76], 0
  00ade	75 06		 jne	 SHORT $LN246@gpc_polygo
  00ae0	83 7b 50 00	 cmp	 DWORD PTR [rbx+80], 0
  00ae4	74 1a		 je	 SHORT $LN249@gpc_polygo
$LN246@gpc_polygo:
  00ae6	48 8d 54 24 68	 lea	 rdx, QWORD PTR it$[rsp]
  00aeb	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR st$113967[rsp]
  00af3	66 41 0f 28 da	 movapd	 xmm3, xmm10
  00af8	4c 8b c3	 mov	 r8, rbx
  00afb	e8 00 00 00 00	 call	 add_st_edge
$LN249@gpc_polygo:
  00b00	48 8b 9b 88 00
	00 00		 mov	 rbx, QWORD PTR [rbx+136]
  00b07	48 85 db	 test	 rbx, rbx
  00b0a	75 c8		 jne	 SHORT $LL250@gpc_polygo
  00b0c	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR st$113967[rsp]
  00b14	48 85 c9	 test	 rcx, rcx
  00b17	74 11		 je	 SHORT $LN336@gpc_polygo
$LL245@gpc_polygo:
  00b19	48 8b 59 20	 mov	 rbx, QWORD PTR [rcx+32]
  00b1d	e8 00 00 00 00	 call	 free
  00b22	48 8b cb	 mov	 rcx, rbx
  00b25	48 85 db	 test	 rbx, rbx
  00b28	75 ef		 jne	 SHORT $LL245@gpc_polygo
$LN336@gpc_polygo:
  00b2a	8b 54 24 48	 mov	 edx, DWORD PTR scanbeam$[rsp]
$LN244@gpc_polygo:

; 1494 : 
; 1495 :       /* Process each node in the intersection table */
; 1496 :       for (intersect= it; intersect; intersect= intersect->next)

  00b2e	4c 8b 64 24 68	 mov	 r12, QWORD PTR it$[rsp]
  00b33	41 bb 01 00 00
	00		 mov	 r11d, 1
  00b39	4d 85 e4	 test	 r12, r12
  00b3c	0f 84 d6 04 00
	00		 je	 $LN78@gpc_polygo
  00b42	44 8b 6c 24 3c	 mov	 r13d, DWORD PTR bl$[rsp]
$LL80@gpc_polygo:

; 1497 :       {
; 1498 :         e0= intersect->ie[0];

  00b47	49 8b 3c 24	 mov	 rdi, QWORD PTR [r12]

; 1499 :         e1= intersect->ie[1];

  00b4b	49 8b 5c 24 08	 mov	 rbx, QWORD PTR [r12+8]

; 1500 : 
; 1501 :         /* Only generate output for contributing intersections */
; 1502 :         if ((e0->bundle[ABOVE][CLIP] || e0->bundle[ABOVE][SUBJ])
; 1503 :          && (e1->bundle[ABOVE][CLIP] || e1->bundle[ABOVE][SUBJ]))

  00b50	44 8b 57 4c	 mov	 r10d, DWORD PTR [rdi+76]
  00b54	45 85 d2	 test	 r10d, r10d
  00b57	75 0a		 jne	 SHORT $LN76@gpc_polygo
  00b59	44 39 57 50	 cmp	 DWORD PTR [rdi+80], r10d
  00b5d	0f 84 a9 03 00
	00		 je	 $LN50@gpc_polygo
$LN76@gpc_polygo:
  00b63	44 8b 43 4c	 mov	 r8d, DWORD PTR [rbx+76]
  00b67	45 85 c0	 test	 r8d, r8d
  00b6a	75 0a		 jne	 SHORT $LN75@gpc_polygo
  00b6c	44 39 43 50	 cmp	 DWORD PTR [rbx+80], r8d
  00b70	0f 84 96 03 00
	00		 je	 $LN50@gpc_polygo
$LN75@gpc_polygo:

; 1504 : 	{
; 1505 :           p= e0->outp[ABOVE];

  00b76	48 8b 77 70	 mov	 rsi, QWORD PTR [rdi+112]

; 1506 :           q= e1->outp[ABOVE];

  00b7a	48 8b 6b 70	 mov	 rbp, QWORD PTR [rbx+112]

; 1507 :           ix= intersect->point.x;

  00b7e	f2 41 0f 10 7c
	24 10		 movsdx	 xmm7, QWORD PTR [r12+16]

; 1508 :           iy= intersect->point.y + yb;

  00b85	66 41 0f 28 f0	 movapd	 xmm6, xmm8
  00b8a	f2 41 0f 58 74
	24 18		 addsd	 xmm6, QWORD PTR [r12+24]

; 1509 :  
; 1510 :           in[CLIP]= ( e0->bundle[ABOVE][CLIP] && !e0->bside[CLIP])
; 1511 :                  || ( e1->bundle[ABOVE][CLIP] &&  e1->bside[CLIP])
; 1512 :                  || (!e0->bundle[ABOVE][CLIP] && !e1->bundle[ABOVE][CLIP]
; 1513 :                      && e0->bside[CLIP] && e1->bside[CLIP]);

  00b91	45 85 d2	 test	 r10d, r10d
  00b94	74 06		 je	 SHORT $LN198@gpc_polygo
  00b96	83 7f 5c 00	 cmp	 DWORD PTR [rdi+92], 0
  00b9a	74 21		 je	 SHORT $LN200@gpc_polygo
$LN198@gpc_polygo:
  00b9c	45 85 c0	 test	 r8d, r8d
  00b9f	74 06		 je	 SHORT $LN199@gpc_polygo
  00ba1	83 7b 5c 00	 cmp	 DWORD PTR [rbx+92], 0
  00ba5	75 16		 jne	 SHORT $LN200@gpc_polygo
$LN199@gpc_polygo:
  00ba7	45 85 d2	 test	 r10d, r10d
  00baa	75 16		 jne	 SHORT $LN201@gpc_polygo
  00bac	45 85 c0	 test	 r8d, r8d
  00baf	75 11		 jne	 SHORT $LN201@gpc_polygo
  00bb1	44 39 47 5c	 cmp	 DWORD PTR [rdi+92], r8d
  00bb5	74 0b		 je	 SHORT $LN201@gpc_polygo
  00bb7	44 39 43 5c	 cmp	 DWORD PTR [rbx+92], r8d
  00bbb	74 05		 je	 SHORT $LN201@gpc_polygo
$LN200@gpc_polygo:
  00bbd	41 8b d3	 mov	 edx, r11d
  00bc0	eb 02		 jmp	 SHORT $LN202@gpc_polygo
$LN201@gpc_polygo:
  00bc2	33 d2		 xor	 edx, edx
$LN202@gpc_polygo:

; 1514 :           in[SUBJ]= ( e0->bundle[ABOVE][SUBJ] && !e0->bside[SUBJ])
; 1515 :                  || ( e1->bundle[ABOVE][SUBJ] &&  e1->bside[SUBJ])
; 1516 :                  || (!e0->bundle[ABOVE][SUBJ] && !e1->bundle[ABOVE][SUBJ]
; 1517 :                      && e0->bside[SUBJ] && e1->bside[SUBJ]);

  00bc4	44 8b 4f 50	 mov	 r9d, DWORD PTR [rdi+80]
  00bc8	45 85 c9	 test	 r9d, r9d
  00bcb	74 06		 je	 SHORT $LN203@gpc_polygo
  00bcd	83 7f 60 00	 cmp	 DWORD PTR [rdi+96], 0
  00bd1	74 20		 je	 SHORT $LN205@gpc_polygo
$LN203@gpc_polygo:
  00bd3	8b 43 50	 mov	 eax, DWORD PTR [rbx+80]
  00bd6	85 c0		 test	 eax, eax
  00bd8	74 06		 je	 SHORT $LN204@gpc_polygo
  00bda	83 7b 60 00	 cmp	 DWORD PTR [rbx+96], 0
  00bde	75 13		 jne	 SHORT $LN205@gpc_polygo
$LN204@gpc_polygo:
  00be0	45 85 c9	 test	 r9d, r9d
  00be3	75 13		 jne	 SHORT $LN206@gpc_polygo
  00be5	85 c0		 test	 eax, eax
  00be7	75 0f		 jne	 SHORT $LN206@gpc_polygo
  00be9	39 47 60	 cmp	 DWORD PTR [rdi+96], eax
  00bec	74 0a		 je	 SHORT $LN206@gpc_polygo
  00bee	39 43 60	 cmp	 DWORD PTR [rbx+96], eax
  00bf1	74 05		 je	 SHORT $LN206@gpc_polygo
$LN205@gpc_polygo:
  00bf3	41 8b cb	 mov	 ecx, r11d
  00bf6	eb 02		 jmp	 SHORT $LN207@gpc_polygo
$LN206@gpc_polygo:
  00bf8	33 c9		 xor	 ecx, ecx
$LN207@gpc_polygo:

; 1518 :        
; 1519 :           /* Determine quadrant occupancies */
; 1520 :           switch (op)

  00bfa	8b 84 24 60 01
	00 00		 mov	 eax, DWORD PTR op$[rsp]
  00c01	85 c0		 test	 eax, eax
  00c03	78 71		 js	 SHORT $LN343@gpc_polygo
  00c05	41 3b c3	 cmp	 eax, r11d
  00c08	0f 8e 07 01 00
	00		 jle	 $LN72@gpc_polygo
  00c0e	83 f8 02	 cmp	 eax, 2
  00c11	0f 84 c2 00 00
	00		 je	 $LN71@gpc_polygo
  00c17	83 f8 03	 cmp	 eax, 3
  00c1a	75 5a		 jne	 SHORT $LN343@gpc_polygo

; 1543 :           case GPC_UNION:
; 1544 :             tr= (in[CLIP])
; 1545 :              || (in[SUBJ]);

  00c1c	85 d2		 test	 edx, edx
  00c1e	75 0a		 jne	 SHORT $LN216@gpc_polygo
  00c20	85 c9		 test	 ecx, ecx
  00c22	75 06		 jne	 SHORT $LN216@gpc_polygo
  00c24	21 4c 24 38	 and	 DWORD PTR tr$[rsp], ecx
  00c28	eb 05		 jmp	 SHORT $LN217@gpc_polygo
$LN216@gpc_polygo:
  00c2a	44 89 5c 24 38	 mov	 DWORD PTR tr$[rsp], r11d
$LN217@gpc_polygo:

; 1546 :             tl= (in[CLIP] ^ e1->bundle[ABOVE][CLIP])
; 1547 :              || (in[SUBJ] ^ e1->bundle[ABOVE][SUBJ]);

  00c2f	41 8b c0	 mov	 eax, r8d
  00c32	33 c2		 xor	 eax, edx
  00c34	75 0d		 jne	 SHORT $LN218@gpc_polygo
  00c36	8b 43 50	 mov	 eax, DWORD PTR [rbx+80]
  00c39	33 c1		 xor	 eax, ecx
  00c3b	75 06		 jne	 SHORT $LN218@gpc_polygo
  00c3d	21 44 24 34	 and	 DWORD PTR tl$[rsp], eax
  00c41	eb 05		 jmp	 SHORT $LN219@gpc_polygo
$LN218@gpc_polygo:
  00c43	44 89 5c 24 34	 mov	 DWORD PTR tl$[rsp], r11d
$LN219@gpc_polygo:

; 1548 :             br= (in[CLIP] ^ e0->bundle[ABOVE][CLIP])
; 1549 :              || (in[SUBJ] ^ e0->bundle[ABOVE][SUBJ]);

  00c48	41 8b c2	 mov	 eax, r10d
  00c4b	33 c2		 xor	 eax, edx
  00c4d	75 0d		 jne	 SHORT $LN220@gpc_polygo
  00c4f	41 8b c1	 mov	 eax, r9d
  00c52	33 c1		 xor	 eax, ecx
  00c54	75 06		 jne	 SHORT $LN220@gpc_polygo
  00c56	21 44 24 30	 and	 DWORD PTR br$[rsp], eax
  00c5a	eb 05		 jmp	 SHORT $LN221@gpc_polygo
$LN220@gpc_polygo:
  00c5c	44 89 5c 24 30	 mov	 DWORD PTR br$[rsp], r11d
$LN221@gpc_polygo:

; 1550 :             bl= (in[CLIP] ^ e1->bundle[ABOVE][CLIP] ^ e0->bundle[ABOVE][CLIP])
; 1551 :              || (in[SUBJ] ^ e1->bundle[ABOVE][SUBJ] ^ e0->bundle[ABOVE][SUBJ]);

  00c61	45 33 c2	 xor	 r8d, r10d
  00c64	44 33 c2	 xor	 r8d, edx
  00c67	75 6b		 jne	 SHORT $LN222@gpc_polygo
  00c69	8b 43 50	 mov	 eax, DWORD PTR [rbx+80]
  00c6c	41 33 c1	 xor	 eax, r9d
  00c6f	33 c1		 xor	 eax, ecx
  00c71	75 61		 jne	 SHORT $LN222@gpc_polygo
  00c73	45 33 ed	 xor	 r13d, r13d
$LN343@gpc_polygo:
  00c76	44 8b 5c 24 30	 mov	 r11d, DWORD PTR br$[rsp]
$LN215@gpc_polygo:

; 1553 :           }
; 1554 : 	  
; 1555 :           vclass= tr + (tl << 1) + (br << 2) + (bl << 3);

  00c7b	8b 4c 24 34	 mov	 ecx, DWORD PTR tl$[rsp]
  00c7f	43 8d 04 6b	 lea	 eax, DWORD PTR [r11+r13*2]
  00c83	8d 0c 41	 lea	 ecx, DWORD PTR [rcx+rax*2]
  00c86	8b 44 24 38	 mov	 eax, DWORD PTR tr$[rsp]
  00c8a	8d 14 48	 lea	 edx, DWORD PTR [rax+rcx*2]

; 1556 : 
; 1557 :           switch (vclass)

  00c8d	83 fa 08	 cmp	 edx, 8
  00c90	0f 8f a2 01 00
	00		 jg	 $LN224@gpc_polygo
  00c96	0f 84 48 02 00
	00		 je	 $LN368@gpc_polygo
  00c9c	41 bb 01 00 00
	00		 mov	 r11d, 1
  00ca2	41 2b d3	 sub	 edx, r11d
  00ca5	0f 84 56 01 00
	00		 je	 $LN62@gpc_polygo
  00cab	41 2b d3	 sub	 edx, r11d
  00cae	0f 84 26 01 00
	00		 je	 $LN64@gpc_polygo
  00cb4	83 ea 02	 sub	 edx, 2
  00cb7	0f 84 f6 00 00
	00		 je	 $LN66@gpc_polygo
  00cbd	83 ea 02	 sub	 edx, 2
  00cc0	0f 84 b8 00 00
	00		 je	 $LN53@gpc_polygo
  00cc6	41 3b d3	 cmp	 edx, r11d
  00cc9	0f 85 3d 02 00
	00		 jne	 $LN50@gpc_polygo

; 1588 :           case IMN:
; 1589 :             add_local_min(&out_poly, e0, ix, iy);
; 1590 :             e1->outp[ABOVE]= e0->outp[ABOVE];
; 1591 :             break;

  00ccf	e9 10 02 00 00	 jmp	 $LN368@gpc_polygo
$LN222@gpc_polygo:

; 1550 :             bl= (in[CLIP] ^ e1->bundle[ABOVE][CLIP] ^ e0->bundle[ABOVE][CLIP])
; 1551 :              || (in[SUBJ] ^ e1->bundle[ABOVE][SUBJ] ^ e0->bundle[ABOVE][SUBJ]);

  00cd4	45 8b eb	 mov	 r13d, r11d

; 1552 :             break;

  00cd7	eb 9d		 jmp	 SHORT $LN343@gpc_polygo
$LN71@gpc_polygo:

; 1532 :             break;
; 1533 :           case GPC_XOR:
; 1534 :             tr= (in[CLIP])
; 1535 :               ^ (in[SUBJ]);
; 1536 :             tl= (in[CLIP] ^ e1->bundle[ABOVE][CLIP])
; 1537 :               ^ (in[SUBJ] ^ e1->bundle[ABOVE][SUBJ]);

  00cd9	44 8b 6b 50	 mov	 r13d, DWORD PTR [rbx+80]
  00cdd	8b c1		 mov	 eax, ecx

; 1538 :             br= (in[CLIP] ^ e0->bundle[ABOVE][CLIP])
; 1539 :               ^ (in[SUBJ] ^ e0->bundle[ABOVE][SUBJ]);

  00cdf	45 8b d9	 mov	 r11d, r9d
  00ce2	33 c2		 xor	 eax, edx
  00ce4	45 33 e8	 xor	 r13d, r8d
  00ce7	45 33 da	 xor	 r11d, r10d
  00cea	89 44 24 38	 mov	 DWORD PTR tr$[rsp], eax
  00cee	41 8b c5	 mov	 eax, r13d

; 1540 :             bl= (in[CLIP] ^ e1->bundle[ABOVE][CLIP] ^ e0->bundle[ABOVE][CLIP])
; 1541 :               ^ (in[SUBJ] ^ e1->bundle[ABOVE][SUBJ] ^ e0->bundle[ABOVE][SUBJ]);

  00cf1	45 33 e9	 xor	 r13d, r9d
  00cf4	45 33 ea	 xor	 r13d, r10d
  00cf7	33 c1		 xor	 eax, ecx
  00cf9	44 33 d9	 xor	 r11d, ecx
  00cfc	33 c2		 xor	 eax, edx
  00cfe	44 33 da	 xor	 r11d, edx
  00d01	44 33 e9	 xor	 r13d, ecx
  00d04	44 33 ea	 xor	 r13d, edx
  00d07	89 44 24 34	 mov	 DWORD PTR tl$[rsp], eax
  00d0b	44 89 5c 24 30	 mov	 DWORD PTR br$[rsp], r11d

; 1542 :             break;

  00d10	e9 66 ff ff ff	 jmp	 $LN215@gpc_polygo
$LN72@gpc_polygo:

; 1521 :           {
; 1522 :           case GPC_DIFF:
; 1523 :           case GPC_INT:
; 1524 :             tr= (in[CLIP])
; 1525 :              && (in[SUBJ]);

  00d15	85 d2		 test	 edx, edx
  00d17	74 0b		 je	 SHORT $LN208@gpc_polygo
  00d19	85 c9		 test	 ecx, ecx
  00d1b	74 07		 je	 SHORT $LN208@gpc_polygo
  00d1d	44 89 5c 24 38	 mov	 DWORD PTR tr$[rsp], r11d
  00d22	eb 05		 jmp	 SHORT $LN209@gpc_polygo
$LN208@gpc_polygo:
  00d24	83 64 24 38 00	 and	 DWORD PTR tr$[rsp], 0
$LN209@gpc_polygo:

; 1526 :             tl= (in[CLIP] ^ e1->bundle[ABOVE][CLIP])
; 1527 :              && (in[SUBJ] ^ e1->bundle[ABOVE][SUBJ]);

  00d29	41 8b c0	 mov	 eax, r8d
  00d2c	33 c2		 xor	 eax, edx
  00d2e	74 0e		 je	 SHORT $LN210@gpc_polygo
  00d30	8b 43 50	 mov	 eax, DWORD PTR [rbx+80]
  00d33	33 c1		 xor	 eax, ecx
  00d35	74 07		 je	 SHORT $LN210@gpc_polygo
  00d37	44 89 5c 24 34	 mov	 DWORD PTR tl$[rsp], r11d
  00d3c	eb 05		 jmp	 SHORT $LN211@gpc_polygo
$LN210@gpc_polygo:
  00d3e	83 64 24 34 00	 and	 DWORD PTR tl$[rsp], 0
$LN211@gpc_polygo:

; 1528 :             br= (in[CLIP] ^ e0->bundle[ABOVE][CLIP])
; 1529 :              && (in[SUBJ] ^ e0->bundle[ABOVE][SUBJ]);

  00d43	41 8b c2	 mov	 eax, r10d
  00d46	33 c2		 xor	 eax, edx
  00d48	74 07		 je	 SHORT $LN212@gpc_polygo
  00d4a	41 8b c1	 mov	 eax, r9d
  00d4d	33 c1		 xor	 eax, ecx
  00d4f	75 03		 jne	 SHORT $LN367@gpc_polygo
$LN212@gpc_polygo:
  00d51	45 33 db	 xor	 r11d, r11d
$LN367@gpc_polygo:

; 1530 :             bl= (in[CLIP] ^ e1->bundle[ABOVE][CLIP] ^ e0->bundle[ABOVE][CLIP])
; 1531 :              && (in[SUBJ] ^ e1->bundle[ABOVE][SUBJ] ^ e0->bundle[ABOVE][SUBJ]);

  00d54	45 33 c2	 xor	 r8d, r10d
  00d57	44 89 5c 24 30	 mov	 DWORD PTR br$[rsp], r11d
  00d5c	44 33 c2	 xor	 r8d, edx
  00d5f	74 15		 je	 SHORT $LN214@gpc_polygo
  00d61	8b 43 50	 mov	 eax, DWORD PTR [rbx+80]
  00d64	41 33 c1	 xor	 eax, r9d
  00d67	33 c1		 xor	 eax, ecx
  00d69	74 0b		 je	 SHORT $LN214@gpc_polygo
  00d6b	41 bd 01 00 00
	00		 mov	 r13d, 1
  00d71	e9 05 ff ff ff	 jmp	 $LN215@gpc_polygo
$LN214@gpc_polygo:
  00d76	45 33 ed	 xor	 r13d, r13d
  00d79	e9 fd fe ff ff	 jmp	 $LN215@gpc_polygo
$LN53@gpc_polygo:

; 1617 :           case IMM:
; 1618 :             if (p && q)

  00d7e	48 85 f6	 test	 rsi, rsi
  00d81	0f 84 85 01 00
	00		 je	 $LN50@gpc_polygo
  00d87	48 85 ed	 test	 rbp, rbp
  00d8a	0f 84 7c 01 00
	00		 je	 $LN50@gpc_polygo

; 1619 :             {
; 1620 :               add_right(p, ix, iy);

  00d90	66 0f 28 d6	 movapd	 xmm2, xmm6
  00d94	66 0f 28 cf	 movapd	 xmm1, xmm7
  00d98	48 8b ce	 mov	 rcx, rsi
  00d9b	e8 00 00 00 00	 call	 add_right

; 1621 :               merge_left(p, q, out_poly);

  00da0	4d 8b c6	 mov	 r8, r14
  00da3	48 8b d5	 mov	 rdx, rbp
  00da6	48 8b ce	 mov	 rcx, rsi
  00da9	e8 00 00 00 00	 call	 merge_left

; 1622 :               add_local_min(&out_poly, e0, ix, iy);
; 1623 :               e1->outp[ABOVE]= e0->outp[ABOVE];
; 1624 :             }
; 1625 :             break;

  00dae	e9 31 01 00 00	 jmp	 $LN368@gpc_polygo
$LN66@gpc_polygo:

; 1558 :           {
; 1559 :           case EMN:
; 1560 :             add_local_min(&out_poly, e0, ix, iy);
; 1561 :             e1->outp[ABOVE]= e0->outp[ABOVE];
; 1562 :             break;
; 1563 :           case ERI:
; 1564 :             if (p)

  00db3	48 85 f6	 test	 rsi, rsi
  00db6	0f 84 50 01 00
	00		 je	 $LN50@gpc_polygo

; 1565 :             {
; 1566 :               add_right(p, ix, iy);

  00dbc	66 0f 28 d6	 movapd	 xmm2, xmm6
  00dc0	66 0f 28 cf	 movapd	 xmm1, xmm7
  00dc4	48 8b ce	 mov	 rcx, rsi
  00dc7	e8 00 00 00 00	 call	 add_right
$LN369@gpc_polygo:

; 1567 :               e1->outp[ABOVE]= p;

  00dcc	48 89 73 70	 mov	 QWORD PTR [rbx+112], rsi

; 1568 :               e0->outp[ABOVE]= NULL;

  00dd0	48 83 67 70 00	 and	 QWORD PTR [rdi+112], 0

; 1569 :             }
; 1570 :             break;

  00dd5	e9 2c 01 00 00	 jmp	 $LN356@gpc_polygo
$LN64@gpc_polygo:

; 1571 :           case ELI:
; 1572 :             if (q)

  00dda	48 85 ed	 test	 rbp, rbp
  00ddd	0f 84 29 01 00
	00		 je	 $LN50@gpc_polygo

; 1573 :             {
; 1574 :               add_left(q, ix, iy);

  00de3	66 0f 28 d6	 movapd	 xmm2, xmm6
  00de7	66 0f 28 cf	 movapd	 xmm1, xmm7
  00deb	48 8b cd	 mov	 rcx, rbp
  00dee	e8 00 00 00 00	 call	 add_left
$LN371@gpc_polygo:

; 1575 :               e0->outp[ABOVE]= q;

  00df3	48 89 6f 70	 mov	 QWORD PTR [rdi+112], rbp
$LN370@gpc_polygo:

; 1576 :               e1->outp[ABOVE]= NULL;

  00df7	48 83 63 70 00	 and	 QWORD PTR [rbx+112], 0

; 1577 :             }
; 1578 :             break;

  00dfc	e9 05 01 00 00	 jmp	 $LN356@gpc_polygo
$LN62@gpc_polygo:

; 1579 :           case EMX:
; 1580 :             if (p && q)

  00e01	48 85 f6	 test	 rsi, rsi
  00e04	0f 84 02 01 00
	00		 je	 $LN50@gpc_polygo
  00e0a	48 85 ed	 test	 rbp, rbp
  00e0d	0f 84 f9 00 00
	00		 je	 $LN50@gpc_polygo

; 1581 :             {
; 1582 :               add_left(p, ix, iy);

  00e13	66 0f 28 d6	 movapd	 xmm2, xmm6
  00e17	66 0f 28 cf	 movapd	 xmm1, xmm7
  00e1b	48 8b ce	 mov	 rcx, rsi
  00e1e	e8 00 00 00 00	 call	 add_left

; 1583 :               merge_right(p, q, out_poly);

  00e23	4d 8b c6	 mov	 r8, r14
  00e26	48 8b d5	 mov	 rdx, rbp
  00e29	48 8b ce	 mov	 rcx, rsi
  00e2c	e8 00 00 00 00	 call	 merge_right
$LN376@gpc_polygo:

; 1584 :               e0->outp[ABOVE]= NULL;

  00e31	48 83 67 70 00	 and	 QWORD PTR [rdi+112], 0

; 1585 :               e1->outp[ABOVE]= NULL;
; 1586 :             }
; 1587 :             break;

  00e36	eb bf		 jmp	 SHORT $LN370@gpc_polygo
$LN224@gpc_polygo:

; 1556 : 
; 1557 :           switch (vclass)

  00e38	83 ea 09	 sub	 edx, 9
  00e3b	74 7f		 je	 SHORT $LN51@gpc_polygo
  00e3d	83 ea 02	 sub	 edx, 2
  00e40	74 60		 je	 SHORT $LN59@gpc_polygo
  00e42	83 ea 02	 sub	 edx, 2
  00e45	74 41		 je	 SHORT $LN57@gpc_polygo
  00e47	41 bb 01 00 00
	00		 mov	 r11d, 1
  00e4d	41 3b d3	 cmp	 edx, r11d
  00e50	0f 85 b6 00 00
	00		 jne	 $LN50@gpc_polygo

; 1608 :           case IMX:
; 1609 :             if (p && q)

  00e56	48 85 f6	 test	 rsi, rsi
  00e59	0f 84 ad 00 00
	00		 je	 $LN50@gpc_polygo
  00e5f	48 85 ed	 test	 rbp, rbp
  00e62	0f 84 a4 00 00
	00		 je	 $LN50@gpc_polygo

; 1610 :             {
; 1611 :               add_right(p, ix, iy);

  00e68	66 0f 28 d6	 movapd	 xmm2, xmm6
  00e6c	66 0f 28 cf	 movapd	 xmm1, xmm7
  00e70	48 8b ce	 mov	 rcx, rsi
  00e73	e8 00 00 00 00	 call	 add_right

; 1612 :               merge_left(p, q, out_poly);

  00e78	4d 8b c6	 mov	 r8, r14
  00e7b	48 8b d5	 mov	 rdx, rbp
  00e7e	48 8b ce	 mov	 rcx, rsi
  00e81	e8 00 00 00 00	 call	 merge_left

; 1613 :               e0->outp[ABOVE]= NULL;
; 1614 :               e1->outp[ABOVE]= NULL;
; 1615 :             }
; 1616 :             break;

  00e86	eb a9		 jmp	 SHORT $LN376@gpc_polygo
$LN57@gpc_polygo:

; 1600 :           case IRI:
; 1601 :             if (q)

  00e88	48 85 ed	 test	 rbp, rbp
  00e8b	74 79		 je	 SHORT $LN356@gpc_polygo

; 1602 :             {
; 1603 :               add_right(q, ix, iy);

  00e8d	66 0f 28 d6	 movapd	 xmm2, xmm6
  00e91	66 0f 28 cf	 movapd	 xmm1, xmm7
  00e95	48 8b cd	 mov	 rcx, rbp
  00e98	e8 00 00 00 00	 call	 add_right

; 1604 :               e0->outp[ABOVE]= q;
; 1605 :               e1->outp[ABOVE]= NULL;
; 1606 :             }
; 1607 :             break;

  00e9d	e9 51 ff ff ff	 jmp	 $LN371@gpc_polygo
$LN59@gpc_polygo:

; 1592 :           case ILI:
; 1593 :             if (p)

  00ea2	48 85 f6	 test	 rsi, rsi
  00ea5	74 5f		 je	 SHORT $LN356@gpc_polygo

; 1594 :             {
; 1595 :               add_left(p, ix, iy);

  00ea7	66 0f 28 d6	 movapd	 xmm2, xmm6
  00eab	66 0f 28 cf	 movapd	 xmm1, xmm7
  00eaf	48 8b ce	 mov	 rcx, rsi
  00eb2	e8 00 00 00 00	 call	 add_left

; 1596 :               e1->outp[ABOVE]= p;
; 1597 :               e0->outp[ABOVE]= NULL;
; 1598 :             }
; 1599 :             break;

  00eb7	e9 10 ff ff ff	 jmp	 $LN369@gpc_polygo
$LN51@gpc_polygo:

; 1626 :           case EMM:
; 1627 :             if (p && q)

  00ebc	48 85 f6	 test	 rsi, rsi
  00ebf	74 45		 je	 SHORT $LN356@gpc_polygo
  00ec1	48 85 ed	 test	 rbp, rbp
  00ec4	74 40		 je	 SHORT $LN356@gpc_polygo

; 1628 :             {
; 1629 :               add_left(p, ix, iy);

  00ec6	66 0f 28 d6	 movapd	 xmm2, xmm6
  00eca	66 0f 28 cf	 movapd	 xmm1, xmm7
  00ece	48 8b ce	 mov	 rcx, rsi
  00ed1	e8 00 00 00 00	 call	 add_left

; 1630 :               merge_right(p, q, out_poly);

  00ed6	4d 8b c6	 mov	 r8, r14
  00ed9	48 8b d5	 mov	 rdx, rbp
  00edc	48 8b ce	 mov	 rcx, rsi
  00edf	e8 00 00 00 00	 call	 merge_right
$LN368@gpc_polygo:

; 1631 :               add_local_min(&out_poly, e0, ix, iy);

  00ee4	48 8d 4c 24 58	 lea	 rcx, QWORD PTR out_poly$[rsp]
  00ee9	66 0f 28 de	 movapd	 xmm3, xmm6
  00eed	66 0f 28 d7	 movapd	 xmm2, xmm7
  00ef1	48 8b d7	 mov	 rdx, rdi
  00ef4	e8 00 00 00 00	 call	 add_local_min

; 1632 :               e1->outp[ABOVE]= e0->outp[ABOVE];

  00ef9	4c 8b 5f 70	 mov	 r11, QWORD PTR [rdi+112]
  00efd	4c 8b 74 24 58	 mov	 r14, QWORD PTR out_poly$[rsp]
  00f02	4c 89 5b 70	 mov	 QWORD PTR [rbx+112], r11
$LN356@gpc_polygo:

; 1176 :     s_heap= build_lmt(&lmt, &sbtree, &sbt_entries, subj, SUBJ, op);

  00f06	41 bb 01 00 00
	00		 mov	 r11d, 1
$LN50@gpc_polygo:

; 1633 :             }
; 1634 :             break;
; 1635 :           default:
; 1636 :             break;
; 1637 :           } /* End of switch */
; 1638 : 	} /* End of contributing intersection conditional */
; 1639 : 
; 1640 :         /* Swap bundle sides in response to edge crossing */
; 1641 :         if (e0->bundle[ABOVE][CLIP])

  00f0c	83 7f 4c 00	 cmp	 DWORD PTR [rdi+76], 0
  00f10	74 0b		 je	 SHORT $LN48@gpc_polygo

; 1642 : 	  e1->bside[CLIP]= !e1->bside[CLIP];

  00f12	33 c0		 xor	 eax, eax
  00f14	39 43 5c	 cmp	 DWORD PTR [rbx+92], eax
  00f17	0f 94 c0	 sete	 al
  00f1a	89 43 5c	 mov	 DWORD PTR [rbx+92], eax
$LN48@gpc_polygo:

; 1643 :         if (e1->bundle[ABOVE][CLIP])

  00f1d	83 7b 4c 00	 cmp	 DWORD PTR [rbx+76], 0
  00f21	74 0b		 je	 SHORT $LN47@gpc_polygo

; 1644 : 	  e0->bside[CLIP]= !e0->bside[CLIP];

  00f23	33 c0		 xor	 eax, eax
  00f25	39 47 5c	 cmp	 DWORD PTR [rdi+92], eax
  00f28	0f 94 c0	 sete	 al
  00f2b	89 47 5c	 mov	 DWORD PTR [rdi+92], eax
$LN47@gpc_polygo:

; 1645 :         if (e0->bundle[ABOVE][SUBJ])

  00f2e	83 7f 50 00	 cmp	 DWORD PTR [rdi+80], 0
  00f32	74 0b		 je	 SHORT $LN46@gpc_polygo

; 1646 : 	  e1->bside[SUBJ]= !e1->bside[SUBJ];

  00f34	33 c0		 xor	 eax, eax
  00f36	39 43 60	 cmp	 DWORD PTR [rbx+96], eax
  00f39	0f 94 c0	 sete	 al
  00f3c	89 43 60	 mov	 DWORD PTR [rbx+96], eax
$LN46@gpc_polygo:

; 1647 :         if (e1->bundle[ABOVE][SUBJ])

  00f3f	83 7b 50 00	 cmp	 DWORD PTR [rbx+80], 0
  00f43	74 0b		 je	 SHORT $LN45@gpc_polygo

; 1648 : 	  e0->bside[SUBJ]= !e0->bside[SUBJ];

  00f45	33 c0		 xor	 eax, eax
  00f47	39 47 60	 cmp	 DWORD PTR [rdi+96], eax
  00f4a	0f 94 c0	 sete	 al
  00f4d	89 47 60	 mov	 DWORD PTR [rdi+96], eax
$LN45@gpc_polygo:

; 1649 : 
; 1650 :         /* Swap e0 and e1 bundles in the AET */
; 1651 :         prev_edge= e0->prev;
; 1652 :         next_edge= e1->next;

  00f50	48 8b 93 88 00
	00 00		 mov	 rdx, QWORD PTR [rbx+136]
  00f57	48 8b 8f 80 00
	00 00		 mov	 rcx, QWORD PTR [rdi+128]

; 1653 :         if (next_edge)

  00f5e	48 85 d2	 test	 rdx, rdx
  00f61	74 07		 je	 SHORT $LN44@gpc_polygo

; 1654 :           next_edge->prev= e0;

  00f63	48 89 ba 80 00
	00 00		 mov	 QWORD PTR [rdx+128], rdi
$LN44@gpc_polygo:

; 1655 : 
; 1656 :         if (e0->bstate[ABOVE] == BUNDLE_HEAD)

  00f6a	44 39 5f 64	 cmp	 DWORD PTR [rdi+100], r11d
  00f6e	75 1b		 jne	 SHORT $LN41@gpc_polygo

; 1657 :         {
; 1658 :           search= TRUE;

  00f70	41 8b c3	 mov	 eax, r11d
$LL42@gpc_polygo:

; 1660 :           {
; 1661 :             prev_edge= prev_edge->prev;

  00f73	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]

; 1662 :             if (prev_edge)

  00f7a	48 85 c9	 test	 rcx, rcx
  00f7d	74 06		 je	 SHORT $LN40@gpc_polygo

; 1663 :             {
; 1664 :               if (prev_edge->bstate[ABOVE] != BUNDLE_TAIL)

  00f7f	83 79 64 02	 cmp	 DWORD PTR [rcx+100], 2
  00f83	74 02		 je	 SHORT $LN38@gpc_polygo
$LN40@gpc_polygo:

; 1665 :                 search= FALSE;
; 1666 :             }
; 1667 :             else
; 1668 :               search= FALSE;

  00f85	33 c0		 xor	 eax, eax
$LN38@gpc_polygo:

; 1659 :           while (search)

  00f87	85 c0		 test	 eax, eax
  00f89	75 e8		 jne	 SHORT $LL42@gpc_polygo
$LN41@gpc_polygo:

; 1669 :           }
; 1670 :         }
; 1671 :         if (!prev_edge)

  00f8b	48 85 c9	 test	 rcx, rcx
  00f8e	75 17		 jne	 SHORT $LN37@gpc_polygo

; 1672 :         {
; 1673 :           aet->prev= e1;

  00f90	49 89 9f 80 00
	00 00		 mov	 QWORD PTR [r15+128], rbx

; 1674 :           e1->next= aet;

  00f97	4c 89 bb 88 00
	00 00		 mov	 QWORD PTR [rbx+136], r15

; 1675 :           aet= e0->next;

  00f9e	4c 8b bf 88 00
	00 00		 mov	 r15, QWORD PTR [rdi+136]

; 1676 :         }
; 1677 :         else

  00fa5	eb 2a		 jmp	 SHORT $LN36@gpc_polygo
$LN37@gpc_polygo:

; 1678 :         {
; 1679 :           prev_edge->next->prev= e1;

  00fa7	48 8b 81 88 00
	00 00		 mov	 rax, QWORD PTR [rcx+136]
  00fae	48 89 98 80 00
	00 00		 mov	 QWORD PTR [rax+128], rbx

; 1680 :           e1->next= prev_edge->next;

  00fb5	48 8b 81 88 00
	00 00		 mov	 rax, QWORD PTR [rcx+136]
  00fbc	48 89 83 88 00
	00 00		 mov	 QWORD PTR [rbx+136], rax

; 1681 :           prev_edge->next= e0->next;

  00fc3	48 8b 87 88 00
	00 00		 mov	 rax, QWORD PTR [rdi+136]
  00fca	48 89 81 88 00
	00 00		 mov	 QWORD PTR [rcx+136], rax
$LN36@gpc_polygo:

; 1682 :         }
; 1683 :         e0->next->prev= prev_edge;

  00fd1	48 8b 87 88 00
	00 00		 mov	 rax, QWORD PTR [rdi+136]
  00fd8	48 89 88 80 00
	00 00		 mov	 QWORD PTR [rax+128], rcx

; 1684 :         e1->next->prev= e1;

  00fdf	48 8b 83 88 00
	00 00		 mov	 rax, QWORD PTR [rbx+136]
  00fe6	48 89 98 80 00
	00 00		 mov	 QWORD PTR [rax+128], rbx

; 1685 :         e0->next= next_edge;

  00fed	48 89 97 88 00
	00 00		 mov	 QWORD PTR [rdi+136], rdx
  00ff4	4d 8b 64 24 20	 mov	 r12, QWORD PTR [r12+32]
  00ff9	4d 85 e4	 test	 r12, r12
  00ffc	0f 85 45 fb ff
	ff		 jne	 $LL80@gpc_polygo
  01002	8b 54 24 48	 mov	 edx, DWORD PTR scanbeam$[rsp]
  01006	44 89 6c 24 3c	 mov	 DWORD PTR bl$[rsp], r13d
  0100b	4c 8b ac 24 78
	01 00 00	 mov	 r13, QWORD PTR result$[rsp]
  01013	4c 89 7c 24 70	 mov	 QWORD PTR aet$[rsp], r15
$LN78@gpc_polygo:

; 1686 :       } /* End of IT loop*/
; 1687 : 
; 1688 :       /* Prepare for next scanbeam */
; 1689 :       for (edge= aet; edge; edge= next_edge)

  01018	49 8b cf	 mov	 rcx, r15
  0101b	4d 85 ff	 test	 r15, r15
  0101e	0f 84 ab 00 00
	00		 je	 $LN33@gpc_polygo
$LL35@gpc_polygo:

; 1690 :       {
; 1691 :         next_edge= edge->next;
; 1692 :         succ_edge= edge->succ;
; 1693 : 
; 1694 :         if ((edge->top.y == yt) && succ_edge)

  01024	f2 0f 10 41 28	 movsdx	 xmm0, QWORD PTR [rcx+40]
  01029	4c 8b 81 88 00
	00 00		 mov	 r8, QWORD PTR [rcx+136]
  01030	48 8b 91 98 00
	00 00		 mov	 rdx, QWORD PTR [rcx+152]
  01037	66 41 0f 2e c1	 ucomisd xmm0, xmm9
  0103c	7a 55		 jp	 SHORT $LN32@gpc_polygo
  0103e	75 53		 jne	 SHORT $LN32@gpc_polygo
  01040	48 85 d2	 test	 rdx, rdx
  01043	74 4e		 je	 SHORT $LN32@gpc_polygo

; 1695 :         {
; 1696 :           /* Replace AET edge by its successor */
; 1697 :           succ_edge->outp[BELOW]= edge->outp[ABOVE];

  01045	48 8b 41 70	 mov	 rax, QWORD PTR [rcx+112]
  01049	48 89 42 78	 mov	 QWORD PTR [rdx+120], rax

; 1698 :           succ_edge->bstate[BELOW]= edge->bstate[ABOVE];

  0104d	8b 41 64	 mov	 eax, DWORD PTR [rcx+100]
  01050	89 42 68	 mov	 DWORD PTR [rdx+104], eax

; 1699 :           succ_edge->bundle[BELOW][CLIP]= edge->bundle[ABOVE][CLIP];

  01053	8b 41 4c	 mov	 eax, DWORD PTR [rcx+76]
  01056	89 42 54	 mov	 DWORD PTR [rdx+84], eax

; 1700 :           succ_edge->bundle[BELOW][SUBJ]= edge->bundle[ABOVE][SUBJ];

  01059	8b 41 50	 mov	 eax, DWORD PTR [rcx+80]
  0105c	89 42 58	 mov	 DWORD PTR [rdx+88], eax

; 1701 :           prev_edge= edge->prev;

  0105f	48 8b 81 80 00
	00 00		 mov	 rax, QWORD PTR [rcx+128]

; 1702 :           if (prev_edge)

  01066	48 85 c0	 test	 rax, rax
  01069	74 09		 je	 SHORT $LN31@gpc_polygo

; 1703 :             prev_edge->next= succ_edge;

  0106b	48 89 90 88 00
	00 00		 mov	 QWORD PTR [rax+136], rdx

; 1704 :           else

  01072	eb 03		 jmp	 SHORT $LN30@gpc_polygo
$LN31@gpc_polygo:

; 1705 :             aet= succ_edge;

  01074	4c 8b fa	 mov	 r15, rdx
$LN30@gpc_polygo:

; 1706 :           if (next_edge)

  01077	4d 85 c0	 test	 r8, r8
  0107a	74 07		 je	 SHORT $LN29@gpc_polygo

; 1707 :             next_edge->prev= succ_edge;

  0107c	49 89 90 80 00
	00 00		 mov	 QWORD PTR [r8+128], rdx
$LN29@gpc_polygo:

; 1708 :           succ_edge->prev= prev_edge;

  01083	48 89 82 80 00
	00 00		 mov	 QWORD PTR [rdx+128], rax

; 1709 :           succ_edge->next= next_edge;

  0108a	4c 89 82 88 00
	00 00		 mov	 QWORD PTR [rdx+136], r8

; 1710 :         }
; 1711 :         else

  01091	eb 22		 jmp	 SHORT $LN28@gpc_polygo
$LN32@gpc_polygo:

; 1712 :         {
; 1713 :           /* Update this edge */
; 1714 :           edge->outp[BELOW]= edge->outp[ABOVE];

  01093	48 8b 41 70	 mov	 rax, QWORD PTR [rcx+112]
  01097	48 89 41 78	 mov	 QWORD PTR [rcx+120], rax

; 1715 :           edge->bstate[BELOW]= edge->bstate[ABOVE];

  0109b	8b 41 64	 mov	 eax, DWORD PTR [rcx+100]
  0109e	89 41 68	 mov	 DWORD PTR [rcx+104], eax

; 1716 :           edge->bundle[BELOW][CLIP]= edge->bundle[ABOVE][CLIP];

  010a1	8b 41 4c	 mov	 eax, DWORD PTR [rcx+76]
  010a4	89 41 54	 mov	 DWORD PTR [rcx+84], eax

; 1717 :           edge->bundle[BELOW][SUBJ]= edge->bundle[ABOVE][SUBJ];

  010a7	8b 41 50	 mov	 eax, DWORD PTR [rcx+80]
  010aa	89 41 58	 mov	 DWORD PTR [rcx+88], eax

; 1718 :           edge->xb= edge->xt;

  010ad	48 8b 41 38	 mov	 rax, QWORD PTR [rcx+56]
  010b1	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax
$LN28@gpc_polygo:

; 1719 : 	      }
; 1720 :         edge->outp[ABOVE]= NULL;

  010b5	48 83 61 70 00	 and	 QWORD PTR [rcx+112], 0
  010ba	49 8b c8	 mov	 rcx, r8
  010bd	4d 85 c0	 test	 r8, r8
  010c0	0f 85 5e ff ff
	ff		 jne	 $LL35@gpc_polygo
  010c6	8b 54 24 48	 mov	 edx, DWORD PTR scanbeam$[rsp]
  010ca	4c 89 7c 24 70	 mov	 QWORD PTR aet$[rsp], r15
$LN33@gpc_polygo:
  010cf	3b 54 24 4c	 cmp	 edx, DWORD PTR sbt_entries$[rsp]
  010d3	44 8b a4 24 60
	01 00 00	 mov	 r12d, DWORD PTR op$[rsp]
  010db	48 8b ac 24 80
	00 00 00	 mov	 rbp, QWORD PTR sbt$1$[rsp]
  010e3	4c 8b 94 24 98
	00 00 00	 mov	 r10, QWORD PTR local_min$1$[rsp]
  010eb	0f 8c 9a f1 ff
	ff		 jl	 $LL143@gpc_polygo
$LN322@gpc_polygo:

; 1721 :       }
; 1722 :     }
; 1723 :   } /* === END OF SCANBEAM PROCESSING ================================== */
; 1724 : 
; 1725 :   /* Generate result polygon from out_poly */
; 1726 :   result->contour= NULL;

  010f1	49 83 65 10 00	 and	 QWORD PTR [r13+16], 0

; 1727 :   result->hole= NULL;

  010f6	49 83 65 08 00	 and	 QWORD PTR [r13+8], 0

; 1728 :   result->num_contours= count_contours(out_poly);

  010fb	33 f6		 xor	 esi, esi
  010fd	49 8b fe	 mov	 rdi, r14
  01100	4d 85 f6	 test	 r14, r14
  01103	74 57		 je	 SHORT $LN268@gpc_polygo
$LL270@gpc_polygo:
  01105	83 3f 00	 cmp	 DWORD PTR [rdi], 0
  01108	74 43		 je	 SHORT $LN269@gpc_polygo
  0110a	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  0110e	33 d2		 xor	 edx, edx
  01110	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  01114	48 8b c1	 mov	 rax, rcx
  01117	48 85 c9	 test	 rcx, rcx
  0111a	74 2e		 je	 SHORT $LN259@gpc_polygo
$LL266@gpc_polygo:
  0111c	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  01120	41 03 d3	 add	 edx, r11d
  01123	48 85 c0	 test	 rax, rax
  01126	75 f4		 jne	 SHORT $LL266@gpc_polygo
  01128	83 fa 02	 cmp	 edx, 2
  0112b	7e 07		 jle	 SHORT $LN263@gpc_polygo
  0112d	89 17		 mov	 DWORD PTR [rdi], edx
  0112f	41 03 f3	 add	 esi, r11d
  01132	eb 19		 jmp	 SHORT $LN269@gpc_polygo
$LN263@gpc_polygo:
  01134	48 85 c9	 test	 rcx, rcx
  01137	74 11		 je	 SHORT $LN259@gpc_polygo
$LL261@gpc_polygo:
  01139	48 8b 59 10	 mov	 rbx, QWORD PTR [rcx+16]
  0113d	e8 00 00 00 00	 call	 free
  01142	48 8b cb	 mov	 rcx, rbx
  01145	48 85 db	 test	 rbx, rbx
  01148	75 ef		 jne	 SHORT $LL261@gpc_polygo
$LN259@gpc_polygo:
  0114a	83 27 00	 and	 DWORD PTR [rdi], 0
$LN269@gpc_polygo:
  0114d	48 8b 7f 18	 mov	 rdi, QWORD PTR [rdi+24]
  01151	41 bb 01 00 00
	00		 mov	 r11d, 1
  01157	48 85 ff	 test	 rdi, rdi
  0115a	75 a9		 jne	 SHORT $LL270@gpc_polygo
$LN268@gpc_polygo:
  0115c	41 89 75 00	 mov	 DWORD PTR [r13], esi

; 1729 :   if (result->num_contours > 0)

  01160	85 f6		 test	 esi, esi
  01162	0f 8e 83 01 00
	00		 jle	 $LN27@gpc_polygo

; 1730 :   {
; 1731 :     MALLOC(result->hole, result->num_contours
; 1732 :            * sizeof(int), "hole flag table creation", int);

  01168	48 63 ce	 movsxd	 rcx, esi
  0116b	48 c1 e1 02	 shl	 rcx, 2
  0116f	48 85 c9	 test	 rcx, rcx
  01172	74 32		 je	 SHORT $LN26@gpc_polygo
  01174	e8 00 00 00 00	 call	 malloc
  01179	49 89 45 08	 mov	 QWORD PTR [r13+8], rax
  0117d	48 85 c0	 test	 rax, rax
  01180	75 29		 jne	 SHORT $LN24@gpc_polygo
  01182	e8 00 00 00 00	 call	 __iob_func
  01187	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BJ@CMCBODNK@hole?5flag?5table?5creation?$AA@
  0118e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@GBJAADOD@gpc?5malloc?5failure?3?5?$CFs?6?$AA@
  01195	48 8d 48 60	 lea	 rcx, QWORD PTR [rax+96]
  01199	e8 00 00 00 00	 call	 fprintf
  0119e	33 c9		 xor	 ecx, ecx
  011a0	e8 00 00 00 00	 call	 exit
  011a5	cc		 int	 3
$LN26@gpc_polygo:
  011a6	49 83 65 08 00	 and	 QWORD PTR [r13+8], 0
$LN24@gpc_polygo:

; 1733 :     MALLOC(result->contour, result->num_contours
; 1734 :            * sizeof(gpc_vertex_list), "contour creation", gpc_vertex_list);

  011ab	49 63 4d 00	 movsxd	 rcx, DWORD PTR [r13]
  011af	48 c1 e1 04	 shl	 rcx, 4
  011b3	48 85 c9	 test	 rcx, rcx
  011b6	74 32		 je	 SHORT $LN23@gpc_polygo
  011b8	e8 00 00 00 00	 call	 malloc
  011bd	49 89 45 10	 mov	 QWORD PTR [r13+16], rax
  011c1	48 85 c0	 test	 rax, rax
  011c4	75 29		 jne	 SHORT $LN21@gpc_polygo
  011c6	e8 00 00 00 00	 call	 __iob_func
  011cb	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BB@OCAHDIFD@contour?5creation?$AA@
  011d2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@GBJAADOD@gpc?5malloc?5failure?3?5?$CFs?6?$AA@
  011d9	48 8d 48 60	 lea	 rcx, QWORD PTR [rax+96]
  011dd	e8 00 00 00 00	 call	 fprintf
  011e2	33 c9		 xor	 ecx, ecx
  011e4	e8 00 00 00 00	 call	 exit
  011e9	cc		 int	 3
$LN23@gpc_polygo:
  011ea	49 83 65 10 00	 and	 QWORD PTR [r13+16], 0
$LN21@gpc_polygo:

; 1735 : 
; 1736 :     c= 0;
; 1737 :     for (poly= out_poly; poly; poly= npoly)

  011ef	4d 85 f6	 test	 r14, r14
  011f2	0f 84 0c 01 00
	00		 je	 $LN301@gpc_polygo
  011f8	33 ff		 xor	 edi, edi
  011fa	33 ed		 xor	 ebp, ebp
$LL20@gpc_polygo:

; 1738 :     {
; 1739 :       npoly= poly->next;
; 1740 :       if (poly->active)

  011fc	41 83 3e 00	 cmp	 DWORD PTR [r14], 0
  01200	4d 8b 66 18	 mov	 r12, QWORD PTR [r14+24]
  01204	0f 84 cc 00 00
	00		 je	 $LN17@gpc_polygo

; 1741 :       {
; 1742 :         result->hole[c]= poly->proxy->hole;

  0120a	49 8b 46 20	 mov	 rax, QWORD PTR [r14+32]
  0120e	49 8b 4d 08	 mov	 rcx, QWORD PTR [r13+8]
  01212	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  01215	89 04 29	 mov	 DWORD PTR [rcx+rbp], eax

; 1743 :         result->contour[c].num_vertices= poly->active;

  01218	49 8b 4d 10	 mov	 rcx, QWORD PTR [r13+16]
  0121c	41 8b 06	 mov	 eax, DWORD PTR [r14]
  0121f	89 04 0f	 mov	 DWORD PTR [rdi+rcx], eax

; 1744 :         MALLOC(result->contour[c].vertex,
; 1745 :           result->contour[c].num_vertices * sizeof(gpc_vertex),
; 1746 :           "vertex creation", gpc_vertex);

  01222	49 8b 45 10	 mov	 rax, QWORD PTR [r13+16]
  01226	48 63 0c 07	 movsxd	 rcx, DWORD PTR [rdi+rax]
  0122a	48 c1 e1 04	 shl	 rcx, 4
  0122e	48 85 c9	 test	 rcx, rcx
  01231	74 3e		 je	 SHORT $LN16@gpc_polygo
  01233	e8 00 00 00 00	 call	 malloc
  01238	49 8b 4d 10	 mov	 rcx, QWORD PTR [r13+16]
  0123c	48 89 44 0f 08	 mov	 QWORD PTR [rdi+rcx+8], rax
  01241	49 8b 45 10	 mov	 rax, QWORD PTR [r13+16]
  01245	48 83 7c 07 08
	00		 cmp	 QWORD PTR [rdi+rax+8], 0
  0124b	75 2a		 jne	 SHORT $LN14@gpc_polygo
  0124d	e8 00 00 00 00	 call	 __iob_func
  01252	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BA@EHDPPPDI@vertex?5creation?$AA@
  01259	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@GBJAADOD@gpc?5malloc?5failure?3?5?$CFs?6?$AA@
  01260	48 8d 48 60	 lea	 rcx, QWORD PTR [rax+96]
  01264	e8 00 00 00 00	 call	 fprintf
  01269	33 c9		 xor	 ecx, ecx
  0126b	e8 00 00 00 00	 call	 exit
  01270	cc		 int	 3
$LN16@gpc_polygo:
  01271	48 83 64 07 08
	00		 and	 QWORD PTR [rdi+rax+8], 0
$LN14@gpc_polygo:

; 1747 :       
; 1748 :         v= result->contour[c].num_vertices - 1;

  01277	49 8b 45 10	 mov	 rax, QWORD PTR [r13+16]
  0127b	8b 0c 07	 mov	 ecx, DWORD PTR [rdi+rax]

; 1749 :         for (vtx= poly->proxy->v[LEFT]; vtx; vtx= nv)

  0127e	49 8b 46 20	 mov	 rax, QWORD PTR [r14+32]
  01282	4c 8b 40 08	 mov	 r8, QWORD PTR [rax+8]
  01286	ff c9		 dec	 ecx
  01288	48 63 f1	 movsxd	 rsi, ecx
  0128b	4d 85 c0	 test	 r8, r8
  0128e	74 3e		 je	 SHORT $LN11@gpc_polygo

; 1747 :       
; 1748 :         v= result->contour[c].num_vertices - 1;

  01290	48 c1 e6 04	 shl	 rsi, 4
$LL13@gpc_polygo:

; 1750 :         {
; 1751 :           nv= vtx->next;
; 1752 :           result->contour[c].vertex[v].x= vtx->x;

  01294	49 8b 45 10	 mov	 rax, QWORD PTR [r13+16]
  01298	49 8b 58 10	 mov	 rbx, QWORD PTR [r8+16]

; 1753 :           result->contour[c].vertex[v].y= vtx->y;
; 1754 :           FREE(vtx);

  0129c	49 8b c8	 mov	 rcx, r8
  0129f	48 8b 54 07 08	 mov	 rdx, QWORD PTR [rdi+rax+8]
  012a4	49 8b 00	 mov	 rax, QWORD PTR [r8]
  012a7	48 89 04 16	 mov	 QWORD PTR [rsi+rdx], rax
  012ab	49 8b 45 10	 mov	 rax, QWORD PTR [r13+16]
  012af	48 8b 54 07 08	 mov	 rdx, QWORD PTR [rdi+rax+8]
  012b4	49 8b 40 08	 mov	 rax, QWORD PTR [r8+8]
  012b8	48 89 44 32 08	 mov	 QWORD PTR [rdx+rsi+8], rax
  012bd	e8 00 00 00 00	 call	 free

; 1755 :           v--;

  012c2	48 83 ee 10	 sub	 rsi, 16
  012c6	4c 8b c3	 mov	 r8, rbx
  012c9	48 85 db	 test	 rbx, rbx
  012cc	75 c6		 jne	 SHORT $LL13@gpc_polygo
$LN11@gpc_polygo:

; 1756 :         }
; 1757 :         c++;

  012ce	48 83 c5 04	 add	 rbp, 4
  012d2	48 83 c7 10	 add	 rdi, 16
$LN17@gpc_polygo:

; 1758 :       }
; 1759 :       FREE(poly);

  012d6	49 8b ce	 mov	 rcx, r14
  012d9	e8 00 00 00 00	 call	 free
  012de	4d 8b f4	 mov	 r14, r12
  012e1	4d 85 e4	 test	 r12, r12
  012e4	74 1e		 je	 SHORT $LN301@gpc_polygo

; 1735 : 
; 1736 :     c= 0;
; 1737 :     for (poly= out_poly; poly; poly= npoly)

  012e6	e9 11 ff ff ff	 jmp	 $LL20@gpc_polygo
$LN27@gpc_polygo:

; 1760 :     }
; 1761 :   }
; 1762 :   else
; 1763 :   {
; 1764 :     for (poly= out_poly; poly; poly= npoly)

  012eb	4d 85 f6	 test	 r14, r14
  012ee	74 14		 je	 SHORT $LN301@gpc_polygo
$LL7@gpc_polygo:

; 1765 :     {
; 1766 :       npoly= poly->next;

  012f0	49 8b 5e 18	 mov	 rbx, QWORD PTR [r14+24]

; 1767 :       FREE(poly);

  012f4	49 8b ce	 mov	 rcx, r14
  012f7	e8 00 00 00 00	 call	 free
  012fc	4c 8b f3	 mov	 r14, rbx
  012ff	48 85 db	 test	 rbx, rbx
  01302	75 ec		 jne	 SHORT $LL7@gpc_polygo
$LN301@gpc_polygo:

; 1768 :     }
; 1769 :   }
; 1770 : 
; 1771 :   /* Tidy up */
; 1772 :   reset_it(&it);

  01304	48 83 7c 24 68
	00		 cmp	 QWORD PTR it$[rsp], 0
  0130a	74 1c		 je	 SHORT $LN340@gpc_polygo
$LL275@gpc_polygo:
  0130c	4c 8b 64 24 68	 mov	 r12, QWORD PTR it$[rsp]
  01311	49 8b cc	 mov	 rcx, r12
  01314	49 8b 5c 24 20	 mov	 rbx, QWORD PTR [r12+32]
  01319	e8 00 00 00 00	 call	 free
  0131e	48 89 5c 24 68	 mov	 QWORD PTR it$[rsp], rbx
  01323	48 85 db	 test	 rbx, rbx
  01326	75 e4		 jne	 SHORT $LL275@gpc_polygo
$LN340@gpc_polygo:
  01328	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR lmt$1$[rsp]

; 1773 :   reset_lmt(&lmt);

$LL280@gpc_polygo:
  01330	48 8b 59 10	 mov	 rbx, QWORD PTR [rcx+16]
  01334	e8 00 00 00 00	 call	 free
  01339	48 8b cb	 mov	 rcx, rbx
  0133c	48 85 db	 test	 rbx, rbx
  0133f	75 ef		 jne	 SHORT $LL280@gpc_polygo

; 1774 :   FREE(c_heap);

  01341	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR c_heap$1$[rsp]
  01349	48 85 c9	 test	 rcx, rcx
  0134c	74 05		 je	 SHORT $LN3@gpc_polygo
  0134e	e8 00 00 00 00	 call	 free
$LN3@gpc_polygo:

; 1775 :   FREE(s_heap);

  01353	48 8b 4c 24 78	 mov	 rcx, QWORD PTR s_heap$1$[rsp]
  01358	48 85 c9	 test	 rcx, rcx
  0135b	74 05		 je	 SHORT $LN2@gpc_polygo
  0135d	e8 00 00 00 00	 call	 free
$LN2@gpc_polygo:

; 1776 :   FREE(sbt);

  01362	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR sbt$1$[rsp]
  0136a	48 85 c9	 test	 rcx, rcx
  0136d	74 05		 je	 SHORT $LN1@gpc_polygo
$LN359@gpc_polygo:
  0136f	e8 00 00 00 00	 call	 free
$LN1@gpc_polygo:

; 1777 : }

  01374	4c 8d 9c 24 20
	01 00 00	 lea	 r11, QWORD PTR [rsp+288]
  0137c	49 8b 5b 50	 mov	 rbx, QWORD PTR [r11+80]
  01380	41 0f 28 73 f0	 movaps	 xmm6, XMMWORD PTR [r11-16]
  01385	41 0f 28 7b e0	 movaps	 xmm7, XMMWORD PTR [r11-32]
  0138a	45 0f 28 43 d0	 movaps	 xmm8, XMMWORD PTR [r11-48]
  0138f	45 0f 28 4b c0	 movaps	 xmm9, XMMWORD PTR [r11-64]
  01394	45 0f 28 53 b0	 movaps	 xmm10, XMMWORD PTR [r11-80]
  01399	45 0f 28 5b a0	 movaps	 xmm11, XMMWORD PTR [r11-96]
  0139e	45 0f 28 63 90	 movaps	 xmm12, XMMWORD PTR [r11-112]
  013a3	49 8b e3	 mov	 rsp, r11
  013a6	41 5f		 pop	 r15
  013a8	41 5e		 pop	 r14
  013aa	41 5d		 pop	 r13
  013ac	41 5c		 pop	 r12
  013ae	5f		 pop	 rdi
  013af	5e		 pop	 rsi
  013b0	5d		 pop	 rbp
  013b1	c3		 ret	 0
$LN358@gpc_polygo:
gpc_polygon_clip ENDP
END
